{
  "version": 3,
  "sources": ["../node_modules/pixi.js/src/extensions/Extensions.ts", "../node_modules/eventemitter3/index.js", "../node_modules/eventemitter3/index.mjs", "../node_modules/@pixi/colord/index.mjs", "../node_modules/@pixi/colord/plugins/names.mjs", "../node_modules/pixi.js/src/color/Color.ts", "../node_modules/pixi.js/src/culling/cullingMixin.ts", "../node_modules/pixi.js/src/maths/misc/const.ts", "../node_modules/pixi.js/src/maths/point/Point.ts", "../node_modules/pixi.js/src/maths/matrix/Matrix.ts", "../node_modules/pixi.js/src/maths/point/ObservablePoint.ts", "../node_modules/pixi.js/src/utils/data/uid.ts", "../node_modules/pixi.js/src/utils/logging/deprecation.ts", "../node_modules/pixi.js/src/utils/logging/warn.ts", "../node_modules/pixi.js/src/utils/pool/GlobalResourceRegistry.ts", "../node_modules/pixi.js/src/utils/pool/Pool.ts", "../node_modules/pixi.js/src/utils/pool/PoolGroup.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/cacheAsTextureMixin.ts", "../node_modules/pixi.js/src/utils/data/removeItems.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/collectRenderablesMixin.ts", "../node_modules/pixi.js/src/filters/FilterEffect.ts", "../node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts", "../node_modules/pixi.js/src/maths/shapes/Rectangle.ts", "../node_modules/pixi.js/src/scene/container/bounds/Bounds.ts", "../node_modules/pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/getFastGlobalBoundsMixin.ts", "../node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts", "../node_modules/pixi.js/src/scene/container/utils/multiplyHexColors.ts", "../node_modules/pixi.js/src/scene/container/utils/multiplyColors.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/getGlobalMixin.ts", "../node_modules/pixi.js/src/scene/container/bounds/getLocalBounds.ts", "../node_modules/pixi.js/src/scene/container/utils/checkChildrenDidChange.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/onRenderMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/sortMixin.ts", "../node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts", "../node_modules/pixi.js/src/maths/misc/pow2.ts", "../node_modules/pixi.js/src/scene/container/utils/definedProps.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts", "../node_modules/pixi.js/src/maths/matrix/groupD8.ts", "../node_modules/pixi.js/src/utils/misc/NOOP.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferImageSource.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts", "../node_modules/pixi.js/src/scene/container/RenderGroup.ts", "../node_modules/pixi.js/src/scene/container/utils/assignWithIgnore.ts", "../node_modules/pixi.js/src/scene/container/Container.ts", "../node_modules/pixi.js/src/ticker/const.ts", "../node_modules/pixi.js/src/ticker/TickerListener.ts", "../node_modules/pixi.js/src/ticker/Ticker.ts", "../node_modules/pixi.js/src/dom/CanvasObserver.ts", "../node_modules/pixi.js/src/events/FederatedEvent.ts", "../node_modules/ismobilejs/src/isMobile.ts", "../node_modules/ismobilejs/src/index.ts", "../node_modules/pixi.js/src/utils/browser/isMobile.ts", "../node_modules/pixi.js/src/accessibility/AccessibilitySystem.ts", "../node_modules/pixi.js/src/accessibility/accessibilityTarget.ts", "../node_modules/pixi.js/src/accessibility/init.ts", "../node_modules/pixi.js/src/app/ResizePlugin.ts", "../node_modules/pixi.js/src/app/TickerPlugin.ts", "../node_modules/pixi.js/src/app/init.ts", "../node_modules/pixi.js/src/events/EventTicker.ts", "../node_modules/pixi.js/src/events/FederatedMouseEvent.ts", "../node_modules/pixi.js/src/events/FederatedPointerEvent.ts", "../node_modules/pixi.js/src/events/FederatedWheelEvent.ts", "../node_modules/pixi.js/src/events/EventBoundary.ts", "../node_modules/pixi.js/src/events/EventSystem.ts", "../node_modules/pixi.js/src/events/FederatedEventTarget.ts", "../node_modules/pixi.js/src/events/init.ts", "../node_modules/pixi.js/src/dom/DOMPipe.ts", "../node_modules/pixi.js/src/scene/view/ViewContainer.ts", "../node_modules/pixi.js/src/dom/init.ts", "../node_modules/pixi.js/src/assets/loader/parsers/LoaderParser.ts", "../node_modules/pixi.js/src/environment-browser/BrowserAdapter.ts", "../node_modules/pixi.js/src/environment/adapter.ts", "../node_modules/pixi.js/src/utils/path.ts", "../node_modules/pixi.js/src/assets/utils/convertToList.ts", "../node_modules/pixi.js/src/assets/utils/createStringVariations.ts", "../node_modules/pixi.js/src/assets/utils/isSingleItem.ts", "../node_modules/pixi.js/src/assets/resolver/Resolver.ts", "../node_modules/pixi.js/src/assets/utils/copySearchParams.ts", "../node_modules/pixi.js/src/spritesheet/Spritesheet.ts", "../node_modules/pixi.js/src/spritesheet/spritesheetAsset.ts", "../node_modules/pixi.js/src/spritesheet/init.ts", "../node_modules/pixi.js/src/utils/data/updateQuadBounds.ts", "../node_modules/pixi.js/src/scene/sprite/Sprite.ts", "../node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts", "../node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts", "../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts", "../node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts", "../node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts", "../node_modules/pixi.js/src/utils/browser/detectVideoAlphaMode.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts", "../node_modules/pixi.js/src/assets/cache/Cache.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts", "../node_modules/pixi.js/src/rendering/init.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts", "../node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts", "../node_modules/pixi.js/src/utils/data/ViewableBuffer.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts", "../node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts", "../node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts", "../node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts", "../node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts", "../node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts", "../node_modules/pixi.js/src/rendering/renderers/types.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts", "../node_modules/pixi.js/src/scene/graphics/shared/BatchableGraphics.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/getOrientationOfPoints.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildLine.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPixelLine.ts", "../node_modules/earcut/src/earcut.js", "../node_modules/pixi.js/src/utils/utils.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/triangulateWithHoles.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildPolygon.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildRectangle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildTriangle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/fill/FillGradient.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/generateTextureFillMatrix.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts", "../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts", "../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts", "../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts", "../node_modules/pixi.js/src/scene/graphics/init.ts", "../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts", "../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts", "../node_modules/pixi.js/src/scene/mesh/init.ts", "../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts", "../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs", "../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs", "../node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs", "../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts", "../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts", "../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts", "../node_modules/pixi.js/src/scene/particle-container/init.ts", "../node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts", "../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts", "../node_modules/pixi.js/src/scene/text/canvas/BatchableText.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts", "../node_modules/pixi.js/src/scene/graphics/shared/fill/FillPattern.ts", "../node_modules/parse-svg-path/index.js", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGPath.ts", "../node_modules/pixi.js/src/maths/shapes/Circle.ts", "../node_modules/pixi.js/src/maths/shapes/Ellipse.ts", "../node_modules/pixi.js/src/maths/misc/squaredDistanceToLineSegment.ts", "../node_modules/pixi.js/src/maths/shapes/Polygon.ts", "../node_modules/pixi.js/src/maths/shapes/RoundedRectangle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveBezier.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArc.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcTo.ts", "../node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildArcToSvg.ts", "../node_modules/pixi.js/src/scene/graphics/shared/path/roundShape.ts", "../node_modules/pixi.js/src/scene/graphics/shared/path/ShapePath.ts", "../node_modules/pixi.js/src/scene/graphics/shared/path/GraphicsPath.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGFloatAttribute.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGDefinitions.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/extractSvgUrlId.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/parseSVGStyle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/fillOperations.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/utils/pathOperations.ts", "../node_modules/pixi.js/src/scene/graphics/shared/svg/SVGParser.ts", "../node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts", "../node_modules/pixi.js/src/scene/graphics/shared/GraphicsContext.ts", "../node_modules/pixi.js/src/scene/text/TextStyle.ts", "../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts", "../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts", "../node_modules/tiny-lru/dist/tiny-lru.js", "../node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts", "../node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextGenerator.ts", "../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts", "../node_modules/pixi.js/src/scene/text/init.ts", "../node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts", "../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts", "../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts", "../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts", "../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts", "../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts", "../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts", "../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts", "../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts", "../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts", "../node_modules/pixi.js/src/scene/text-bitmap/init.ts", "../node_modules/pixi.js/src/scene/text-html/BatchableHTMLText.ts", "../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts", "../node_modules/pixi.js/src/utils/browser/isSafari.ts", "../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts", "../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts", "../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts", "../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts", "../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts", "../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts", "../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts", "../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts", "../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts", "../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts", "../node_modules/pixi.js/src/scene/text-html/init.ts", "../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts", "../node_modules/pixi.js/src/scene/sprite-tiling/init.ts", "../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts", "../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts", "../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts", "../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts", "../node_modules/pixi.js/src/filters/FilterPipe.ts", "../node_modules/pixi.js/src/filters/Filter.ts", "../node_modules/pixi.js/lib/filters/defaults/defaultFilter.vert.mjs", "../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.frag.mjs", "../node_modules/pixi.js/lib/filters/defaults/passthrough/passthrough.wgsl.mjs", "../node_modules/pixi.js/src/filters/defaults/passthrough/PassthroughFilter.ts", "../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts", "../node_modules/pixi.js/src/filters/FilterSystem.ts", "../node_modules/pixi.js/src/filters/init.ts", "../node_modules/pixi.js/lib/environment-browser/browserAll.mjs", "../node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs", "../node_modules/pixi.js/src/environment/autoDetectEnvironment.ts", "../node_modules/pixi.js/src/utils/browser/unsafeEvalSupported.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/const.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts", "../node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts", "../node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts", "../node_modules/pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts", "../node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts", "../node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts", "../node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts", "../node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts", "../node_modules/pixi.js/src/scene/container/utils/clearList.ts", "../node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts", "../node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts", "../node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts", "../node_modules/pixi.js/src/scene/sprite/SpritePipe.ts", "../node_modules/pixi.js/src/utils/const.ts", "../node_modules/pixi.js/src/utils/global/globalHooks.ts", "../node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts", "../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs", "../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs", "../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs", "../node_modules/pixi.js/src/filters/mask/MaskFilter.ts", "../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts", "../node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts", "../node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts", "../node_modules/pixi.js/src/utils/sayHello.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts", "../node_modules/pixi.js/src/utils/data/clean.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuLimitsSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts", "../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts", "../node_modules/pixi.js/src/scene/graphics/gl/GlGraphicsAdaptor.ts", "../node_modules/pixi.js/src/scene/mesh/gl/GlMeshAdaptor.ts", "../node_modules/pixi.js/src/rendering/batcher/gl/GlBatchAdaptor.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/buffer/const.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBuffer.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/buffer/GlBufferSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/context/GlContextSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/const.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/geometry/GlGeometrySystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlBackBufferSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlColorMaskSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlEncoderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlLimitsSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlStencilSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboElementsSTD40.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/createUboSyncSTD40.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlUboSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/GlRenderTarget.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GenerateShaderSyncCode.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgramData.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/compileShader.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/defaultValue.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/mapType.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUboData.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getUniformData.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/logProgramError.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/generateProgram.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlShaderSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/utils/generateUniformsSync.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlUniformGroupSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/state/GlStateSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTexture.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadImageResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/pixiToGlMaps.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/applyStyleParams.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/utils/mapFormatToGlType.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/texture/GlTextureSystem.ts", "../node_modules/pixi.js/src/rendering/renderers/gl/WebGLRenderer.ts", "../node_modules/pixi.js/src/environment-browser/browserExt.ts", "../node_modules/pixi.js/src/environment-webworker/webworkerExt.ts", "../node_modules/pixi.js/src/utils/browser/isWebGLSupported.ts", "../node_modules/pixi.js/src/utils/browser/isWebGPUSupported.ts", "../node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts", "../node_modules/pixi.js/src/app/Application.ts", "../node_modules/pixi.js/src/scene/text-bitmap/BitmapFont.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontTextParser.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLParser.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/bitmapFontXMLStringParser.ts", "../node_modules/pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts", "../node_modules/pixi.js/src/assets/BackgroundLoader.ts", "../node_modules/pixi.js/src/assets/cache/parsers/cacheTextureArray.ts", "../node_modules/pixi.js/src/assets/detections/utils/testImageFormat.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectAvif.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectDefaults.ts", "../node_modules/pixi.js/src/assets/detections/utils/testVideoFormat.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectMp4.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectOgv.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectWebm.ts", "../node_modules/pixi.js/src/assets/detections/parsers/detectWebp.ts", "../node_modules/pixi.js/src/assets/loader/Loader.ts", "../node_modules/pixi.js/src/assets/utils/checkDataUrl.ts", "../node_modules/pixi.js/src/assets/utils/checkExtension.ts", "../node_modules/pixi.js/src/assets/loader/parsers/loadJson.ts", "../node_modules/pixi.js/src/assets/loader/parsers/loadTxt.ts", "../node_modules/pixi.js/src/assets/loader/parsers/loadWebFont.ts", "../node_modules/pixi.js/src/utils/network/getResolutionOfUrl.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/utils/createTexture.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/loadSVG.ts", "../node_modules/pixi.js/lib/_virtual/checkImageBitmap.worker.mjs", "../node_modules/pixi.js/lib/_virtual/loadImageBitmap.worker.mjs", "../node_modules/pixi.js/src/assets/loader/workers/WorkerManager.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/loadTextures.ts", "../node_modules/pixi.js/src/assets/loader/parsers/textures/loadVideoTextures.ts", "../node_modules/pixi.js/src/assets/resolver/parsers/resolveTextureUrl.ts", "../node_modules/pixi.js/src/assets/resolver/parsers/resolveJsonUrl.ts", "../node_modules/pixi.js/src/assets/Assets.ts", "../node_modules/pixi.js/src/scene/text/AbstractText.ts", "../node_modules/pixi.js/src/scene/text/Text.ts", "../node_modules/pixi.js/src/index.ts", "../src/helpers.ts", "../src/vis_stim_manager.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * Collection of valid extension types.\n * @category extensions\n * @advanced\n */\nenum ExtensionType\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n\n    /** A type of extension for building and triangulating custom shapes used in graphics. */\n    ShapeBuilder = 'shape-builder',\n\n    /** A type of extension for creating custom batchers used in rendering. */\n    Batcher = 'batcher',\n}\n\n/**\n * The metadata for an extension.\n * @category extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @category extensions\n * @advanced\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @category extensions\n * @advanced\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @category extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\n/**\n * The function that is called when an extension is added or removed.\n * @category extensions\n * @ignore\n */\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @category extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration system for all PixiJS extensions. Provides a centralized way to add, remove,\n * and manage functionality across the engine.\n *\n * Features:\n * - Register custom extensions and plugins\n * - Handle multiple extension types\n * - Priority-based ordering\n * @example\n * ```ts\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // Register a simple object extension\n * extensions.add({\n *   extension: {\n *       type: ExtensionType.LoadParser,\n *       name: 'my-loader',\n *       priority: 100, // Optional priority for ordering\n *   },\n *   // add load parser functions\n * });\n *\n * // Register a class-based extension\n * class MyRendererPlugin {\n *     static extension = {\n *         type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem],\n *         name: 'myRendererPlugin'\n *     };\n *\n *    // add renderer plugin methods\n * }\n * extensions.add(MyRendererPlugin);\n *\n * // Remove extensions\n * extensions.remove(MyRendererPlugin);\n * ```\n * @remarks\n * - Extensions must have a type from {@link ExtensionType}\n * - Can be registered before or after their handlers\n * - Supports priority-based ordering\n * - Automatically normalizes extension formats\n * @see {@link ExtensionType} For all available extension types\n * @see {@link ExtensionFormat} For extension registration format\n * @see {@link Application} For application plugin system\n * @see {@link LoaderParser} For asset loading extensions\n * @category extensions\n * @standard\n * @class\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed. Can be:\n     * - Extension class with static `extension` property\n     * - Extension format object with `type` and `ref`\n     * - Multiple extensions as separate arguments\n     * @returns {extensions} this for chaining\n     * @example\n     * ```ts\n     * // Remove a single extension\n     * extensions.remove(MyRendererPlugin);\n     *\n     * // Remove multiple extensions\n     * extensions.remove(\n     *     MyRendererPlugin,\n     *     MySystemPlugin\n     * );\n     * ```\n     * @see {@link ExtensionType} For available extension types\n     * @see {@link ExtensionFormat} For extension format details\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS. Extensions can be registered in multiple formats:\n     * - As a class with a static `extension` property\n     * - As an extension format object\n     * - As multiple extensions passed as separate arguments\n     * @param extensions - Extensions to add to PixiJS. Each can be:\n     * - A class with static `extension` property\n     * - An extension format object with `type` and `ref`\n     * - Multiple extensions as separate arguments\n     * @returns This extensions instance for chaining\n     * @example\n     * ```ts\n     * // Register a simple extension\n     * extensions.add(MyRendererPlugin);\n     *\n     * // Register multiple extensions\n     * extensions.add(\n     *     MyRendererPlugin,\n     *     MySystemPlugin,\n     * });\n     * ```\n     * @see {@link ExtensionType} For available extension types\n     * @see {@link ExtensionFormat} For extension format details\n     * @see {@link extensions.remove} For removing registered extensions\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns this for chaining.\n     * @internal\n     * @ignore\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns this for chaining.\n     * @ignore\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns this for chaining.\n     * @ignore\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns this for chaining.\n     * @ignore\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Mixin the source object(s) properties into the target class's prototype.\n     * Copies all property descriptors from source objects to the target's prototype.\n     * @param Target - The target class to mix properties into\n     * @param sources - One or more source objects containing properties to mix in\n     * @example\n     * ```ts\n     * // Create a mixin with shared properties\n     * const moveable = {\n     *     x: 0,\n     *     y: 0,\n     *     move(x: number, y: number) {\n     *         this.x += x;\n     *         this.y += y;\n     *     }\n     * };\n     *\n     * // Create a mixin with computed properties\n     * const scalable = {\n     *     scale: 1,\n     *     get scaled() {\n     *         return this.scale > 1;\n     *     }\n     * };\n     *\n     * // Apply mixins to a class\n     * extensions.mixin(Sprite, moveable, scalable);\n     *\n     * // Use mixed-in properties\n     * const sprite = new Sprite();\n     * sprite.move(10, 20);\n     * console.log(sprite.x, sprite.y); // 10, 20\n     * ```\n     * @remarks\n     * - Copies all properties including getters/setters\n     * - Does not modify source objects\n     * - Preserves property descriptors\n     * @see {@link Object.defineProperties} For details on property descriptors\n     * @see {@link Object.getOwnPropertyDescriptors} For details on property copying\n     */\n    mixin(Target: any, ...sources: Parameters<typeof Object.getOwnPropertyDescriptors>[0][])\n    {\n        // Apply each source's properties to the target prototype\n        for (const source of sources)\n        {\n            Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));\n        }\n    }\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n    ExtensionMetadataDetails\n};\n", "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n", "export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n", "import { colord, extend } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\nimport type { AnyColor, HslaColor, HslColor, HsvaColor, HsvColor, RgbaColor, RgbColor } from '@pixi/colord';\n\nextend([namesPlugin]);\n\n/**\n * Array of RGBA color components, where each component is a number between 0 and 1.\n * The array must contain exactly 4 numbers in the order: red, green, blue, alpha.\n * @example\n * ```ts\n * // Full white (opaque)\n * const white: RgbaArray = [1, 1, 1, 1];\n *\n * // Semi-transparent red\n * const transparentRed: RgbaArray = [1, 0, 0, 0.5];\n * ```\n * @remarks\n * - All components must be between 0 and 1\n * - Array must contain exactly 4 values\n * - Order is [red, green, blue, alpha]\n * @see {@link Color} For the main color utility class\n * @category color\n * @standard\n */\nexport type RgbaArray = [number, number, number, number];\n\n/**\n * Valid color formats supported by PixiJS. These types extend from [colord](https://www.npmjs.com/package/colord)\n * with additional PixiJS-specific formats.\n *\n * Common Formats:\n * ```ts\n * // CSS Color Names\n * new Color('red');\n * new Color('blue');\n * new Color('green');\n *\n * // Hex Values\n * new Color(0xff0000);     // RGB integer\n * new Color('#ff0000');    // 6-digit hex\n * new Color('#f00');       // 3-digit hex\n * new Color('#ff0000ff');  // 8-digit hex (with alpha)\n * new Color('#f00f');      // 4-digit hex (with alpha)\n *\n * // RGB/RGBA Objects\n * new Color({ r: 255, g: 0, b: 0 });\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 });\n *\n * // RGB/RGBA Strings\n * new Color('rgb(255, 0, 0)');\n * new Color('rgba(255, 0, 0, 0.5)');\n * new Color('rgb(100% 0% 0%)');\n * new Color('rgba(100% 0% 0% / 50%)');\n *\n * // Arrays (normalized 0-1)\n * new Color([1, 0, 0]);           // RGB\n * new Color([1, 0, 0, 0.5]);      // RGBA\n * new Color(new Float32Array([1, 0, 0, 0.5]));\n *\n * // Arrays (0-255)\n * new Color(new Uint8Array([255, 0, 0]));\n * new Color(new Uint8ClampedArray([255, 0, 0, 128]));\n *\n * // HSL/HSLA\n * new Color({ h: 0, s: 100, l: 50 });\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 });\n * new Color('hsl(0, 100%, 50%)');\n * new Color('hsla(0deg 100% 50% / 50%)');\n *\n * // HSV/HSVA\n * new Color({ h: 0, s: 100, v: 100 });\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 });\n * ```\n * @remarks\n * - All color values are normalized internally to 0-1 range\n * - Alpha is always between 0-1\n * - Invalid colors will throw an error\n * - Original format is preserved when possible\n * @see {@link Color} For the main color utility class\n * @see {@link https://www.w3.org/TR/css-color-4} CSS Color Level 4 Specification\n * @since 7.2.0\n * @category color\n * @standard\n */\nexport type ColorSource =\n    | string\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | HslColor\n    | HslaColor\n    | HsvColor\n    | HsvaColor\n    | RgbColor\n    | RgbaColor\n    | Color\n    | number;\n\ntype ColorSourceTypedArray = Float32Array | Uint8Array | Uint8ClampedArray;\n\n/**\n * Color utility class for managing colors in various formats. Provides a unified way to work\n * with colors across your PixiJS application.\n *\n * Features:\n * - Accepts multiple color formats (hex, RGB, HSL, etc.)\n * - Automatic format conversion\n * - Color manipulation methods\n * - Component access (r,g,b,a)\n * - Chainable operations\n * @example\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n *\n * // Convert between formats\n * const color = new Color('red');\n * color.toHex();        // \"#ff0000\"\n * color.toRgbString();  // \"rgb(255,0,0,1)\"\n * color.toNumber();     // 0xff0000\n *\n * // Access components\n * color.red;    // 1\n * color.green;  // 0\n * color.blue;   // 0\n * color.alpha;  // 1\n *\n * // Chain operations\n * color\n *   .setAlpha(0.5)\n *   .multiply([0.5, 0.5, 0.5])\n *   .premultiply(0.8);\n * ```\n * @remarks\n * The Color class automatically normalizes all color values internally:\n * - RGB components are stored as floats between 0-1\n * - Alpha is always between 0-1\n * - Color operations clamp values to valid ranges\n * - Original input format is preserved when possible\n * @since 7.2.0\n * @category color\n * @standard\n */\nexport class Color\n{\n    /**\n     * Static shared Color instance used for utility operations. This is a singleton color object\n     * that can be reused to avoid creating unnecessary Color instances.\n     * > [!IMPORTANT] You should be careful when using this shared instance, as it is mutable and can be\n     * > changed by any code that uses it.\n     * >\n     * > It is best used for one-off color operations or temporary transformations.\n     * > For persistent colors, create your own Color instance instead.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Use shared instance for one-off color operations\n     * Color.shared.setValue(0xff0000);\n     * const redHex = Color.shared.toHex();     // \"#ff0000\"\n     * const redRgb = Color.shared.toRgbArray(); // [1, 0, 0]\n     *\n     * // Temporary color transformations\n     * const colorNumber = Color.shared\n     *     .setValue('#ff0000')     // Set to red\n     *     .setAlpha(0.5)          // Make semi-transparent\n     *     .premultiply(0.8)       // Apply premultiplication\n     *     .toNumber();            // Convert to number\n     *\n     * // Chain multiple operations\n     * const result = Color.shared\n     *     .setValue(someColor)\n     *     .multiply(tintColor)\n     *     .toPremultiplied(alpha);\n     * ```\n     * @remarks\n     * - This is a shared instance - be careful about multiple code paths using it simultaneously\n     * - Use for temporary color operations to avoid allocating new Color instances\n     * - The value is preserved between operations, so reset if needed\n     * - For persistent colors, create your own Color instance instead\n     */\n    public static readonly shared = new Color();\n\n    /**\n     * Temporary Color object for static uses internally.\n     * As to not conflict with Color.shared.\n     * @ignore\n     */\n    private static readonly _temp = new Color();\n\n    /** Pattern for hex strings */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static readonly HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n    /** Internal color source, from constructor or set value */\n    private _value: Exclude<ColorSource, Color> | null;\n\n    /** Normalized rgba component, floats from 0-1 */\n    private _components: Float32Array;\n\n    /** Cache color as number */\n    private _int: number;\n\n    /** An array of the current Color. Only populated when `toArray` functions are called */\n    private _arrayRgba: number[] | null;\n    private _arrayRgb: number[] | null;\n\n    /**\n     * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n     */\n    constructor(value: ColorSource = 0xffffff)\n    {\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 0xffffff;\n        this.value = value;\n    }\n\n    /**\n     * Get the red component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('red');\n     * console.log(color.red); // 1\n     *\n     * const green = new Color('#00ff00');\n     * console.log(green.red); // 0\n     * ```\n     */\n    get red(): number\n    {\n        return this._components[0];\n    }\n\n    /**\n     * Get the green component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('lime');\n     * console.log(color.green); // 1\n     *\n     * const red = new Color('#ff0000');\n     * console.log(red.green); // 0\n     * ```\n     */\n    get green(): number\n    {\n        return this._components[1];\n    }\n\n    /**\n     * Get the blue component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('blue');\n     * console.log(color.blue); // 1\n     *\n     * const yellow = new Color('#ffff00');\n     * console.log(yellow.blue); // 0\n     * ```\n     */\n    get blue(): number\n    {\n        return this._components[2];\n    }\n\n    /**\n     * Get the alpha component of the color, normalized between 0 and 1.\n     * @example\n     * ```ts\n     * const color = new Color('red');\n     * console.log(color.alpha); // 1 (fully opaque)\n     *\n     * const transparent = new Color('rgba(255, 0, 0, 0.5)');\n     * console.log(transparent.alpha); // 0.5 (semi-transparent)\n     * ```\n     */\n    get alpha(): number\n    {\n        return this._components[3];\n    }\n\n    /**\n     * Sets the color value and returns the instance for chaining.\n     *\n     * This is a chainable version of setting the `value` property.\n     * @param value - The color to set. Accepts various formats:\n     * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n     * - RGB/RGBA values (arrays, objects)\n     * - CSS color names\n     * - HSL/HSLA values\n     * - HSV/HSVA values\n     * @returns The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic usage\n     * const color = new Color();\n     * color.setValue('#ff0000')\n     *     .setAlpha(0.5)\n     *     .premultiply(0.8);\n     *\n     * // Different formats\n     * color.setValue(0xff0000);          // Hex number\n     * color.setValue('#ff0000');         // Hex string\n     * color.setValue([1, 0, 0]);         // RGB array\n     * color.setValue([1, 0, 0, 0.5]);    // RGBA array\n     * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object\n     *\n     * // Copy from another color\n     * const red = new Color('red');\n     * color.setValue(red);\n     * ```\n     * @throws {Error} If the color value is invalid or null\n     * @see {@link Color.value} For the underlying value property\n     */\n    public setValue(value: ColorSource): this\n    {\n        this.value = value;\n\n        return this;\n    }\n\n    /**\n     * The current color source. This property allows getting and setting the color value\n     * while preserving the original format where possible.\n     * @remarks\n     * When setting:\n     * - Setting to a `Color` instance copies its source and components\n     * - Setting to other valid sources normalizes and stores the value\n     * - Setting to `null` throws an Error\n     * - The color remains unchanged if normalization fails\n     *\n     * When getting:\n     * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}\n     * - Otherwise returns the original color source\n     * @example\n     * ```ts\n     * // Setting different color formats\n     * const color = new Color();\n     *\n     * color.value = 0xff0000;         // Hex number\n     * color.value = '#ff0000';        // Hex string\n     * color.value = [1, 0, 0];        // RGB array\n     * color.value = [1, 0, 0, 0.5];   // RGBA array\n     * color.value = { r: 1, g: 0, b: 0 }; // RGB object\n     *\n     * // Copying from another color\n     * const red = new Color('red');\n     * color.value = red;  // Copies red's components\n     *\n     * // Getting the value\n     * console.log(color.value);  // Returns original format\n     *\n     * // After modifications\n     * color.multiply([0.5, 0.5, 0.5]);\n     * console.log(color.value);  // Returns null\n     * ```\n     * @throws {Error} When attempting to set `null`\n     */\n    set value(value: ColorSource | null)\n    {\n        // Support copying from other Color objects\n        if (value instanceof Color)\n        {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        }\n        else if (value === null)\n        {\n            throw new Error('Cannot set Color#value to null');\n        }\n        else if (this._value === null || !this._isSourceEqual(this._value, value))\n        {\n            this._value = this._cloneSource(value);\n            this._normalize(this._value);\n        }\n    }\n    get value(): Exclude<ColorSource, Color> | null\n    {\n        return this._value;\n    }\n\n    /**\n     * Copy a color source internally.\n     * @param value - Color source\n     */\n    private _cloneSource(value: Exclude<ColorSource, Color> | null): Exclude<ColorSource, Color> | null\n    {\n        if (typeof value === 'string' || typeof value === 'number' || value instanceof Number || value === null)\n        {\n            return value;\n        }\n        else if (Array.isArray(value) || ArrayBuffer.isView(value))\n        {\n            return value.slice(0);\n        }\n        else if (typeof value === 'object' && value !== null)\n        {\n            return { ...value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Equality check for color sources.\n     * @param value1 - First color source\n     * @param value2 - Second color source\n     * @returns `true` if the color sources are equal, `false` otherwise.\n     */\n    private _isSourceEqual(value1: Exclude<ColorSource, Color>, value2: Exclude<ColorSource, Color>): boolean\n    {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n\n        // Mismatched types\n        if (type1 !== type2)\n        {\n            return false;\n        }\n        // Handle numbers/strings and things that extend Number\n        // important to do the instanceof Number first, as this is \"object\" type\n        else if (type1 === 'number' || type1 === 'string' || value1 instanceof Number)\n        {\n            return value1 === value2;\n        }\n        // Handle Arrays and TypedArrays\n        else if (\n            (Array.isArray(value1) && Array.isArray(value2))\n            || (ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n        )\n        {\n            if (value1.length !== value2.length)\n            {\n                return false;\n            }\n\n            return value1.every((v, i) => v === value2[i]);\n        }\n        // Handle Objects\n        else if (value1 !== null && value2 !== null)\n        {\n            const keys1 = Object.keys(value1) as (keyof typeof value1)[];\n            const keys2 = Object.keys(value2) as (keyof typeof value2)[];\n\n            if (keys1.length !== keys2.length)\n            {\n                return false;\n            }\n\n            return keys1.every((key) => value1[key] === value2[key]);\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Convert to a RGBA color object with normalized components (0-1).\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert colors to RGBA objects\n     * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }\n     * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }\n     *\n     * // With transparency\n     * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }\n     * ```\n     * @returns An RGBA object with normalized components\n     */\n    public toRgba(): RgbaColor\n    {\n        const [r, g, b, a] = this._components;\n\n        return { r, g, b, a };\n    }\n\n    /**\n     * Convert to a RGB color object with normalized components (0-1).\n     *\n     * Alpha component is omitted in the output.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert colors to RGB objects\n     * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }\n     * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }\n     *\n     * // Alpha is ignored\n     * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }\n     * ```\n     * @returns An RGB object with normalized components\n     */\n    public toRgb(): RgbColor\n    {\n        const [r, g, b] = this._components;\n\n        return { r, g, b };\n    }\n\n    /**\n     * Convert to a CSS-style rgba string representation.\n     *\n     * RGB components are scaled to 0-255 range, alpha remains 0-1.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert colors to RGBA strings\n     * new Color('white').toRgbaString();     // returns \"rgba(255,255,255,1)\"\n     * new Color('#ff0000').toRgbaString();   // returns \"rgba(255,0,0,1)\"\n     *\n     * // With transparency\n     * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns \"rgba(255,0,0,0.5)\"\n     * ```\n     * @returns A CSS-compatible rgba string\n     */\n    public toRgbaString(): string\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n     * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,\n     * a cached array will be used and returned.\n     * @returns Array containing RGB components as integers between 0-255\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n     * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]\n     *\n     * // Using custom output array\n     * const rgb = new Uint8Array(3);\n     * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]\n     *\n     * // Using different array types\n     * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]\n     * new Color('red').toUint8RgbArray([]); // [255, 0, 0]\n     * ```\n     * @remarks\n     * - Output values are always clamped between 0-255\n     * - Alpha component is not included in output\n     * - Reuses internal cache array if no output array provided\n     */\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray = number[]>(out?: T): T\n    {\n        const [r, g, b] = this._components;\n\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n     * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n     * a cached array will be used and returned.\n     * @returns Array containing RGBA components as floats between 0-1\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toArray();  // returns [1, 1, 1, 1]\n     * new Color('red').toArray();    // returns [1, 0, 0, 1]\n     *\n     * // With alpha\n     * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]\n     *\n     * // Using custom output array\n     * const rgba = new Float32Array(4);\n     * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]\n     * ```\n     * @remarks\n     * - Output values are normalized between 0-1\n     * - Includes alpha component as the fourth value\n     * - Reuses internal cache array if no output array provided\n     */\n    public toArray<T extends number[] | Float32Array = number[]>(out?: T): T\n    {\n        if (!this._arrayRgba)\n        {\n            this._arrayRgba = [];\n        }\n\n        out ||= this._arrayRgba as T;\n        const [r, g, b, a] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n     * @param {number[]|Float32Array} [out] - Optional output array. If not provided,\n     * a cached array will be used and returned.\n     * @returns Array containing RGB components as floats between 0-1\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toRgbArray(); // returns [1, 1, 1]\n     * new Color('red').toRgbArray();   // returns [1, 0, 0]\n     *\n     * // Using custom output array\n     * const rgb = new Float32Array(3);\n     * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]\n     * ```\n     * @remarks\n     * - Output values are normalized between 0-1\n     * - Alpha component is omitted from output\n     * - Reuses internal cache array if no output array provided\n     */\n    public toRgbArray<T extends number[] | Float32Array = number[]>(out?: T): T\n    {\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n        const [r, g, b] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n\n        return out;\n    }\n\n    /**\n     * Convert to a hexadecimal number.\n     * @returns The color as a 24-bit RGB integer\n     * @example\n     * ```ts\n     * // Basic usage\n     * new Color('white').toNumber(); // returns 0xffffff\n     * new Color('red').toNumber();   // returns 0xff0000\n     *\n     * // Store as hex\n     * const color = new Color('blue');\n     * const hex = color.toNumber(); // 0x0000ff\n     * ```\n     */\n    public toNumber(): number\n    {\n        return this._int;\n    }\n\n    /**\n     * Convert to a BGR number.\n     *\n     * Useful for platforms that expect colors in BGR format.\n     * @returns The color as a 24-bit BGR integer\n     * @example\n     * ```ts\n     * // Convert RGB to BGR\n     * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n     *\n     * // Common use case: platform-specific color format\n     * const color = new Color('orange');\n     * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels\n     * ```\n     * @remarks\n     * This swaps the red and blue channels compared to the normal RGB format:\n     * - RGB 0xRRGGBB becomes BGR 0xBBGGRR\n     */\n    public toBgrNumber(): number\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return (b << 16) + (g << 8) + r;\n    }\n\n    /**\n     * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n     *\n     * Useful for platforms that expect colors in little endian byte order.\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Convert RGB color to little endian format\n     * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n     *\n     * // Common use cases:\n     * const color = new Color('orange');\n     * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems\n     *\n     * // Multiple conversions\n     * const colors = {\n     *     normal: 0xffcc99,\n     *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff\n     *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99\n     * };\n     * ```\n     * @remarks\n     * - Swaps R and B channels in the color value\n     * - RGB 0xRRGGBB becomes 0xBBGGRR\n     * - Useful for systems that use little endian byte order\n     * - Can be used to convert back and forth between formats\n     * @returns The color as a number in little endian format (BBGGRR)\n     * @see {@link Color.toBgrNumber} For BGR format without byte swapping\n     */\n    public toLittleEndianNumber(): number\n    {\n        const value = this._int;\n\n        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    }\n\n    /**\n     * Multiply with another color.\n     *\n     * This action is destructive and modifies the original color.\n     * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:\n     * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)\n     * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])\n     * - Color objects ({ r: 1, g: 0, b: 0 })\n     * - CSS color names ('red', 'blue')\n     * @returns this - The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic multiplication\n     * const color = new Color('#ff0000');\n     * color.multiply(0x808080); // 50% darker red\n     *\n     * // With transparency\n     * color.multiply([1, 1, 1, 0.5]); // 50% transparent\n     *\n     * // Chain operations\n     * color\n     *     .multiply('#808080')\n     *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });\n     * ```\n     * @remarks\n     * - Multiplies each RGB component and alpha separately\n     * - Values are clamped between 0-1\n     * - Original color format is lost (value becomes null)\n     * - Operation cannot be undone\n     */\n    public multiply(value: ColorSource): this\n    {\n        const [r, g, b, a] = Color._temp.setValue(value)._components;\n\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Converts color to a premultiplied alpha format.\n     *\n     * This action is destructive and modifies the original color.\n     * @param alpha - The alpha value to multiply by (0-1)\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n     * @returns {Color} The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic premultiplication\n     * const color = new Color('red');\n     * color.premultiply(0.5); // 50% transparent red with premultiplied RGB\n     *\n     * // Alpha only (RGB unchanged)\n     * color.premultiply(0.5, false); // 50% transparent, original RGB\n     *\n     * // Chain with other operations\n     * color\n     *     .multiply(0x808080)\n     *     .premultiply(0.5)\n     *     .toNumber();\n     * ```\n     * @remarks\n     * - RGB channels are multiplied by alpha when applyToRGB is true\n     * - Alpha is always set to the provided value\n     * - Values are clamped between 0-1\n     * - Original color format is lost (value becomes null)\n     * - Operation cannot be undone\n     */\n    public premultiply(alpha: number, applyToRGB = true): this\n    {\n        if (applyToRGB)\n        {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Returns the color as a 32-bit premultiplied alpha integer.\n     *\n     * Format: 0xAARRGGBB\n     * @param {number} alpha - The alpha value to multiply by (0-1)\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels\n     * @returns {number} The premultiplied color as a 32-bit integer\n     * @example\n     * ```ts\n     * // Convert to premultiplied format\n     * const color = new Color('red');\n     *\n     * // Full opacity (0xFFRRGGBB)\n     * color.toPremultiplied(1.0); // 0xFFFF0000\n     *\n     * // 50% transparency with premultiplied RGB\n     * color.toPremultiplied(0.5); // 0x7F7F0000\n     *\n     * // 50% transparency without RGB premultiplication\n     * color.toPremultiplied(0.5, false); // 0x7FFF0000\n     * ```\n     * @remarks\n     * - Returns full opacity (0xFF000000) when alpha is 1.0\n     * - Returns 0 when alpha is 0.0 and applyToRGB is true\n     * - RGB values are rounded during premultiplication\n     */\n    public toPremultiplied(alpha: number, applyToRGB = true): number\n    {\n        if (alpha === 1.0)\n        {\n            return (0xff << 24) + this._int;\n        }\n        if (alpha === 0.0)\n        {\n            return applyToRGB ? 0 : this._int;\n        }\n        let r = (this._int >> 16) & 0xff;\n        let g = (this._int >> 8) & 0xff;\n        let b = this._int & 0xff;\n\n        if (applyToRGB)\n        {\n            r = ((r * alpha) + 0.5) | 0;\n            g = ((g * alpha) + 0.5) | 0;\n            b = ((b * alpha) + 0.5) | 0;\n        }\n\n        return ((alpha * 255) << 24) + (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Convert to a hexadecimal string (6 characters).\n     * @returns A CSS-compatible hex color string (e.g., \"#ff0000\")\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Basic colors\n     * new Color('red').toHex();    // returns \"#ff0000\"\n     * new Color('white').toHex();  // returns \"#ffffff\"\n     * new Color('black').toHex();  // returns \"#000000\"\n     *\n     * // From different formats\n     * new Color(0xff0000).toHex(); // returns \"#ff0000\"\n     * new Color([1, 0, 0]).toHex(); // returns \"#ff0000\"\n     * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns \"#ff0000\"\n     * ```\n     * @remarks\n     * - Always returns a 6-character hex string\n     * - Includes leading \"#\" character\n     * - Alpha channel is ignored\n     * - Values are rounded to nearest hex value\n     */\n    public toHex(): string\n    {\n        const hexString = this._int.toString(16);\n\n        return `#${'000000'.substring(0, 6 - hexString.length) + hexString}`;\n    }\n\n    /**\n     * Convert to a hexadecimal string with alpha (8 characters).\n     * @returns A CSS-compatible hex color string with alpha (e.g., \"#ff0000ff\")\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // Fully opaque colors\n     * new Color('red').toHexa();   // returns \"#ff0000ff\"\n     * new Color('white').toHexa(); // returns \"#ffffffff\"\n     *\n     * // With transparency\n     * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns \"#ff00007f\"\n     * new Color([1, 0, 0, 0]).toHexa(); // returns \"#ff000000\"\n     * ```\n     * @remarks\n     * - Returns an 8-character hex string\n     * - Includes leading \"#\" character\n     * - Alpha is encoded in last two characters\n     * - Values are rounded to nearest hex value\n     */\n    public toHexa(): string\n    {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n\n        return this.toHex() + '00'.substring(0, 2 - alphaString.length) + alphaString;\n    }\n\n    /**\n     * Set alpha (transparency) value while preserving color components.\n     *\n     * Provides a chainable interface for setting alpha.\n     * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)\n     * @returns The Color instance for chaining\n     * @example\n     * ```ts\n     * // Basic alpha setting\n     * const color = new Color('red');\n     * color.setAlpha(0.5);  // 50% transparent red\n     *\n     * // Chain with other operations\n     * color\n     *     .setValue('#ff0000')\n     *     .setAlpha(0.8)    // 80% opaque\n     *     .premultiply(0.5); // Further modify alpha\n     *\n     * // Reset to fully opaque\n     * color.setAlpha(1);\n     * ```\n     * @remarks\n     * - Alpha value is clamped between 0-1\n     * - Can be chained with other color operations\n     */\n    public setAlpha(alpha: number): this\n    {\n        this._components[3] = this._clamp(alpha);\n\n        return this;\n    }\n\n    /**\n     * Normalize the input value into rgba\n     * @param value - Input value\n     */\n    private _normalize(value: Exclude<ColorSource, Color>): void\n    {\n        let r: number | undefined;\n        let g: number | undefined;\n        let b: number | undefined;\n        let a: number | undefined;\n\n        // Number is a primitive so typeof works fine, but in the case\n        // that someone creates a class that extends Number, we also\n        // need to check for instanceof Number\n        if (\n            (typeof value === 'number' || value instanceof Number)\n            && (value as number) >= 0\n            && (value as number) <= 0xffffff\n        )\n        {\n            const int = value as number; // cast required because instanceof Number is ambiguous for TS\n\n            r = ((int >> 16) & 0xff) / 255;\n            g = ((int >> 8) & 0xff) / 255;\n            b = (int & 0xff) / 255;\n            a = 1.0;\n        }\n        else if (\n            (Array.isArray(value) || value instanceof Float32Array)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 1\n            value = this._clamp(value);\n            [r, g, b, a = 1.0] = value;\n        }\n        else if (\n            (value instanceof Uint8Array || value instanceof Uint8ClampedArray)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 255\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        }\n        else if (typeof value === 'string' || typeof value === 'object')\n        {\n            if (typeof value === 'string')\n            {\n                const match = Color.HEX_PATTERN.exec(value);\n\n                if (match)\n                {\n                    // Normalize hex string, remove 0x or # prefix\n                    value = `#${match[2]}`;\n                }\n            }\n\n            const color = colord(value as AnyColor);\n\n            if (color.isValid())\n            {\n                ({ r, g, b, a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n\n        // Cache normalized values for rgba and hex integer\n        if (r !== undefined)\n        {\n            this._components[0] = r as number;\n            this._components[1] = g as number;\n            this._components[2] = b as number;\n            this._components[3] = a as number;\n            this._refreshInt();\n        }\n        else\n        {\n            throw new Error(`Unable to convert color ${value}`);\n        }\n    }\n\n    /** Refresh the internal color rgb number */\n    private _refreshInt(): void\n    {\n        // Clamp values to 0 - 1\n        this._clamp(this._components);\n\n        const [r, g, b] = this._components;\n\n        this._int = ((r * 255) << 16) + ((g * 255) << 8) + ((b * 255) | 0);\n    }\n\n    /**\n     * Clamps values to a range. Will override original values\n     * @param value - Value(s) to clamp\n     * @param min - Minimum value\n     * @param max - Maximum value\n     */\n    private _clamp<T extends number | number[] | ColorSourceTypedArray>(value: T, min = 0, max = 1): T\n    {\n        if (typeof value === 'number')\n        {\n            return Math.min(Math.max(value, min), max) as T;\n        }\n\n        value.forEach((v, i) =>\n        {\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n\n        return value;\n    }\n\n    /**\n     * Check if a value can be interpreted as a valid color format.\n     * Supports all color formats that can be used with the Color class.\n     * @param value - Value to check\n     * @returns True if the value can be used as a color\n     * @example\n     * ```ts\n     * import { Color } from 'pixi.js';\n     *\n     * // CSS colors and hex values\n     * Color.isColorLike('red');          // true\n     * Color.isColorLike('#ff0000');      // true\n     * Color.isColorLike(0xff0000);       // true\n     *\n     * // Arrays (RGB/RGBA)\n     * Color.isColorLike([1, 0, 0]);      // true\n     * Color.isColorLike([1, 0, 0, 0.5]); // true\n     *\n     * // TypedArrays\n     * Color.isColorLike(new Float32Array([1, 0, 0]));          // true\n     * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true\n     * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true\n     *\n     * // Object formats\n     * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)\n     * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)\n     * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)\n     * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)\n     * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)\n     * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)\n     *\n     * // Color instances\n     * Color.isColorLike(new Color('red')); // true\n     *\n     * // Invalid values\n     * Color.isColorLike(null);           // false\n     * Color.isColorLike(undefined);      // false\n     * Color.isColorLike({});             // false\n     * Color.isColorLike([]);             // false\n     * Color.isColorLike('not-a-color');  // false\n     * ```\n     * @remarks\n     * Checks for the following formats:\n     * - Numbers (0x000000 to 0xffffff)\n     * - CSS color strings\n     * - RGB/RGBA arrays and objects\n     * - HSL/HSLA objects\n     * - HSV/HSVA objects\n     * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)\n     * - Color instances\n     * @see {@link ColorSource} For supported color format types\n     * @see {@link Color.setValue} For setting color values\n     * @category utility\n     */\n    public static isColorLike(value: unknown): value is ColorSource\n    {\n        return (\n            typeof value === 'number'\n            || typeof value === 'string'\n            || value instanceof Number\n            || value instanceof Color\n            || Array.isArray(value)\n            || value instanceof Uint8Array\n            || value instanceof Uint8ClampedArray\n            || value instanceof Float32Array\n            || ((value as RgbColor).r !== undefined\n                && (value as RgbColor).g !== undefined\n                && (value as RgbColor).b !== undefined)\n            || ((value as RgbaColor).r !== undefined\n                && (value as RgbaColor).g !== undefined\n                && (value as RgbaColor).b !== undefined\n                && (value as RgbaColor).a !== undefined)\n            || ((value as HslColor).h !== undefined\n                && (value as HslColor).s !== undefined\n                && (value as HslColor).l !== undefined)\n            || ((value as HslaColor).h !== undefined\n                && (value as HslaColor).s !== undefined\n                && (value as HslaColor).l !== undefined\n                && (value as HslaColor).a !== undefined)\n            || ((value as HsvColor).h !== undefined\n                && (value as HsvColor).s !== undefined\n                && (value as HsvColor).v !== undefined)\n            || ((value as HsvaColor).h !== undefined\n                && (value as HsvaColor).s !== undefined\n                && (value as HsvaColor).v !== undefined\n                && (value as HsvaColor).a !== undefined)\n        );\n    }\n}\n", "import type { Rectangle } from '../maths/shapes/Rectangle';\n\n/**\n * The CullingMixin interface provides properties and methods for managing culling behavior\n * of a display object. Culling is the process of determining whether an object should be rendered\n * based on its visibility within the current view or frame.\n *\n * Key Features:\n * - Custom culling areas for better performance\n * - Per-object culling control\n * - Child culling management\n * @example\n * ```ts\n * // Enable culling for a container\n * const container = new Container();\n * container.cullable = true;\n *\n * // Set custom cull area for better performance\n * container.cullArea = new Rectangle(0, 0, 800, 600);\n *\n * // Disable child culling for static scenes\n * container.cullableChildren = false;\n * ```\n * @category scene\n * @standard\n */\nexport interface CullingMixinConstructor\n{\n    /**\n     * Custom shape used for culling calculations instead of object bounds.\n     * Defined in local space coordinates relative to the object.\n     * > [!NOTE]\n     * > Setting this to a custom Rectangle allows you to define a specific area for culling,\n     * > which can improve performance by avoiding expensive bounds calculations.\n     * @example\n     * ```ts\n     * const container = new Container();\n     *\n     * // Define custom culling boundary\n     * container.cullArea = new Rectangle(0, 0, 800, 600);\n     *\n     * // Reset to use object bounds\n     * container.cullArea = null;\n     * ```\n     * @remarks\n     * - Improves performance by avoiding bounds calculations\n     * - Useful for containers with many children\n     * - Set to null to use object bounds\n     * @default null\n     */\n    cullArea: Rectangle;\n\n    /**\n     * Controls whether this object should be culled when out of view.\n     * When true, the object will not be rendered if its bounds are outside the visible area.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     *\n     * // Enable culling\n     * sprite.cullable = true;\n     *\n     * // Force object to always render\n     * sprite.cullable = false;\n     * ```\n     * @remarks\n     * - Does not affect transform updates\n     * - Applies to this object only\n     * - Children follow their own cullable setting\n     * @default false\n     */\n    cullable: boolean;\n\n    /**\n     * Controls whether children of this container can be culled.\n     * When false, skips recursive culling checks for better performance.\n     * @example\n     * ```ts\n     * const container = new Container();\n     *\n     * // Enable container culling\n     * container.cullable = true;\n     *\n     * // Disable child culling for performance\n     * container.cullableChildren = false;\n     *\n     * // Children will always render if container is visible\n     * container.addChild(sprite1, sprite2, sprite3);\n     * ```\n     * @remarks\n     * - Improves performance for static scenes\n     * - Useful when children are always within container bounds\n     * - Parent culling still applies\n     * @default true\n     */\n    cullableChildren: boolean;\n}\n\n/** @internal */\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n", "/**\n * Two Pi.\n * @type {number}\n * @category maths\n * @standard\n */\nexport const PI_2 = Math.PI * 2;\n\n/**\n * Conversion factor for converting radians to degrees.\n * @type {number} RAD_TO_DEG\n * @category maths\n * @standard\n */\nexport const RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Conversion factor for converting degrees to radians.\n * @type {number}\n * @category maths\n * @standard\n */\nexport const DEG_TO_RAD = Math.PI / 180;\n\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @category maths\n * @advanced\n */\nexport type SHAPE_PRIMITIVE =\n    | 'polygon'\n    | 'rectangle'\n    | 'circle'\n    | 'ellipse'\n    | 'triangle'\n    | 'roundedRectangle';\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Point extends PixiMixins.Point { }\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @example\n * ```ts\n * // Basic point creation\n * const point = new Point(100, 200);\n *\n * // Using with transformations\n * const matrix = new Matrix();\n * matrix.translate(50, 50).apply(point);\n *\n * // Point arithmetic\n * const start = new Point(0, 0);\n * const end = new Point(100, 100);\n * const middle = new Point(\n *     (start.x + end.x) / 2,\n *     (start.y + end.y) / 2\n * );\n * ```\n * @see {@link PointData} For basic x,y interface\n * @see {@link PointLike} For point manipulation interface\n * @see {@link ObservablePoint} For observable version\n * @category maths\n * @standard\n */\nexport class Point implements PointLike\n{\n    /**\n     * Position of the point on the x axis\n     * @example\n     * ```ts\n     * // Set x position\n     * const point = new Point();\n     * point.x = 100;\n     *\n     * // Use in calculations\n     * const width = rightPoint.x - leftPoint.x;\n     * ```\n     */\n    public x = 0;\n    /**\n     * Position of the point on the y axis\n     * @example\n     * ```ts\n     * // Set y position\n     * const point = new Point();\n     * point.y = 200;\n     *\n     * // Use in calculations\n     * const height = bottomPoint.y - topPoint.y;\n     * ```\n     */\n    public y = 0;\n\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Creates a clone of this point, which is a new instance with the same `x` and `y` values.\n     * @example\n     * ```ts\n     * // Basic point cloning\n     * const original = new Point(100, 200);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.set(300, 400);\n     *\n     * // Verify independence\n     * console.log(original); // Point(100, 200)\n     * console.log(modified); // Point(300, 400)\n     * ```\n     * @remarks\n     * - Creates new Point instance\n     * - Deep copies x and y values\n     * - Independent from original\n     * - Useful for preserving values\n     * @returns A clone of this point\n     * @see {@link Point.copyFrom} For copying into existing point\n     * @see {@link Point.copyTo} For copying to existing point\n     */\n    public clone(): Point\n    {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * Copies x and y from the given point into this point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Point(100, 200);\n     * const target = new Point();\n     * target.copyFrom(source);\n     *\n     * // Copy and chain operations\n     * const point = new Point()\n     *     .copyFrom(source)\n     *     .set(x + 50, y + 50);\n     *\n     * // Copy from any PointData\n     * const data = { x: 10, y: 20 };\n     * point.copyFrom(data);\n     * ```\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     * @see {@link Point.copyTo} For copying to another point\n     * @see {@link Point.clone} For creating new point copy\n     */\n    public copyFrom(p: PointData): this\n    {\n        this.set(p.x, p.y);\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Point(100, 200);\n     * const target = new Point();\n     * source.copyTo(target);\n     * ```\n     * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n     * @returns The point (`p`) with values updated\n     * @see {@link Point.copyFrom} For copying from another point\n     * @see {@link Point.clone} For creating new point copy\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this.x, this.y);\n\n        return p;\n    }\n\n    /**\n     * Checks if another point is equal to this point.\n     *\n     * Compares x and y values using strict equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const p1 = new Point(100, 200);\n     * const p2 = new Point(100, 200);\n     * console.log(p1.equals(p2)); // true\n     *\n     * // Compare with PointData\n     * const data = { x: 100, y: 200 };\n     * console.log(p1.equals(data)); // true\n     *\n     * // Check different points\n     * const p3 = new Point(200, 300);\n     * console.log(p1.equals(p3)); // false\n     * ```\n     * @param p - The point to check\n     * @returns `true` if both `x` and `y` are equal\n     * @see {@link Point.copyFrom} For making points equal\n     * @see {@link PointData} For point data interface\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this.x) && (p.y === this.y);\n    }\n\n    /**\n     * Sets the point to a new x and y position.\n     *\n     * If y is omitted, both x and y will be set to x.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * const point = new Point();\n     * point.set(100, 200);\n     *\n     * // Set both x and y to same value\n     * point.set(50); // x=50, y=50\n     *\n     * // Chain with other operations\n     * point\n     *     .set(10, 20)\n     *     .copyTo(otherPoint);\n     * ```\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis, defaults to x\n     * @returns The point instance itself\n     * @see {@link Point.copyFrom} For copying from another point\n     * @see {@link Point.equals} For comparing positions\n     */\n    public set(x = 0, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    // #endif\n\n    /**\n     * A static Point object with `x` and `y` values of `0`.\n     *\n     * This shared instance is reset to zero values when accessed.\n     *\n     * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.\n     * @example\n     * ```ts\n     * // Use for temporary calculations\n     * const tempPoint = Point.shared;\n     * tempPoint.set(100, 200);\n     * matrix.apply(tempPoint);\n     *\n     * // Will be reset to (0,0) on next access\n     * const fresh = Point.shared; // x=0, y=0\n     * ```\n     * @readonly\n     * @returns A fresh zeroed point for temporary use\n     * @see {@link Point.constructor} For creating new points\n     * @see {@link PointData} For basic point interface\n     */\n    static get shared(): Point\n    {\n        tempPoint.x = 0;\n        tempPoint.y = 0;\n\n        return tempPoint;\n    }\n}\n\nconst tempPoint = new Point();\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\n/**\n * The data structure that contains the position, scale, pivot, skew and rotation of an object.\n * This is used by the {@link Matrix} class to decompose the matrix into its components.\n * @category maths\n * @advanced\n */\nexport interface TransformableObject\n{\n    /** The position of the object */\n    position: PointData;\n    /** The scale of the object */\n    scale: PointData;\n    /** The pivot of the object */\n    pivot: PointData;\n    /** The skew of the object */\n    skew: PointData;\n    /** The rotation of the object */\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * Represents a 3x3 transformation matrix:\n *\n * ```js\n * | a  c  tx |\n * | b  d  ty |\n * | 0  0  1  |\n * ```\n * @example\n * ```ts\n * // Create identity matrix\n * const matrix = new Matrix();\n *\n * // Create matrix with custom values\n * const transform = new Matrix(2, 0, 0, 2, 100, 100); // Scale 2x, translate 100,100\n *\n * // Transform a point\n * const point = { x: 10, y: 20 };\n * const transformed = transform.apply(point);\n *\n * // Chain transformations\n * matrix\n *     .translate(100, 50)\n *     .rotate(Math.PI / 4)\n *     .scale(2, 2);\n * ```\n * @remarks\n * - Used for transform hierarchies\n * - Supports scale, rotation, position\n * - Can be concatenated with append/prepend\n * - Efficient for batched transformations\n * @category maths\n * @standard\n */\nexport class Matrix\n{\n    /**\n     * Scale on the x axis.\n     * @default 1\n     */\n    public a: number;\n\n    /**\n     * Shear on the y axis.\n     * @default 0\n     */\n    public b: number;\n\n    /**\n     * Shear on the x axis.\n     * @default 0\n     */\n    public c: number;\n\n    /**\n     * Scale on the y axis.\n     * @default 1\n     */\n    public d: number;\n\n    /**\n     * Translation on the x axis.\n     * @default 0\n     */\n    public tx: number;\n\n    /**\n     * Translation on the y axis.\n     * @default 0\n     */\n    public ty: number;\n\n    /**\n     * Array representation of the matrix.\n     * Only populated when `toArray()` is called.\n     * @default null\n     * @see {@link Matrix.toArray} For filling this array\n     */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array.\n     * Populates matrix components from a flat array in column-major order.\n     *\n     * > [!NOTE] Array mapping order:\n     * > ```\n     * > array[0] = a  (x scale)\n     * > array[1] = b  (y skew)\n     * > array[2] = tx (x translation)\n     * > array[3] = c  (x skew)\n     * > array[4] = d  (y scale)\n     * > array[5] = ty (y translation)\n     * > ```\n     * @example\n     * ```ts\n     * // Create matrix from array\n     * const matrix = new Matrix();\n     * matrix.fromArray([\n     *     2, 0,  100,  // a, b, tx\n     *     0, 2,  100   // c, d, ty\n     * ]);\n     *\n     * // Create matrix from typed array\n     * const float32Array = new Float32Array([\n     *     1, 0, 0,     // Scale x1, no skew\n     *     0, 1, 0      // No skew, scale x1\n     * ]);\n     * matrix.fromArray(float32Array);\n     * ```\n     * @param array - The array to populate the matrix from\n     * @see {@link Matrix.toArray} For converting matrix to array\n     * @see {@link Matrix.set} For setting values directly\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties directly.\n     * All matrix components can be set in one call.\n     * @example\n     * ```ts\n     * // Set to identity matrix\n     * matrix.set(1, 0, 0, 1, 0, 0);\n     *\n     * // Set to scale matrix\n     * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x\n     *\n     * // Set to translation matrix\n     * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50\n     * ```\n     * @param a - Scale on x axis\n     * @param b - Shear on y axis\n     * @param c - Shear on x axis\n     * @param d - Scale on y axis\n     * @param tx - Translation on x axis\n     * @param ty - Translation on y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.fromArray} For setting from array\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     *\n     * > [!NOTE] The array format is:\n     * > ```\n     * > Non-transposed:\n     * > [a, c, tx,\n     * > b, d, ty,\n     * > 0, 0, 1]\n     * >\n     * > Transposed:\n     * > [a, b, 0,\n     * > c, d, 0,\n     * > tx,ty,1]\n     * > ```\n     * @example\n     * ```ts\n     * // Basic array conversion\n     * const matrix = new Matrix(2, 0, 0, 2, 100, 100);\n     * const array = matrix.toArray();\n     *\n     * // Using existing array\n     * const float32Array = new Float32Array(9);\n     * matrix.toArray(false, float32Array);\n     *\n     * // Get transposed array\n     * const transposed = matrix.toArray(true);\n     * ```\n     * @param transpose - Whether to transpose the matrix\n     * @param out - Optional Float32Array to store the result\n     * @returns The array containing the matrix values\n     * @see {@link Matrix.fromArray} For creating matrix from array\n     * @see {@link Matrix.array} For cached array storage\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     *\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @example\n     * ```ts\n     * // Basic point transformation\n     * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n     * const point = new Point(10, 20);\n     * const transformed = matrix.apply(point);\n     *\n     * // Reuse existing point\n     * const output = new Point();\n     * matrix.apply(point, output);\n     * ```\n     * @param pos - The origin point to transform\n     * @param newPos - Optional point to store the result\n     * @returns The transformed point\n     * @see {@link Matrix.applyInverse} For inverse transformation\n     * @see {@link Point} For point operations\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     *\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @example\n     * ```ts\n     * // Basic inverse transformation\n     * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);\n     * const worldPoint = new Point(150, 100);\n     * const localPoint = matrix.applyInverse(worldPoint);\n     *\n     * // Reuse existing point\n     * const output = new Point();\n     * matrix.applyInverse(worldPoint, output);\n     *\n     * // Convert mouse position to local space\n     * const mousePoint = new Point(mouseX, mouseY);\n     * const localMouse = matrix.applyInverse(mousePoint);\n     * ```\n     * @param pos - The origin point to inverse-transform\n     * @param newPos - Optional point to store the result\n     * @returns The inverse-transformed point\n     * @see {@link Matrix.apply} For forward transformation\n     * @see {@link Matrix.invert} For getting inverse matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y axes.\n     * Adds to the position values while preserving scale, rotation and skew.\n     * @example\n     * ```ts\n     * // Basic translation\n     * const matrix = new Matrix();\n     * matrix.translate(100, 50); // Move right 100, down 50\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .scale(2, 2)\n     *     .translate(100, 0)\n     *     .rotate(Math.PI / 4);\n     * ```\n     * @param x - How much to translate on the x axis\n     * @param y - How much to translate on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.set} For setting position directly\n     * @see {@link Matrix.setTransform} For complete transform setup\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * Multiplies the scale values with existing matrix components.\n     * @example\n     * ```ts\n     * // Basic scaling\n     * const matrix = new Matrix();\n     * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .translate(100, 100)\n     *     .scale(2, 2)     // Scales after translation\n     *     .rotate(Math.PI / 4);\n     * ```\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.setTransform} For setting scale directly\n     * @see {@link Matrix.append} For combining transformations\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     *\n     * Rotates around the origin (0,0) by the given angle in radians.\n     * @example\n     * ```ts\n     * // Basic rotation\n     * const matrix = new Matrix();\n     * matrix.rotate(Math.PI / 4); // Rotate 45 degrees\n     *\n     * // Chain with other transformations\n     * matrix\n     *     .translate(100, 100) // Move to rotation center\n     *     .rotate(Math.PI)     // Rotate 180 degrees\n     *     .scale(2, 2);        // Scale after rotation\n     *\n     * // Common angles\n     * matrix.rotate(Math.PI / 2);  // 90 degrees\n     * matrix.rotate(Math.PI);      // 180 degrees\n     * matrix.rotate(Math.PI * 2);  // 360 degrees\n     * ```\n     * @remarks\n     * - Rotates around origin point (0,0)\n     * - Affects position if translation was set\n     * - Uses counter-clockwise rotation\n     * - Order of operations matters when chaining\n     * @param angle - The angle in radians\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.setTransform} For setting rotation directly\n     * @see {@link Matrix.append} For combining transformations\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * Combines two matrices by multiplying them together: this = this * matrix\n     * @example\n     * ```ts\n     * // Basic matrix combination\n     * const matrix = new Matrix();\n     * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);\n     * matrix.append(other);\n     * ```\n     * @remarks\n     * - Order matters: A.append(B) !== B.append(A)\n     * - Modifies current matrix\n     * - Preserves transformation order\n     * - Commonly used for combining transforms\n     * @param matrix - The matrix to append\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.prepend} For prepending transformations\n     * @see {@link Matrix.appendFrom} For appending two external matrices\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrices and sets the result to this matrix.\n     * Performs matrix multiplication: this = A * B\n     * @example\n     * ```ts\n     * // Basic matrix multiplication\n     * const result = new Matrix();\n     * const matrixA = new Matrix().scale(2, 2);\n     * const matrixB = new Matrix().rotate(Math.PI / 4);\n     * result.appendFrom(matrixA, matrixB);\n     * ```\n     * @remarks\n     * - Order matters: A * B !== B * A\n     * - Creates a new transformation from two others\n     * - More efficient than append() for multiple operations\n     * - Does not modify input matrices\n     * @param a - The first matrix to multiply\n     * @param b - The second matrix to multiply\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.append} For single matrix combination\n     * @see {@link Matrix.prepend} For reverse order multiplication\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties.\n     * Combines position, scale, rotation, skew and pivot in a single operation.\n     * @example\n     * ```ts\n     * // Basic transform setup\n     * const matrix = new Matrix();\n     * matrix.setTransform(\n     *     100, 100,    // position\n     *     0, 0,        // pivot\n     *     2, 2,        // scale\n     *     Math.PI / 4, // rotation (45 degrees)\n     *     0, 0         // skew\n     * );\n     * ```\n     * @remarks\n     * - Updates all matrix components at once\n     * - More efficient than separate transform calls\n     * - Uses radians for rotation and skew\n     * - Pivot affects rotation center\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.decompose} For extracting transform properties\n     * @see {@link TransformableObject} For transform data structure\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * Combines two matrices by multiplying them together: this = matrix * this\n     * @example\n     * ```ts\n     * // Basic matrix prepend\n     * const matrix = new Matrix().scale(2, 2);\n     * const other = new Matrix().translate(100, 0);\n     * matrix.prepend(other); // Translation happens before scaling\n     * ```\n     * @remarks\n     * - Order matters: A.prepend(B) !== B.prepend(A)\n     * - Modifies current matrix\n     * - Reverses transformation order compared to append()\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.append} For appending transformations\n     * @see {@link Matrix.appendFrom} For combining external matrices\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix into its individual transform components.\n     * Extracts position, scale, rotation and skew values from the matrix.\n     * @example\n     * ```ts\n     * // Basic decomposition\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * const transform = {\n     *     position: new Point(),\n     *     scale: new Point(),\n     *     pivot: new Point(),\n     *     skew: new Point(),\n     *     rotation: 0\n     * };\n     *\n     * matrix.decompose(transform);\n     * console.log(transform.position); // Point(100, 100)\n     * console.log(transform.rotation); // ~0.785 (PI/4)\n     * console.log(transform.scale); // Point(2, 2)\n     * ```\n     * @remarks\n     * - Handles combined transformations\n     * - Accounts for pivot points\n     * - Chooses between rotation/skew based on transform type\n     * - Uses radians for rotation and skew\n     * @param transform - The transform object to store the decomposed values\n     * @returns The transform with the newly applied properties\n     * @see {@link Matrix.setTransform} For composing from components\n     * @see {@link TransformableObject} For transform structure\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix.\n     * Creates the matrix that when multiplied with this matrix results in an identity matrix.\n     * @example\n     * ```ts\n     * // Basic matrix inversion\n     * const matrix = new Matrix()\n     *     .translate(100, 50)\n     *     .scale(2, 2);\n     *\n     * matrix.invert(); // Now transforms in opposite direction\n     *\n     * // Verify inversion\n     * const point = new Point(50, 50);\n     * const transformed = matrix.apply(point);\n     * const original = matrix.invert().apply(transformed);\n     * // original ≈ point\n     * ```\n     * @remarks\n     * - Modifies the current matrix\n     * - Useful for reversing transformations\n     * - Cannot invert matrices with zero determinant\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.applyInverse} For inverse transformations\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /**\n     * Checks if this matrix is an identity matrix.\n     *\n     * An identity matrix has no transformations applied (default state).\n     * @example\n     * ```ts\n     * // Check if matrix is identity\n     * const matrix = new Matrix();\n     * console.log(matrix.isIdentity()); // true\n     *\n     * // Check after transformations\n     * matrix.translate(100, 0);\n     * console.log(matrix.isIdentity()); // false\n     *\n     * // Reset and verify\n     * matrix.identity();\n     * console.log(matrix.isIdentity()); // true\n     * ```\n     * @remarks\n     * - Verifies a = 1, d = 1 (no scale)\n     * - Verifies b = 0, c = 0 (no skew)\n     * - Verifies tx = 0, ty = 0 (no translation)\n     * @returns True if matrix has no transformations\n     * @see {@link Matrix.identity} For resetting to identity\n     * @see {@link Matrix.IDENTITY} For constant identity matrix\n     */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * Sets all components to their default values: scale=1, no skew, no translation.\n     * @example\n     * ```ts\n     * // Reset transformed matrix\n     * const matrix = new Matrix()\n     *     .scale(2, 2)\n     *     .rotate(Math.PI / 4);\n     * matrix.identity(); // Back to default state\n     *\n     * // Chain after reset\n     * matrix\n     *     .identity()\n     *     .translate(100, 100)\n     *     .scale(2, 2);\n     *\n     * // Compare with identity constant\n     * const isDefault = matrix.equals(Matrix.IDENTITY);\n     * ```\n     * @remarks\n     * - Sets a=1, d=1 (default scale)\n     * - Sets b=0, c=0 (no skew)\n     * - Sets tx=0, ty=0 (no translation)\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.IDENTITY} For constant identity matrix\n     * @see {@link Matrix.isIdentity} For checking identity state\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @param matrix\n     * @example\n     * ```ts\n     * // Basic matrix cloning\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     * const copy = matrix.clone();\n     *\n     * // Clone and modify\n     * const modified = matrix.clone()\n     *     .scale(2, 2);\n     *\n     * // Compare matrices\n     * console.log(matrix.equals(copy));     // true\n     * console.log(matrix.equals(modified)); // false\n     * ```\n     * @returns A copy of this matrix. Good for chaining method calls.\n     * @see {@link Matrix.copyTo} For copying to existing matrix\n     * @see {@link Matrix.copyFrom} For copying from another matrix\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix.\n     * @example\n     * ```ts\n     * // Basic matrix copying\n     * const source = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     * const target = new Matrix();\n     * target.copyFrom(source);\n     * ```\n     * @param matrix - The matrix to copy from\n     * @returns This matrix. Good for chaining method calls.\n     * @see {@link Matrix.clone} For creating new matrix copy\n     * @see {@link Matrix.copyTo} For copying to another matrix\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Checks if this matrix equals another matrix.\n     * Compares all components for exact equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const m1 = new Matrix();\n     * const m2 = new Matrix();\n     * console.log(m1.equals(m2)); // true\n     *\n     * // Compare transformed matrices\n     * const transform = new Matrix()\n     *     .translate(100, 100)\n     * const clone = new Matrix()\n     *     .scale(2, 2);\n     * console.log(transform.equals(clone)); // false\n     * ```\n     * @param matrix - The matrix to compare to\n     * @returns True if matrices are identical\n     * @see {@link Matrix.copyFrom} For copying matrix values\n     * @see {@link Matrix.isIdentity} For identity comparison\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix with no transformations applied.\n     *\n     * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.\n     * @example\n     * ```ts\n     * // Get identity matrix reference\n     * const identity = Matrix.IDENTITY;\n     * console.log(identity.isIdentity()); // true\n     *\n     * // Compare with identity\n     * const matrix = new Matrix();\n     * console.log(matrix.equals(Matrix.IDENTITY)); // true\n     *\n     * // Create new matrix instead of modifying IDENTITY\n     * const transform = new Matrix()\n     *     .copyFrom(Matrix.IDENTITY)\n     *     .translate(100, 100);\n     * ```\n     * @readonly\n     * @returns A read-only identity matrix\n     * @see {@link Matrix.shared} For temporary calculations\n     * @see {@link Matrix.identity} For resetting matrices\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     *\n     * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.\n     * @example\n     * ```ts\n     * // Use for temporary calculations\n     * const tempMatrix = Matrix.shared;\n     * tempMatrix.translate(100, 100).rotate(Math.PI / 4);\n     * const point = tempMatrix.apply({ x: 10, y: 20 });\n     *\n     * // Will be reset to identity on next access\n     * const fresh = Matrix.shared; // Back to identity\n     * ```\n     * @remarks\n     * - Always returns identity matrix\n     * - Safe to modify temporarily\n     * - Not safe to store references\n     * - Useful for one-off calculations\n     * @readonly\n     * @returns A fresh identity matrix for temporary use\n     * @see {@link Matrix.IDENTITY} For immutable identity matrix\n     * @see {@link Matrix.identity} For resetting matrices\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n", "import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * Provides callback mechanism for point value updates.\n * @example\n * ```ts\n * // Basic observer implementation\n * const observer: Observer<ObservablePoint> = {\n *     _onUpdate: (point) => {\n *         console.log(`Point updated to (${point.x}, ${point.y})`);\n *     }\n * };\n *\n * // Create observable point with observer\n * const point = new ObservablePoint(observer, 100, 100);\n *\n * // Observer will be notified on changes\n * point.x = 200; // Logs: Point updated to (200, 100)\n * ```\n * @remarks\n * - Used internally by ObservablePoint\n * - Triggered on x/y changes\n * - Can track multiple points\n * - Useful for change detection\n * @typeParam T - The type of point being observed\n * @see {@link ObservablePoint} The observable point class\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport interface Observer<T>\n{\n    /**\n     * Callback to call when the point has updated.\n     * Triggered whenever x or y coordinates change.\n     * @param point - The point that was updated\n     */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system.\n * Triggers a callback when its position changes.\n *\n * The x and y properties represent the position on the horizontal and vertical axes, respectively.\n * @example\n * ```ts\n * // Basic observable point usage\n * const point = new ObservablePoint(\n *     { _onUpdate: (p) => console.log(`Updated to (${p.x}, ${p.y})`) },\n *     100, 100\n * );\n *\n * // Update triggers callback\n * point.x = 200; // Logs: Updated to (200, 100)\n * point.y = 300; // Logs: Updated to (200, 300)\n *\n * // Set both coordinates\n * point.set(50, 50); // Logs: Updated to (50, 50)\n * ```\n * @see {@link Point} For non-observable version\n * @see {@link Observer} For observer interface\n * @see {@link PointLike} For point interface\n * @category maths\n * @standard\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const point = new ObservablePoint(observer, 100, 200);\n     * const copy = point.clone();\n     *\n     * // Clone with new observer\n     * const newObserver = {\n     *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)\n     * };\n     * const watched = point.clone(newObserver);\n     *\n     * // Verify independence\n     * watched.set(300, 400); // Only triggers new observer\n     * ```\n     * @param observer - Optional observer to pass to the new observable point\n     * @returns A copy of this observable point\n     * @see {@link ObservablePoint.copyFrom} For copying into existing point\n     * @see {@link Observer} For observer interface details\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new x and y position.\n     *\n     * If y is omitted, both x and y will be set to x.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * const point = new ObservablePoint(observer);\n     * point.set(100, 200);\n     *\n     * // Set both x and y to same value\n     * point.set(50); // x=50, y=50\n     * ```\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis, defaults to x\n     * @returns The point instance itself\n     * @see {@link ObservablePoint.copyFrom} For copying from another point\n     * @see {@link ObservablePoint.equals} For comparing positions\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point into this point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new ObservablePoint(observer, 100, 200);\n     * const target = new ObservablePoint();\n     * target.copyFrom(source);\n     *\n     * // Copy and chain operations\n     * const point = new ObservablePoint()\n     *     .copyFrom(source)\n     *     .set(x + 50, y + 50);\n     *\n     * // Copy from any PointData\n     * const data = { x: 10, y: 20 };\n     * point.copyFrom(data);\n     * ```\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     * @see {@link ObservablePoint.copyTo} For copying to another point\n     * @see {@link ObservablePoint.clone} For creating new point copy\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new ObservablePoint(100, 200);\n     * const target = new ObservablePoint();\n     * source.copyTo(target);\n     * ```\n     * @param p - The point to copy to. Can be any type that is or extends `PointLike`\n     * @returns The point (`p`) with values updated\n     * @see {@link ObservablePoint.copyFrom} For copying from another point\n     * @see {@link ObservablePoint.clone} For creating new point copy\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Checks if another point is equal to this point.\n     *\n     * Compares x and y values using strict equality.\n     * @example\n     * ```ts\n     * // Basic equality check\n     * const p1 = new ObservablePoint(100, 200);\n     * const p2 = new ObservablePoint(100, 200);\n     * console.log(p1.equals(p2)); // true\n     *\n     * // Compare with PointData\n     * const data = { x: 100, y: 200 };\n     * console.log(p1.equals(data)); // true\n     *\n     * // Check different points\n     * const p3 = new ObservablePoint(200, 300);\n     * console.log(p1.equals(p3)); // false\n     * ```\n     * @param p - The point to check\n     * @returns `true` if both `x` and `y` are equal\n     * @see {@link ObservablePoint.copyFrom} For making points equal\n     * @see {@link PointData} For point data interface\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /**\n     * Position of the observable point on the x axis.\n     * Triggers observer callback when value changes.\n     * @example\n     * ```ts\n     * // Basic x position\n     * const point = new ObservablePoint(observer);\n     * point.x = 100; // Triggers observer\n     *\n     * // Use in calculations\n     * const width = rightPoint.x - leftPoint.x;\n     * ```\n     * @default 0\n     */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /**\n     * Position of the observable point on the y axis.\n     * Triggers observer callback when value changes.\n     * @example\n     * ```ts\n     * // Basic y position\n     * const point = new ObservablePoint(observer);\n     * point.y = 200; // Triggers observer\n     *\n     * // Use in calculations\n     * const height = bottomPoint.y - topPoint.y;\n     * ```\n     * @default 0\n     */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n", "const uidCache: Record<string, number> = {\n    default: -1,\n};\n\n/**\n * The names of the unique identifiers. These are used to create unique identifiers for different types of objects.\n * @category utils\n * @internal\n */\nexport type UIDNames =\n    | 'default'\n    | 'resource'\n    | 'texture'\n    | 'textureSource'\n    | 'textureResource'\n    | 'batcher' //\n    | 'graphicsContext' //\n    | 'graphicsView' //\n    | 'graphicsPath' //\n    | 'fillGradient' //\n    | 'fillPattern' //\n    | 'meshView' //\n    | 'renderable' //\n    | 'buffer' //\n    | 'bufferResource' //\n    | 'geometry'\n    | 'instructionSet' //\n    | 'renderTarget' //\n    | 'uniform' //\n    | 'spriteView' //\n    | 'textView' //\n    | 'tilingSpriteView' //\n    | 'shader' //\n    | 'renderer' //\n    | 'textStyle'\n    | (string & {});\n\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @returns {number} The next unique identifier to use.\n * @category utils\n * @internal\n */\nexport function uid(name: UIDNames = 'default'): number\n{\n    if (uidCache[name] === undefined)\n    {\n        uidCache[name] = -1;\n    }\n\n    return ++uidCache[name];\n}\n\n/**\n * Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :)\n * @internal\n */\nexport function resetUids(): void\n{\n    for (const key in uidCache)\n    {\n        delete uidCache[key];\n    }\n}\n", "// A set of warning messages already fired\nconst warnings: Set<string> = new Set();\n\n/**\n * deprecation name for version 8.0.0\n * @ignore\n * @internal\n */\nexport const v8_0_0 = '8.0.0';\n/**\n * deprecation name for version 8.1.0\n * @ignore\n * @internal\n */\nexport const v8_3_4 = '8.3.4';\n\n/**\n * Options for managing deprecation messages behavior globally\n * @category utils\n * @standard\n */\ninterface DeprecationOptions\n{\n    /**\n     * When set to true, all deprecation warning messages will be hidden.\n     * Use this if you want to silence deprecation notifications.\n     * @default false\n     * @standard\n     */\n    quiet: boolean;\n    /**\n     * When set to true, deprecation messages will be displayed as plain text without color formatting.\n     * Use this if you want to disable colored console output for deprecation warnings.\n     * @default false\n     * @standard\n     */\n    noColor: boolean;\n}\n\n/** @internal */\nexport type DeprecationFn = ((version: string, message: string, ignoreDepth?: number) => void) & DeprecationOptions;\n\nconst deprecationState: DeprecationOptions = {\n    quiet: false,\n    noColor: false\n};\n\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n *\n * Deprecation messages can be configured globally:\n * ```ts\n * // Suppress all deprecation messages\n * deprecation.quiet = true;\n *\n * // Put plain text to console instead of colorful messages\n * deprecation.noColor = true;\n * ```\n * @category utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport const deprecation: DeprecationFn = ((version: string, message: string, ignoreDepth: number = 3) =>\n{\n    // Suppress if is in quiet mode and ignore duplicate\n    if (deprecationState.quiet || warnings.has(message)) return;\n\n    /* eslint-disable no-console */\n    let stack = new Error().stack;\n\n    const deprecationMessage = `${message}\\nDeprecated since v${version}`;\n    const useGroup = typeof console.groupCollapsed === 'function' && !deprecationState.noColor;\n\n    // Handle IE < 10 and Safari < 6\n    if (typeof stack === 'undefined')\n    {\n        console.warn('PixiJS Deprecation Warning: ', deprecationMessage);\n    }\n    else\n    {\n        // chop off the stack trace which includes PixiJS internal calls\n        stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n\n        if (useGroup)\n        {\n            console.groupCollapsed(\n                '%cPixiJS Deprecation Warning: %c%s',\n                'color:#614108;background:#fffbe6',\n                'font-weight:normal;color:#614108;background:#fffbe6',\n                deprecationMessage\n            );\n            console.warn(stack);\n            console.groupEnd();\n        }\n        else\n        {\n            console.warn('PixiJS Deprecation Warning: ', deprecationMessage);\n            console.warn(stack);\n        }\n    }\n    /* eslint-enable no-console */\n\n    warnings.add(message);\n}) as DeprecationFn;\n\nObject.defineProperties(deprecation, {\n    quiet: {\n        get: () => deprecationState.quiet,\n        set: (value: boolean) =>\n        {\n            deprecationState.quiet = value;\n        },\n        enumerable: true,\n        configurable: false\n    },\n    noColor: {\n        get: () => deprecationState.noColor,\n        set: (value: boolean) =>\n        {\n            deprecationState.noColor = value;\n        },\n        enumerable: true,\n        configurable: false\n    }\n} satisfies {[key in keyof DeprecationOptions]: PropertyDescriptor});\n", "let warnCount = 0;\nconst maxWarnings = 500;\n\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @category utils\n * @ignore\n */\nexport function warn(...args: any[])\n{\n    if (warnCount === maxWarnings) return;\n\n    warnCount++;\n\n    if (warnCount === maxWarnings)\n    {\n        console.warn('PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.');\n    }\n    else\n    {\n        console.warn('PixiJS Warning: ', ...args);\n    }\n}\n", "/** Interface for objects that can be cleaned up by the PoolCollector. */\ninterface Cleanable\n{\n    clear(): void;\n}\n\n/**\n * A singleton collector that manages and provides cleanup for registered pools and caches.\n * Useful for cleaning up all pools/caches at once during application shutdown or reset.\n * @category utils\n * @internal\n */\nexport const GlobalResourceRegistry = {\n    /**\n     * Set of registered pools and cleanable objects.\n     * @private\n     */\n    _registeredResources: new Set<Cleanable>(),\n\n    /**\n     * Registers a pool or cleanable object for cleanup.\n     * @param {Cleanable} pool - The pool or object to register.\n     */\n    register(pool: Cleanable): void\n    {\n        this._registeredResources.add(pool);\n    },\n\n    /**\n     * Unregisters a pool or cleanable object from cleanup.\n     * @param {Cleanable} pool - The pool or object to unregister.\n     */\n    unregister(pool: Cleanable): void\n    {\n        this._registeredResources.delete(pool);\n    },\n\n    /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */\n    release(): void\n    {\n        this._registeredResources.forEach((pool) => pool.clear());\n    },\n\n    /**\n     * Gets the number of registered pools and cleanable objects.\n     * @returns {number} The count of registered items.\n     */\n    get registeredCount(): number\n    {\n        return this._registeredResources.size;\n    },\n\n    /**\n     * Checks if a specific pool or cleanable object is registered.\n     * @param {Cleanable} pool - The pool or object to check.\n     * @returns {boolean} True if the item is registered, false otherwise.\n     */\n    isRegistered(pool: Cleanable): boolean\n    {\n        return this._registeredResources.has(pool);\n    },\n\n    /**\n     * Removes all registrations without clearing the pools.\n     * Useful if you want to reset the collector without affecting the pools.\n     */\n    reset(): void\n    {\n        this._registeredResources.clear();\n    }\n};\n", "/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link PoolItem}.\n * @category utils\n * @advanced\n */\nexport class Pool<T extends PoolItem>\n{\n    /** @internal */\n    public readonly _classType: PoolItemConstructor<T>;\n    private readonly _pool: T[] = [];\n    private _count = 0;\n    private _index = 0;\n\n    /**\n     * Constructs a new Pool.\n     * @param ClassType - The constructor of the items in the pool.\n     * @param {number} [initialSize] - The initial size of the pool.\n     */\n    constructor(ClassType: PoolItemConstructor<T>, initialSize?: number)\n    {\n        this._classType = ClassType;\n\n        if (initialSize)\n        {\n            this.prepopulate(initialSize);\n        }\n    }\n\n    /**\n     * Prepopulates the pool with a given number of items.\n     * @param total - The number of items to add to the pool.\n     */\n    public prepopulate(total: number): void\n    {\n        for (let i = 0; i < total; i++)\n        {\n            this._pool[this._index++] = new this._classType();\n        }\n\n        this._count += total;\n    }\n\n    /**\n     * Gets an item from the pool. Calls the item's `init` method if it exists.\n     * If there are no items left in the pool, a new one will be created.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get(data?: unknown): T\n    {\n        let item;\n\n        if (this._index > 0)\n        {\n            item = this._pool[--this._index];\n        }\n        else\n        {\n            item = new this._classType();\n        }\n\n        item.init?.(data);\n\n        return item;\n    }\n\n    /**\n     * Returns an item to the pool. Calls the item's `reset` method if it exists.\n     * @param {T} item - The item to return to the pool.\n     */\n    public return(item: T): void\n    {\n        item.reset?.();\n\n        this._pool[this._index++] = item;\n    }\n\n    /**\n     * Gets the number of items in the pool.\n     * @readonly\n     */\n    get totalSize(): number\n    {\n        return this._count;\n    }\n\n    /**\n     * Gets the number of items in the pool that are free to use without needing to create more.\n     * @readonly\n     */\n    get totalFree(): number\n    {\n        return this._index;\n    }\n\n    /**\n     * Gets the number of items in the pool that are currently in use.\n     * @readonly\n     */\n    get totalUsed(): number\n    {\n        return this._count - this._index;\n    }\n\n    /** clears the pool */\n    public clear()\n    {\n        if (this._pool.length > 0 && this._pool[0].destroy)\n        {\n            for (let i = 0; i < this._index; i++)\n            {\n                this._pool[i].destroy();\n            }\n        }\n        this._pool.length = 0;\n        this._count = 0;\n        this._index = 0;\n    }\n}\n\n/**\n * An object that can be stored in a {@link Pool}.\n * @category utils\n * @advanced\n */\nexport type PoolItem = {\n    init?: (data?: any) => void;\n    reset?: () => void;\n    destroy?: () => void;\n    [key: string]: any;\n};\n\n/**\n * The constructor of an object that can be stored in a {@link Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link Pool}.\n * @category utils\n * @advanced\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n", "import { GlobalResourceRegistry } from './GlobalResourceRegistry';\nimport { Pool } from './Pool';\n\nimport type { PoolItem, PoolItemConstructor } from './Pool';\n\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @category utils\n * @advanced\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n\n/**\n * A group of pools that can be used to store objects of different types.\n * @category utils\n * @advanced\n */\nexport class PoolGroupClass\n{\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    private readonly _poolsByClass: Map<PoolItemConstructor<PoolItem>, Pool<PoolItem>> = new Map();\n\n    /**\n     * Prepopulates a specific pool with a given number of items.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {number} total - The number of items to add to the pool.\n     */\n    public prepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void\n    {\n        const classPool = this.getPool(Class);\n\n        classPool.prepopulate(total);\n    }\n\n    /**\n     * Gets an item from a specific pool.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T\n    {\n        const pool = this.getPool(Class);\n\n        return pool.get(data) as T;\n    }\n\n    /**\n     * Returns an item to its respective pool.\n     * @param {PoolItem} item - The item to return to the pool.\n     */\n    public return(item: PoolItem): void\n    {\n        const pool = this.getPool(item.constructor as PoolItemConstructor<PoolItem>);\n\n        pool.return(item);\n    }\n\n    /**\n     * Gets a specific pool based on the class type.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n     * @returns {Pool<T>} The pool of the given class type.\n     */\n    public getPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>\n    {\n        if (!this._poolsByClass.has(ClassType))\n        {\n            this._poolsByClass.set(ClassType, new Pool(ClassType));\n        }\n\n        return this._poolsByClass.get(ClassType) as Pool<T>;\n    }\n\n    /** gets the usage stats of each pool in the system */\n    public stats(): Record<string, {free: number; used: number; size: number}>\n    {\n        const stats = {} as Record<string, {free: number; used: number; size: number}>;\n\n        this._poolsByClass.forEach((pool) =>\n        {\n            // TODO: maybe we should allow the name to be set when `createEntity` is called\n            const name = stats[pool._classType.name]\n                ? pool._classType.name + (pool._classType as any).ID : pool._classType.name;\n\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize,\n            };\n        });\n\n        return stats;\n    }\n\n    /** Clears all pools in the group. This will reset all pools and free their resources. */\n    public clear(): void\n    {\n        this._poolsByClass.forEach((pool) => pool.clear());\n        this._poolsByClass.clear();\n    }\n}\n\n/**\n * A singleton instance of the PoolGroupClass that can be used throughout the application.\n * @internal\n */\nexport const BigPool = new PoolGroupClass();\nGlobalResourceRegistry.register(BigPool);\n", "import { deprecation } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\nimport type { CacheAsTextureOptions } from '../RenderGroup';\n\n/** @ignore */\nexport interface CacheAsTextureMixinConstructor\n{\n    cacheAsTexture?: (val: boolean | CacheAsTextureOptions) => void;\n}\n\n/**\n * The CacheAsTextureMixin interface provides methods and properties for caching a container as a texture.\n * This can improve rendering performance for complex static containers by allowing them to be rendered as a single texture.\n * It includes methods to enable or disable caching, update the cached texture, and check\n * 1if the container is currently cached.\n * @category scene\n * @advanced\n */\nexport interface CacheAsTextureMixin extends Required<CacheAsTextureMixinConstructor>\n{\n    /**\n     * Caches this container as a texture. This allows the container to be rendered as a single texture,\n     * which can improve performance for complex static containers.\n     * @example\n     * ```ts\n     * // Basic caching\n     * container.cacheAsTexture(true);\n     *\n     * // With custom options\n     * container.cacheAsTexture({\n     *     resolution: 2,\n     *     antialias: true,\n     * });\n     *\n     * // Disable caching\n     * container.cacheAsTexture(false);\n     *\n     * // Cache a complex UI\n     * const ui = new Container();\n     * // Add multiple children...\n     * ui.cacheAsTexture(true);\n     * ui.updateCacheTexture(); // Update if contents change\n     * ```\n     * @param val - If true, enables caching with default options.\n     *             If false, disables caching.\n     *             Can also pass options object to configure caching behavior.\n     * @see {@link Container#updateCacheTexture} For updating cached content\n     * @see {@link Container#isCachedAsTexture} For checking cache state\n     */\n    cacheAsTexture: (val: boolean | CacheAsTextureOptions) => void;\n\n    /**\n     * Updates the cached texture of this container. This will flag the container's cached texture\n     * to be redrawn on the next render.\n     * @example\n     * ```ts\n     * // Basic update after changes\n     * container.updateCacheTexture();\n     * ```\n     */\n    updateCacheTexture: () => void;\n\n    /**\n     * Legacy property for backwards compatibility with PixiJS v7 and below.\n     * Use `cacheAsTexture` instead.\n     * @deprecated since 8.0.0\n     */\n    cacheAsBitmap: boolean;\n\n    /**\n     * Whether this container is currently cached as a texture.\n     * @example\n     * ```ts\n     * // Check cache state\n     * if (container.isCachedAsTexture) {\n     *     console.log('Container is cached');\n     * }\n     * ```\n     * @readonly\n     * @see {@link Container#cacheAsTexture} For enabling caching\n     * @see {@link Container#updateCacheTexture} For updating cache\n     */\n    readonly isCachedAsTexture: boolean;\n}\n\n/** @internal */\nexport const cacheAsTextureMixin: Partial<Container> = {\n    get isCachedAsTexture(): boolean\n    {\n        return !!this.renderGroup?.isCachedAsTexture;\n    },\n\n    cacheAsTexture(val: boolean | CacheAsTextureOptions): void\n    {\n        if (typeof val === 'boolean' && val === false)\n        {\n            this.disableRenderGroup();\n        }\n        else\n        {\n            this.enableRenderGroup();\n            this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n        }\n    },\n\n    updateCacheTexture(): void\n    {\n        this.renderGroup?.updateCacheTexture();\n    },\n\n    get cacheAsBitmap(): boolean\n    {\n        return this.isCachedAsTexture;\n    },\n\n    set cacheAsBitmap(val: boolean)\n    {\n        // #if _DEBUG\n        deprecation('v8.6.0', 'cacheAsBitmap is deprecated, use cacheAsTexture instead.');\n        // #endif\n        this.cacheAsTexture(val);\n    },\n} as Container;\n", "/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @category utils\n * @internal\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n", "import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container, ContainerChild } from '../Container';\n\n/**\n * Mixin interface for containers that allows them to manage children.\n * It provides methods for adding, removing, and manipulating child containers.\n * @category scene\n * @advanced\n */\nexport interface ChildrenHelperMixin<C = ContainerChild>\n{\n    /** @internal */\n    allowChildren: boolean;\n    addChild<U extends C[]>(...children: U): U[0];\n    removeChild<U extends C[]>(...children: U): U[0];\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @example\n     * ```ts\n     * // Remove all children\n     * container.removeChildren();\n     *\n     * // Remove first 3 children\n     * const removed = container.removeChildren(0, 3);\n     * console.log('Removed:', removed.length); // 3\n     *\n     * // Remove children from index 2 onwards\n     * container.removeChildren(2);\n     *\n     * // Remove specific range\n     * const middle = container.removeChildren(1, 4);\n     * ```\n     * @param {number} beginIndex - The beginning position\n     * @param {number} endIndex - The ending position. Default is container size\n     * @returns List of removed children\n     * @throws {RangeError} If begin/end indexes are invalid\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing specific children\n     */\n    removeChildren(beginIndex?: number, endIndex?: number): C[];\n    /**\n     * Removes a child from the specified index position.\n     * @example\n     * ```ts\n     * // Remove first child\n     * const removed = container.removeChildAt(0);\n     *\n     * // type safe access\n     * const sprite = container.removeChildAt<Sprite>(1);\n     *\n     * // With error handling\n     * try {\n     *     const child = container.removeChildAt(10);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {number} index - The index to remove the child from\n     * @returns The child that was removed\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#removeChild} For removing specific children\n     * @see {@link Container#removeChildren} For removing multiple children\n     */\n    removeChildAt<U extends C>(index: number): U;\n    /**\n     * Returns the child at the specified index.\n     * @example\n     * ```ts\n     * // Get first child\n     * const first = container.getChildAt(0);\n     *\n     * // Type-safe access\n     * const sprite = container.getChildAt<Sprite>(1);\n     *\n     * // With error handling\n     * try {\n     *     const child = container.getChildAt(10);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {number} index - The index to get the child from\n     * @returns The child at the given index\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#children} For direct array access\n     * @see {@link Container#getChildByLabel} For name-based lookup\n     */\n    getChildAt<U extends C>(index: number): U;\n    /**\n     * Changes the position of an existing child in the container.\n     * @example\n     * ```ts\n     * // Basic index change\n     * container.setChildIndex(sprite, 0); // Move to front\n     * container.setChildIndex(sprite, container.children.length - 1); // Move to back\n     *\n     * // With error handling\n     * try {\n     *     container.setChildIndex(sprite, 5);\n     * } catch (e) {\n     *     console.warn('Invalid index or child not found');\n     * }\n     * ```\n     * @param {Container}child - The child Container instance to reposition\n     * @param {number}index - The resulting index number for the child\n     * @throws {Error} If index is out of bounds\n     * @throws {Error} If child is not in container\n     * @see {@link Container#getChildIndex} For getting current index\n     * @see {@link Container#swapChildren} For swapping positions\n     */\n    setChildIndex(child: C, index: number): void;\n    /**\n     * Returns the index position of a child Container instance.\n     * @example\n     * ```ts\n     * // Basic index lookup\n     * const index = container.getChildIndex(sprite);\n     * console.log(`Sprite is at index ${index}`);\n     *\n     * // With error handling\n     * try {\n     *     const index = container.getChildIndex(sprite);\n     * } catch (e) {\n     *     console.warn('Child not found in container');\n     * }\n     * ```\n     * @param {Container} child - The Container instance to identify\n     * @returns The index position of the child container\n     * @throws {Error} If child is not in this container\n     * @see {@link Container#setChildIndex} For changing index\n     * @see {@link Container#children} For direct array access\n     */\n    getChildIndex(child: C): number;\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @example\n     * ```ts\n     * // Add at specific index\n     * container.addChildAt(sprite, 0); // Add to front\n     *\n     * // Move existing child\n     * const index = container.children.length - 1;\n     * container.addChildAt(existingChild, index); // Move to back\n     *\n     * // With error handling\n     * try {\n     *     container.addChildAt(sprite, 1000);\n     * } catch (e) {\n     *     console.warn('Index out of bounds');\n     * }\n     * ```\n     * @param {Container} child - The child to add\n     * @param {number} index - The index where the child will be placed\n     * @returns The child that was added\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#addChild} For adding to the end\n     * @see {@link Container#setChildIndex} For moving existing children\n     */\n    addChildAt<U extends C>(child: U, index: number): U;\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @example\n     * ```ts\n     * // Basic swap\n     * container.swapChildren(sprite1, sprite2);\n     *\n     * // With error handling\n     * try {\n     *     container.swapChildren(sprite1, sprite2);\n     * } catch (e) {\n     *     console.warn('One or both children not found in container');\n     * }\n     * ```\n     * @remarks\n     * - Updates render groups\n     * - No effect if same child\n     * - Triggers container changes\n     * - Common in z-ordering\n     * @param {Container} child - First container to swap\n     * @param {Container} child2 - Second container to swap\n     * @throws {Error} If either child is not in container\n     * @see {@link Container#setChildIndex} For direct index placement\n     * @see {@link Container#getChildIndex} For getting current positions\n     */\n    swapChildren<U extends C>(child: U, child2: U): void;\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @example\n     * ```ts\n     * // Basic removal\n     * sprite.removeFromParent();\n     *\n     * // With validation\n     * if (sprite.parent) {\n     *     sprite.removeFromParent();\n     * }\n     * ```\n     * @see {@link Container#addChild} For adding to a new parent\n     * @see {@link Container#removeChild} For parent removing children\n     */\n    removeFromParent(): void;\n    /**\n     * Reparent a child or multiple children to this container while preserving their world transform.\n     * This ensures that the visual position and rotation of the children remain the same even when changing parents.\n     * @example\n     * ```ts\n     * // Basic reparenting\n     * const sprite = new Sprite(texture);\n     * oldContainer.addChild(sprite);\n     * // Move to new parent, keeping visual position\n     * newContainer.reparentChild(sprite);\n     *\n     * // Reparent multiple children\n     * const batch = [sprite1, sprite2, sprite3];\n     * newContainer.reparentChild(...batch);\n     * ```\n     * @param {Container} child - The child or children to reparent\n     * @returns The first child that was reparented\n     * @see {@link Container#reparentChildAt} For index-specific reparenting\n     * @see {@link Container#addChild} For simple parenting\n     */\n    reparentChild<U extends C[]>(...child: U): U[0];\n    /**\n     * Reparent the child to this container at the specified index while preserving its world transform.\n     * This ensures that the visual position and rotation of the child remain the same even when changing parents.\n     * @example\n     * ```ts\n     * // Basic index-specific reparenting\n     * const sprite = new Sprite(texture);\n     * oldContainer.addChild(sprite);\n     * // Move to new parent at index 0 (front)\n     * newContainer.reparentChildAt(sprite, 0);\n     * ```\n     * @param {Container} child - The child to reparent\n     * @param {number} index - The index to reparent the child to\n     * @returns The reparented child\n     * @throws {Error} If index is out of bounds\n     * @see {@link Container#reparentChild} For appending reparented children\n     * @see {@link Container#addChildAt} For simple indexed parenting\n     */\n    reparentChildAt<U extends C>(child: U, index: number): U;\n    /**\n     * Replace a child in the container with a new child. Copying the local transform from the old child to the new one.\n     * @param {Container} oldChild - The child to replace.\n     * @param {Container} newChild - The new child to add.\n     */\n    replaceChild<U extends C, T extends C>(oldChild: U, newChild: T): void;\n}\n\n/** @internal */\nexport const childrenHelperMixin: ChildrenHelperMixin<ContainerChild> = {\n\n    allowChildren: true,\n\n    removeChildren(beginIndex = 0, endIndex?: number): ContainerChild[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: ContainerChild[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.removeChildren(removed);\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                const child = removed[i];\n\n                child.parentRenderLayer?.detach(child);\n\n                this.emit('childRemoved', child, this, i);\n                removed[i].emit('removed', this);\n            }\n\n            if (removed.length > 0)\n            {\n                this._didViewChangeTick++;\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    removeChildAt<U extends ContainerChild>(index: number): U\n    {\n        const child = this.getChildAt<U>(index);\n\n        return this.removeChild(child);\n    },\n\n    getChildAt<U extends ContainerChild>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    setChildIndex(child: ContainerChild, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    getChildIndex(child: ContainerChild): number\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    addChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child);\n        }\n        else\n        {\n            children.splice(index, 0, child);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n\n    swapChildren<U extends ContainerChild>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        this._didContainerChangeTick++;\n    },\n\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    },\n\n    reparentChild<U extends ContainerChild[]>(...child: U): U[0]\n    {\n        if (child.length === 1)\n        {\n            return this.reparentChildAt(child[0], this.children.length);\n        }\n\n        child.forEach((c) => this.reparentChildAt(c, this.children.length));\n\n        return child[0];\n    },\n\n    reparentChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        if (child.parent === this)\n        {\n            this.setChildIndex(child, index);\n\n            return child;\n        }\n\n        const childMat = child.worldTransform.clone();\n\n        child.removeFromParent();\n        this.addChildAt(child, index);\n\n        const newMatrix = this.worldTransform.clone();\n\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n\n        child.setFromMatrix(childMat);\n\n        return child;\n    },\n\n    replaceChild<U extends ContainerChild, T extends ContainerChild>(oldChild: U, newChild: T)\n    {\n        oldChild.updateLocalTransform();\n        this.addChildAt(newChild, this.getChildIndex(oldChild));\n\n        newChild.setFromMatrix(oldChild.localTransform);\n        newChild.updateLocalTransform();\n        this.removeChild(oldChild);\n    },\n} as Container;\n", "import { type InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer, type RenderPipes } from '../../../rendering/renderers/types';\nimport { type RenderLayer } from '../../layers/RenderLayer';\n\nimport type { Container } from '../Container';\n\n/**\n * The CollectRenderablesMixin interface defines methods for collecting renderable objects\n * from a container and its children. These methods add the renderables to an instruction set,\n * which is used by the renderer to process and display the scene.\n * @category scene\n * @internal\n */\nexport interface CollectRenderablesMixin\n{\n    /**\n     * Collects all renderables from the container and its children, adding them to the instruction set.\n     * This method decides whether to use a simple or advanced collection method based on the container's properties.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n\n    /**\n     * Collects renderables using a simple method, suitable for containers marked as simple.\n     * This method iterates over the container's children and adds their renderables to the instruction set.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderablesSimple(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void;\n\n    /**\n     * Collects renderables using an advanced method, suitable for containers with complex processing needs.\n     * This method handles additional effects and transformations that may be applied to the renderables.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void;\n}\n\n/**\n * The collectRenderablesMixin provides implementations for the methods defined in the CollectRenderablesMixin interface.\n * It includes logic to determine the appropriate method for collecting renderables based on the container's properties.\n * @internal\n */\nexport const collectRenderablesMixin: Partial<Container> = {\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: RenderLayer): void\n    {\n        // Skip processing if the container is not in the current render layer or is not fully visible.\n        if ((this.parentRenderLayer && this.parentRenderLayer !== currentLayer)\n            || this.globalDisplayStatus < 0b111 || !this.includeInBuild) return;\n\n        // Sort children if the container has sortable children.\n        if (this.sortableChildren)\n        {\n            this.sortChildren();\n        }\n\n        // Choose the appropriate method for collecting renderables based on the container's properties.\n        if (this.isSimple)\n        {\n            this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n        }\n        else if (this.renderGroup)\n        {\n            renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n        }\n        else\n        {\n            this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n        }\n    },\n    collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void\n    {\n        const children = this.children;\n        const length = children.length;\n\n        // Iterate over each child and collect their renderables.\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    },\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        // Apply each effect to the renderables before collecting them.\n        for (let i = 0; i < this.effects.length; i++)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.push(effect, this, instructionSet);\n        }\n\n        // Collect renderables using the simple method after applying effects.\n        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n\n        // Remove effects from the renderables after collection, processing in reverse order.\n        for (let i = this.effects.length - 1; i >= 0; i--)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.pop(effect, this, instructionSet);\n        }\n    }\n} as Container;\n", "import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container.\n * @internal\n */\nexport class FilterEffect implements Effect\n{\n    /** read only filters array - to modify, set it again! */\n    public filters: readonly Filter[];\n    /**\n     * If specified, rather than calculating the bounds of the container that the filter\n     * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n     * applied to it\n     */\n    public filterArea?: Rectangle;\n\n    /** the pipe that knows how to handle this effect */\n    public pipe = 'filter';\n    /** the priority of this effect */\n    public priority = 1;\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\n/**\n * Represents a mask effect that can be applied to a container.\n * @category rendering\n * @advanced\n */\nexport type MaskEffect = {mask: unknown} & Effect;\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @category rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /** @private */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): MaskEffect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<MaskEffect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @class\n * @category rendering\n * @advanced\n */\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n", "import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\n/** @ignore */\nexport interface EffectsMixinConstructor\n{\n    /**\n     * The mask to apply, which can be a Container or null.\n     *\n     * If null, it clears the existing mask.\n     * @example\n     * ```ts\n     * // Set a mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: false,\n     * });\n     */\n    mask?: Mask;\n    setMask?: (options: Partial<MaskOptionsAndMask>) => void;\n    /**\n     * Sets the filters for the displayObject.\n     * Filters are visual effects that can be applied to any display object and its children.\n     *\n     * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n     * @example\n     * ```ts\n     * new Container({\n     *     filters: [new BlurFilter(2), new ColorMatrixFilter()],\n     * });\n     * ```\n     * @see {@link Filter} For filter base class\n     */\n    filters?: Filter | readonly Filter[];\n}\n\n/**\n * The Mask type represents different ways to mask a display object.\n * - A number represents a mask ID.\n * - A Container represents a mask object, such as a Graphics or Sprite.\n * - null indicates that no mask is applied.\n * @example\n * ```ts\n * // Using a Container as a mask\n * const maskContainer: Mask = new Graphics();\n * // Using a mask ID\n * const maskId: Mask = 123;\n * // No mask applied\n * const noMask: Mask = null;\n * ```\n * @category scene\n * @standard\n */\nexport type Mask = number | Container | null;\n\n/**\n * Options for configuring mask behavior on a display object.\n * @example\n * ```ts\n * // Basic mask inversion\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true\n * });\n * ```\n * @see {@link Container#setMask} For applying masks with options\n * @see {@link Container#mask} For basic masking\n * @category scene\n * @standard\n */\nexport interface MaskOptions\n{\n    /**\n     * Whether the mask should be inverted.\n     * When true, the masked area becomes transparent and the unmasked area becomes visible.\n     * @default false\n     * @example\n     * ```ts\n     * // Invert the mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true\n     * });\n     * ```\n     */\n    inverse: boolean;\n}\n\n/**\n * MaskOptionsAndMask combines MaskOptions with a Mask for configuring masking behavior.\n * Used when setting up complex masking effects with additional options.\n * @example\n * ```ts\n * sprite.setMask({\n *     mask: graphics,\n *     inverse: true,\n * });\n *\n * // Clear existing mask\n * sprite.setMask({\n *     mask: null,\n *     inverse: false,\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link Container#setMask} For applying masks\n * @see {@link MaskOptions} For base options\n */\nexport interface MaskOptionsAndMask extends MaskOptions\n{\n    /**\n     * The mask to apply, which can be a Container or null.\n     *\n     * If null, it clears the existing mask.\n     * @example\n     * ```ts\n     * // Set a mask\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: false,\n     * });\n     */\n    mask: Mask;\n}\n\n/**\n * The EffectsMixin interface provides methods and properties for managing effects\n * such as masks and filters on a display object.\n * It allows for adding, removing, and configuring effects, as well as setting a mask for the display object.\n * @category scene\n * @advanced\n */\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    /** @private */\n    _maskEffect?: MaskEffect;\n    /** @private */\n    _maskOptions?: MaskOptions;\n    /** @private */\n    _filterEffect?: FilterEffect,\n    /** @private */\n    _markStructureAsChanged(): void;\n\n    /**\n     * The area the filter is applied to. This is used as an optimization to define a specific region\n     * for filter effects instead of calculating the display object bounds each frame.\n     *\n     * > [!NOTE]\n     * > Setting this to a custom Rectangle allows you to define a specific area for filter effects,\n     * > which can improve performance by avoiding expensive bounds calculations.\n     * @example\n     * ```ts\n     * // Set specific filter area\n     * container.filterArea = new Rectangle(0, 0, 100, 100);\n     *\n     * // Optimize filter region\n     * const screen = app.screen;\n     * container.filterArea = new Rectangle(\n     *     screen.x,\n     *     screen.y,\n     *     screen.width,\n     *     screen.height\n     * );\n     * ```\n     * @see {@link Container#filters} For applying filters\n     * @see {@link Rectangle} For area definition\n     */\n    filterArea?: Rectangle,\n    /**\n     * todo Needs docs\n     * @advanced\n     */\n    effects?: Effect[];\n    /**\n     * todo Needs docs.\n     * @param {Effect} effect - The effect to add.\n     * @ignore\n     */\n    addEffect(effect: Effect): void;\n    /**\n     * todo Needs docs.\n     * @param {Effect} effect - The effect to remove.\n     * @ignore\n     */\n    removeEffect(effect: Effect): void;\n    /**\n     * Used to set mask and control mask options on a display object.\n     * Allows for more detailed control over masking behavior compared to the mask property.\n     * @example\n     * ```ts\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * // Create a circular mask\n     * const graphics = new Graphics()\n     *     .beginFill(0xFF3300)\n     *     .drawCircle(100, 100, 50)\n     *     .endFill();\n     *\n     * // Apply mask with options\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true, // Create a hole effect\n     * });\n     *\n     * // Clear existing mask\n     * sprite.setMask({ mask: null });\n     * ```\n     * @param {Partial<MaskOptionsAndMask>} options - Configuration options for the mask\n     * @see {@link Container#mask} For simple masking\n     * @see {@link MaskOptionsAndMask} For full options API\n     */\n    setMask(options: Partial<MaskOptionsAndMask>): void;\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it.\n     *\n     * > [!IMPORTANT] In PixiJS a regular mask must be a {@link Graphics} or a {@link Sprite} object.\n     * > This allows for much faster masking in canvas as it utilities shape clipping.\n     * > Furthermore, a mask of an object must be in the subtree of its parent.\n     * > Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * ```ts\n     * // Apply mask to sprite\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     *\n     * // Remove mask\n     * sprite.mask = null;\n     * ```\n     * @see {@link Graphics} For creating mask shapes\n     * @see {@link Sprite} For texture-based masks\n     * @see {@link Container#setMask} For advanced mask options\n     */\n    mask: Mask;\n    /**\n     * Sets the filters for the displayObject.\n     * Filters are visual effects that can be applied to any display object and its children.\n     *\n     * > [!IMPORTANT] This is a WebGL/WebGPU only feature and will be ignored by the canvas renderer.\n     * @example\n     * ```ts\n     * // Add a single filter\n     * sprite.filters = new BlurFilter(2);\n     *\n     * // Apply multiple filters\n     * container.filters = [\n     *     new BlurFilter(2),\n     *     new ColorMatrixFilter(),\n     * ];\n     *\n     * // Remove filters\n     * sprite.filters = null;\n     * ```\n     * @see {@link Filter} For filter base class\n     */\n    set filters(value: Filter | Filter[] | null | undefined);\n    get filters(): readonly Filter[];\n}\n\n/** @internal */\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _maskOptions: {\n        inverse: false,\n    },\n    _filterEffect: null,\n\n    effects: [],\n\n    _markStructureAsChanged()\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n    },\n\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        this._markStructureAsChanged();\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        this._markStructureAsChanged();\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: Mask)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n\n            this._maskEffect = null;\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    setMask(options: Partial<MaskOptionsAndMask>)\n    {\n        this._maskOptions = {\n            ...this._maskOptions,\n            ...options,\n        };\n\n        if (options.mask)\n        {\n            this.mask = options.mask;\n        }\n\n        this._markStructureAsChanged();\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\n/** @ignore */\nexport interface FindMixinConstructor\n{\n    /**\n     * The instance label of the object.\n     * @default null\n     */\n    label?: string;\n}\n\n/**\n * The FindMixin interface provides methods for finding children within a container by their label.\n * It allows for searching for a single child or multiple children with a specific label,\n * either directly or recursively through the container's hierarchy.\n * @category scene\n * @advanced\n */\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see Container#label\n     * @default null\n     */\n    name: string;\n    /**\n     * @deprecated since 8.0.0\n     * @param {string} label - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see Container#getChildByLabel\n     */\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    /**\n     * Returns the first child in the container with the specified label.\n     * Recursive searches are done in a pre-order traversal.\n     * @example\n     * ```ts\n     * // Basic label search\n     * const child = container.getChildByLabel('player');\n     *\n     * // Search with regular expression\n     * const enemy = container.getChildByLabel(/enemy-\\d+/);\n     *\n     * // Deep search through children\n     * const deepChild = container.getChildByLabel('powerup', true);\n     * ```\n     * @param {RegExp|string} label - Instance label to search for\n     * @param {boolean} deep - Whether to search recursively through children\n     * @returns The first child with the specified label, or null if none found\n     * @see {@link Container#getChildrenByLabel} For finding all matches\n     * @see {@link Container#label} For setting labels\n     */\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    /**\n     * Returns all children in the container with the specified label.\n     * Recursive searches are done in a pre-order traversal.\n     * @example\n     * ```ts\n     * // Basic label search\n     * const enemies = container.getChildrenByLabel('enemy');\n     * // Search with regular expression\n     * const powerups = container.getChildrenByLabel(/powerup-\\d+/);\n     * // Deep search with collection\n     * const buttons = [];\n     * container.getChildrenByLabel('button', true, buttons);\n     * ```\n     * @param {string|RegExp} label  - Instance label to search for\n     * @param {boolean}[deep=false] - Whether to search recursively through children\n     * @param {Container[]} [out=[]]  - Optional array to store matching children in\n     * @returns An array of children with the specified label\n     * @see {@link Container#getChildByLabel} For finding first match\n     * @see {@link Container#label} For setting labels\n     */\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\n/** @internal */\nexport const findMixin: Partial<Container> = {\n    label: null,\n\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n", "// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object represents a rectangular area defined by its position and dimensions.\n * Used for hit testing, bounds calculation, and general geometric operations.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new Rectangle(100, 100, 200, 150);\n *\n * // Use as container bounds\n * container.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n *\n * // Manipulate dimensions\n * rect.width *= 2;\n * rect.height += 50;\n * ```\n * @remarks\n * - Position defined by top-left corner (x,y)\n * - Dimensions defined by width and height\n * - Supports point and rectangle containment\n * - Common in UI and layout calculations\n * @see {@link Circle} For circular shapes\n * @see {@link Polygon} For complex shapes\n * @see {@link RoundedRectangle} For rounded corners\n * @category maths\n * @standard\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Rectangle(0, 0, 100, 100);\n     * console.log(shape.type); // 'rectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'rectangle') {\n     *     console.log(shape.width, shape.height);\n     * }\n     * ```\n     * @readonly\n     * @default 'rectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const rect = new Rectangle();\n     * rect.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const rect = new Rectangle();\n     * rect.y = 100;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     * @example\n     * ```ts\n     * // Basic width setting\n     * const rect = new Rectangle();\n     * rect.width = 200;\n     * ```\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @example\n     * ```ts\n     * // Basic height setting\n     * const rect = new Rectangle();\n     * rect.height = 150;\n     * ```\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /**\n     * Returns the left edge (x-coordinate) of the rectangle.\n     * @example\n     * ```ts\n     * // Get left edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.left); // 100\n     *\n     * // Use in alignment calculations\n     * sprite.x = rect.left + padding;\n     *\n     * // Compare positions\n     * if (point.x > rect.left) {\n     *     console.log('Point is right of rectangle');\n     * }\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the left edge\n     * @see {@link Rectangle.right} For right edge position\n     * @see {@link Rectangle.x} For direct x-coordinate access\n     */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /**\n     * Returns the right edge (x + width) of the rectangle.\n     * @example\n     * ```ts\n     * // Get right edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.right); // 300\n     *\n     * // Align to right edge\n     * sprite.x = rect.right - sprite.width;\n     *\n     * // Check boundaries\n     * if (point.x < rect.right) {\n     *     console.log('Point is inside right bound');\n     * }\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the right edge\n     * @see {@link Rectangle.left} For left edge position\n     * @see {@link Rectangle.width} For width value\n     */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /**\n     * Returns the top edge (y-coordinate) of the rectangle.\n     * @example\n     * ```ts\n     * // Get top edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.top); // 100\n     *\n     * // Position above rectangle\n     * sprite.y = rect.top - sprite.height;\n     *\n     * // Check vertical position\n     * if (point.y > rect.top) {\n     *     console.log('Point is below top edge');\n     * }\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the top edge\n     * @see {@link Rectangle.bottom} For bottom edge position\n     * @see {@link Rectangle.y} For direct y-coordinate access\n     */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /**\n     * Returns the bottom edge (y + height) of the rectangle.\n     * @example\n     * ```ts\n     * // Get bottom edge position\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * console.log(rect.bottom); // 250\n     *\n     * // Stack below rectangle\n     * sprite.y = rect.bottom + margin;\n     *\n     * // Check vertical bounds\n     * if (point.y < rect.bottom) {\n     *     console.log('Point is above bottom edge');\n     * }\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the bottom edge\n     * @see {@link Rectangle.top} For top edge position\n     * @see {@link Rectangle.height} For height value\n     */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /**\n     * Determines whether the Rectangle is empty (has no area).\n     * @example\n     * ```ts\n     * // Check zero dimensions\n     * const rect = new Rectangle(100, 100, 0, 50);\n     * console.log(rect.isEmpty()); // true\n     * ```\n     * @returns True if the rectangle has no area\n     * @see {@link Rectangle.width} For width value\n     * @see {@link Rectangle.height} For height value\n     */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /**\n     * A constant empty rectangle. This is a new object every time the property is accessed.\n     * @example\n     * ```ts\n     * // Get fresh empty rectangle\n     * const empty = Rectangle.EMPTY;\n     * console.log(empty.isEmpty()); // true\n     * ```\n     * @returns A new empty rectangle instance\n     * @see {@link Rectangle.isEmpty} For empty state testing\n     */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Rectangle(100, 100, 200, 150);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.width *= 2;\n     * modified.height += 50;\n     *\n     * // Verify independence\n     * console.log(original.width);  // 200\n     * console.log(modified.width);  // 400\n     * ```\n     * @returns A copy of the rectangle\n     * @see {@link Rectangle.copyFrom} For copying into existing rectangle\n     * @see {@link Rectangle.copyTo} For copying to another rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @example\n     * ```ts\n     * // Convert bounds to rectangle\n     * const bounds = container.getBounds();\n     * const rect = new Rectangle().copyFromBounds(bounds);\n     * ```\n     * @param bounds - The bounds to copy and convert to a rectangle\n     * @returns Returns itself\n     * @see {@link Bounds} For bounds object structure\n     * @see {@link Rectangle.getBounds} For getting rectangle bounds\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Rectangle(100, 100, 200, 150);\n     * const target = new Rectangle();\n     * target.copyFrom(source);\n     *\n     * // Chain with other operations\n     * const rect = new Rectangle()\n     *     .copyFrom(source)\n     *     .pad(10);\n     * ```\n     * @param rectangle - The rectangle to copy from\n     * @returns Returns itself\n     * @see {@link Rectangle.copyTo} For copying to another rectangle\n     * @see {@link Rectangle.clone} For creating new rectangle copy\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Rectangle(100, 100, 200, 150);\n     * const target = new Rectangle();\n     * source.copyTo(target);\n     *\n     * // Chain with other operations\n     * const result = source\n     *     .copyTo(new Rectangle())\n     *     .getBounds();\n     * ```\n     * @param rectangle - The rectangle to copy to\n     * @returns Returns given parameter\n     * @see {@link Rectangle.copyFrom} For copying from another rectangle\n     * @see {@link Rectangle.clone} For creating new rectangle copy\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * const isInside = rect.contains(150, 125); // true\n     * // Check edge cases\n     * console.log(rect.contains(100, 100)); // true (on edge)\n     * console.log(rect.contains(300, 250)); // false (outside)\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     * @see {@link Rectangle.containsRect} For rectangle containment\n     * @see {@link Rectangle.strokeContains} For checking stroke intersection\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this rectangle's stroke\n     * @see {@link Rectangle.contains} For checking fill containment\n     * @see {@link Rectangle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const outerLeft = _x - strokeWidthOuter;\n        const outerRight = _x + width + strokeWidthOuter;\n        const outerTop = _y - strokeWidthOuter;\n        const outerBottom = _y + height + strokeWidthOuter;\n\n        const innerLeft = _x + strokeWidthInner;\n        const innerRight = _x + width - strokeWidthInner;\n        const innerTop = _y + strokeWidthInner;\n        const innerBottom = _y + height - strokeWidthInner;\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n            && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     *\n     * Returns true only if the area of the intersection is greater than 0.\n     * This means that rectangles sharing only a side are not considered intersecting.\n     * @example\n     * ```ts\n     * // Basic intersection check\n     * const rect1 = new Rectangle(0, 0, 100, 100);\n     * const rect2 = new Rectangle(50, 50, 100, 100);\n     * console.log(rect1.intersects(rect2)); // true\n     *\n     * // With transformation matrix\n     * const matrix = new Matrix();\n     * matrix.rotate(Math.PI / 4); // 45 degrees\n     * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation\n     *\n     * // Edge cases\n     * const zeroWidth = new Rectangle(0, 0, 0, 100);\n     * console.log(rect1.intersects(zeroWidth)); // false (no area)\n     * ```\n     * @remarks\n     * - Returns true only if intersection area is > 0\n     * - Rectangles sharing only a side are not intersecting\n     * - Zero-area rectangles cannot intersect anything\n     * - Supports optional transformation matrix\n     * @param other - The Rectangle to intersect with `this`\n     * @param transform - Optional transformation matrix of `other`\n     * @returns True if the transformed `other` Rectangle intersects with `this`\n     * @see {@link Rectangle.containsRect} For containment testing\n     * @see {@link Rectangle.contains} For point testing\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     *\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @example\n     * ```ts\n     * // Basic padding\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * rect.pad(10); // Adds 10px padding on all sides\n     *\n     * // Different horizontal and vertical padding\n     * const uiRect = new Rectangle(0, 0, 100, 50);\n     * uiRect.pad(20, 10); // 20px horizontal, 10px vertical\n     * ```\n     * @remarks\n     * - Adjusts x/y by subtracting padding\n     * - Increases width/height by padding * 2\n     * - Common in UI layout calculations\n     * - Chainable with other methods\n     * @param paddingX - The horizontal padding amount\n     * @param paddingY - The vertical padding amount\n     * @returns Returns itself\n     * @see {@link Rectangle.enlarge} For growing to include another rectangle\n     * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @example\n     * ```ts\n     * // Basic fitting\n     * const container = new Rectangle(0, 0, 100, 100);\n     * const content = new Rectangle(25, 25, 200, 200);\n     * content.fit(container); // Clips to container bounds\n     * ```\n     * @param rectangle - The rectangle to fit around\n     * @returns Returns itself\n     * @see {@link Rectangle.enlarge} For growing to include another rectangle\n     * @see {@link Rectangle.pad} For adding padding around the rectangle\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle so that its corners lie on a grid defined by resolution.\n     * @example\n     * ```ts\n     * // Basic grid alignment\n     * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);\n     * rect.ceil(); // Aligns to whole pixels\n     *\n     * // Custom resolution grid\n     * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);\n     * uiRect.ceil(0.5); // Aligns to half pixels\n     *\n     * // Use with precision value\n     * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);\n     * preciseRect.ceil(1, 0.01); // Handles small decimal variations\n     * ```\n     * @param resolution - The grid size to align to (1 = whole pixels)\n     * @param eps - Small number to prevent floating point errors\n     * @returns Returns itself\n     * @see {@link Rectangle.fit} For constraining to bounds\n     * @see {@link Rectangle.enlarge} For growing dimensions\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Scales the rectangle's dimensions and position by the specified factors.\n     * @example\n     * ```ts\n     * const rect = new Rectangle(50, 50, 100, 100);\n     *\n     * // Scale uniformly\n     * rect.scale(0.5, 0.5);\n     * // rect is now: x=25, y=25, width=50, height=50\n     *\n     * // non-uniformly\n     * rect.scale(0.5, 1);\n     * // rect is now: x=25, y=50, width=50, height=100\n     * ```\n     * @param x - The factor by which to scale the horizontal properties (x, width).\n     * @param y - The factor by which to scale the vertical properties (y, height).\n     * @returns Returns itself\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.x *= x;\n        this.y *= y;\n        this.width *= x;\n        this.height *= y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @example\n     * ```ts\n     * // Basic enlargement\n     * const rect = new Rectangle(50, 50, 100, 100);\n     * const other = new Rectangle(0, 0, 200, 75);\n     * rect.enlarge(other);\n     * // rect is now: x=0, y=0, width=200, height=150\n     *\n     * // Use for bounding box calculation\n     * const bounds = new Rectangle();\n     * objects.forEach((obj) => {\n     *     bounds.enlarge(obj.getBounds());\n     * });\n     * ```\n     * @param rectangle - The rectangle to include\n     * @returns Returns itself\n     * @see {@link Rectangle.fit} For shrinking to fit within another rectangle\n     * @see {@link Rectangle.pad} For adding padding around the rectangle\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @example\n     * ```ts\n     * // Basic bounds retrieval\n     * const rect = new Rectangle(100, 100, 200, 150);\n     * const bounds = rect.getBounds();\n     *\n     * // Reuse existing rectangle\n     * const out = new Rectangle();\n     * rect.getBounds(out);\n     * ```\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle.copyFrom} For direct copying\n     * @see {@link Rectangle.clone} For creating new copy\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    /**\n     * Determines whether another Rectangle is fully contained within this Rectangle.\n     *\n     * Rectangles that occupy the same space are considered to be containing each other.\n     *\n     * Rectangles without area (width or height equal to zero) can't contain anything,\n     * not even other arealess rectangles.\n     * @example\n     * ```ts\n     * // Check if one rectangle contains another\n     * const container = new Rectangle(0, 0, 100, 100);\n     * const inner = new Rectangle(25, 25, 50, 50);\n     *\n     * console.log(container.containsRect(inner)); // true\n     *\n     * // Check overlapping rectangles\n     * const partial = new Rectangle(75, 75, 50, 50);\n     * console.log(container.containsRect(partial)); // false\n     *\n     * // Zero-area rectangles\n     * const empty = new Rectangle(0, 0, 0, 100);\n     * console.log(container.containsRect(empty)); // false\n     * ```\n     * @param other - The Rectangle to check for containment\n     * @returns True if other is fully contained within this Rectangle\n     * @see {@link Rectangle.contains} For point containment\n     * @see {@link Rectangle.intersects} For overlap testing\n     */\n    public containsRect(other: Rectangle): boolean\n    {\n        if (this.width <= 0 || this.height <= 0) return false;\n\n        const x1 = other.x;\n        const y1 = other.y;\n        const x2 = other.x + other.width;\n        const y2 = other.y + other.height;\n\n        return x1 >= this.x && x1 < this.x + this.width\n            && y1 >= this.y && y1 < this.y + this.height\n            && x2 >= this.x && x2 < this.x + this.width\n            && y2 >= this.y && y2 < this.y + this.height;\n    }\n\n    /**\n     * Sets the position and dimensions of the rectangle.\n     * @example\n     * ```ts\n     * // Basic usage\n     * const rect = new Rectangle();\n     * rect.set(100, 100, 200, 150);\n     *\n     * // Chain with other operations\n     * const bounds = new Rectangle()\n     *     .set(0, 0, 100, 100)\n     *     .pad(10);\n     * ```\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     * @returns Returns itself for method chaining\n     * @see {@link Rectangle.copyFrom} For copying from another rectangle\n     * @see {@link Rectangle.clone} For creating a new copy\n     */\n    public set(x: number, y: number, width: number, height: number): this\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * A simple axis-aligned bounding box (AABB) data structure used to define rectangular boundaries.\n * Provides a clearer alternative to array-based bounds representation [minX, minY, maxX, maxY].\n * @example\n * ```ts\n * // Create bounds data\n * const bounds: BoundsData = {\n *     minX: 0,\n *     minY: 0,\n *     maxX: 100,\n *     maxY: 100\n * };\n *\n * // Calculate dimensions\n * const width = bounds.maxX - bounds.minX;\n * const height = bounds.maxY - bounds.minY;\n *\n * // Check if point is inside\n * const isInside = (x: number, y: number) =>\n *     x >= bounds.minX && x <= bounds.maxX &&\n *     y >= bounds.minY && y <= bounds.maxY;\n * ```\n * @see {@link Bounds} For full bounds implementation\n * @see {@link Container#getBounds} For getting bounds\n * @category rendering\n * @standard\n */\nexport interface BoundsData\n{\n    /** The minimum X coordinate of the bounds */\n    minX: number;\n    /** The minimum Y coordinate of the bounds */\n    minY: number;\n    /** The maximum X coordinate of the bounds */\n    maxX: number;\n    /** The maximum Y coordinate of the bounds */\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an axis-aligned bounding box (AABB) used for efficient collision detection and culling.\n * Stores minimum and maximum coordinates to define a rectangular boundary.\n * @example\n * ```ts\n * // Create bounds\n * const bounds = new Bounds();\n *\n * // Add a rectangular frame\n * bounds.addFrame(0, 0, 100, 100);\n * console.log(bounds.width, bounds.height); // 100, 100\n *\n * // Transform bounds\n * const matrix = new Matrix()\n *     .translate(50, 50)\n *     .rotate(Math.PI / 4);\n * bounds.applyMatrix(matrix);\n *\n * // Check point intersection\n * if (bounds.containsPoint(75, 75)) {\n *     console.log('Point is inside bounds!');\n * }\n * ```\n * @category rendering\n * @standard\n */\nexport class Bounds\n{\n    /**\n     * The minimum X coordinate of the bounds.\n     * Represents the leftmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set left edge\n     * bounds.minX = 100;\n     * ```\n     * @default Infinity\n     */\n    public minX = Infinity;\n\n    /**\n     * The minimum Y coordinate of the bounds.\n     * Represents the topmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set top edge\n     * bounds.minY = 100;\n     * ```\n     * @default Infinity\n     */\n    public minY = Infinity;\n\n    /**\n     * The maximum X coordinate of the bounds.\n     * Represents the rightmost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set right edge\n     * bounds.maxX = 200;\n     * // Get width\n     * const width = bounds.maxX - bounds.minX;\n     * ```\n     * @default -Infinity\n     */\n    public maxX = -Infinity;\n\n    /**\n     * The maximum Y coordinate of the bounds.\n     * Represents the bottommost edge of the bounding box.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Set bottom edge\n     * bounds.maxY = 200;\n     * // Get height\n     * const height = bounds.maxY - bounds.minY;\n     * ```\n     * @default -Infinity\n     */\n    public maxY = -Infinity;\n\n    /**\n     * The transformation matrix applied to this bounds object.\n     * Used when calculating bounds with transforms.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Apply translation matrix\n     * bounds.matrix = new Matrix()\n     *     .translate(100, 100);\n     *\n     * // Combine transformations\n     * bounds.matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * // Use in bounds calculations\n     * bounds.addFrame(0, 0, 100, 100); // Uses current matrix\n     * bounds.addFrame(0, 0, 100, 100, customMatrix); // Override matrix\n     * ```\n     * @advanced\n     */\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    /**\n     * Creates a new Bounds object.\n     * @param minX - The minimum X coordinate of the bounds.\n     * @param minY - The minimum Y coordinate of the bounds.\n     * @param maxX - The maximum X coordinate of the bounds.\n     * @param maxY - The maximum Y coordinate of the bounds.\n     */\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty, meaning either width or height is zero or negative.\n     * Empty bounds occur when min values exceed max values on either axis.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Check if newly created bounds are empty\n     * console.log(bounds.isEmpty()); // true, default bounds are empty\n     *\n     * // Add frame and check again\n     * bounds.addFrame(0, 0, 100, 100);\n     * console.log(bounds.isEmpty()); // false, bounds now have area\n     *\n     * // Clear bounds\n     * bounds.clear();\n     * console.log(bounds.isEmpty()); // true, bounds are empty again\n     * ```\n     * @returns True if bounds are empty (have no area)\n     * @see {@link Bounds#clear} For resetting bounds\n     * @see {@link Bounds#isValid} For checking validity\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /**\n     * The bounding rectangle representation of these bounds.\n     * Lazily creates and updates a Rectangle instance based on the current bounds.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Get rectangle representation\n     * const rect = bounds.rectangle;\n     * console.log(rect.x, rect.y, rect.width, rect.height);\n     *\n     * // Use for hit testing\n     * if (bounds.rectangle.contains(mouseX, mouseY)) {\n     *     console.log('Mouse is inside bounds!');\n     * }\n     * ```\n     * @see {@link Rectangle} For rectangle methods\n     * @see {@link Bounds.isEmpty} For bounds validation\n     */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /**\n     * Clears the bounds and resets all coordinates to their default values.\n     * Resets the transformation matrix back to identity.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.isEmpty()); // false\n     * // Clear the bounds\n     * bounds.clear();\n     * console.log(bounds.isEmpty()); // true\n     * ```\n     * @returns This bounds object for chaining\n     */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds directly using coordinate values.\n     * Provides a way to set all bounds values at once.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.set(0, 0, 100, 100);\n     * ```\n     * @param x0 - Left X coordinate of frame\n     * @param y0 - Top Y coordinate of frame\n     * @param x1 - Right X coordinate of frame\n     * @param y1 - Bottom Y coordinate of frame\n     * @see {@link Bounds#addFrame} For matrix-aware bounds setting\n     * @see {@link Bounds#clear} For resetting bounds\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds a rectangular frame to the bounds, optionally transformed by a matrix.\n     * Updates the bounds to encompass the new frame coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.addFrame(0, 0, 100, 100);\n     *\n     * // Add transformed frame\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addFrame(0, 0, 100, 100, matrix);\n     * ```\n     * @param x0 - Left X coordinate of frame\n     * @param y0 - Top Y coordinate of frame\n     * @param x1 - Right X coordinate of frame\n     * @param y1 - Bottom Y coordinate of frame\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addRect} For adding Rectangle objects\n     * @see {@link Bounds#addBounds} For adding other Bounds\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds, optionally transformed by a matrix.\n     * Updates the bounds to encompass the given rectangle.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * // Add simple rectangle\n     * const rect = new Rectangle(0, 0, 100, 100);\n     * bounds.addRect(rect);\n     *\n     * // Add transformed rectangle\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addRect(rect, matrix);\n     * ```\n     * @param rect - The rectangle to be added\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding raw coordinates\n     * @see {@link Bounds#addBounds} For adding other bounds\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds another bounds object to this one, optionally transformed by a matrix.\n     * Expands the bounds to include the given bounds' area.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Add child bounds\n     * const childBounds = sprite.getBounds();\n     * bounds.addBounds(childBounds);\n     *\n     * // Add transformed bounds\n     * const matrix = new Matrix()\n     *     .scale(2, 2);\n     * bounds.addBounds(childBounds, matrix);\n     * ```\n     * @param bounds - The bounds to be added\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding raw coordinates\n     * @see {@link Bounds#addRect} For adding rectangles\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds as a mask, creating an intersection of the two bounds.\n     * Only keeps the overlapping region between current bounds and mask bounds.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Create mask bounds\n     * const mask = new Bounds();\n     * mask.addFrame(50, 50, 150, 150);\n     * // Apply mask - results in bounds of (50,50,100,100)\n     * bounds.addBoundsMask(mask);\n     * ```\n     * @param mask - The Bounds to use as a mask\n     * @see {@link Bounds#addBounds} For union operation\n     * @see {@link Bounds#fit} For fitting to rectangle\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Applies a transformation matrix to the bounds, updating its coordinates.\n     * Transforms all corners of the bounds using the given matrix.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Apply translation\n     * const translateMatrix = new Matrix()\n     *     .translate(50, 50);\n     * bounds.applyMatrix(translateMatrix);\n     * ```\n     * @param matrix - The matrix to apply to the bounds\n     * @see {@link Matrix} For matrix operations\n     * @see {@link Bounds#addFrame} For adding transformed frames\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to fit within the given rectangle.\n     * Clips the bounds if they extend beyond the rectangle's edges.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 200, 200);\n     * // Fit within viewport\n     * const viewport = new Rectangle(50, 50, 100, 100);\n     * bounds.fit(viewport);\n     * // bounds are now (50, 50, 150, 150)\n     * ```\n     * @param rect - The rectangle to fit within\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#addBoundsMask} For intersection\n     * @see {@link Bounds#pad} For expanding bounds\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * Similar to fit() but works with raw coordinate values instead of a Rectangle.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 200, 200);\n     * // Fit to specific coordinates\n     * bounds.fitBounds(50, 150, 50, 150);\n     * // bounds are now (50, 50, 150, 150)\n     * ```\n     * @param left - The left value of the bounds\n     * @param right - The right value of the bounds\n     * @param top - The top value of the bounds\n     * @param bottom - The bottom value of the bounds\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#fit} For fitting to Rectangle\n     * @see {@link Bounds#addBoundsMask} For intersection\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Add equal padding\n     * bounds.pad(10);\n     * // bounds are now (-10, -10, 110, 110)\n     *\n     * // Add different padding for x and y\n     * bounds.pad(20, 10);\n     * // bounds are now (-30, -20, 130, 120)\n     * ```\n     * @param paddingX - The horizontal padding amount\n     * @param paddingY - The vertical padding amount\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#fit} For constraining bounds\n     * @see {@link Bounds#scale} For uniform scaling\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /**\n     * Ceils the bounds by rounding up max values and rounding down min values.\n     * Useful for pixel-perfect calculations and avoiding fractional pixels.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * bounds.set(10.2, 10.9, 50.1, 50.8);\n     *\n     * // Round to whole pixels\n     * bounds.ceil();\n     * // bounds are now (10, 10, 51, 51)\n     * ```\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#scale} For size adjustments\n     * @see {@link Bounds#fit} For constraining bounds\n     */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /**\n     * Creates a new Bounds instance with the same values.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Create a copy\n     * const copy = bounds.clone();\n     *\n     * // Original and copy are independent\n     * bounds.pad(10);\n     * console.log(copy.width === bounds.width); // false\n     * ```\n     * @returns A new Bounds instance with the same values\n     * @see {@link Bounds#copyFrom} For reusing existing bounds\n     */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values, adjusting all edges proportionally.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     *\n     * // Scale uniformly\n     * bounds.scale(2);\n     * // bounds are now (0, 0, 200, 200)\n     *\n     * // Scale non-uniformly\n     * bounds.scale(0.5, 2);\n     * // bounds are now (0, 0, 100, 400)\n     * ```\n     * @param x - The X value to scale by\n     * @param y - The Y value to scale by (defaults to x)\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#pad} For adding padding\n     * @see {@link Bounds#fit} For constraining size\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /**\n     * The x position of the bounds in local space.\n     * Setting this value will move the bounds while maintaining its width.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get x position\n     * console.log(bounds.x); // 0\n     *\n     * // Move bounds horizontally\n     * bounds.x = 50;\n     * console.log(bounds.minX, bounds.maxX); // 50, 150\n     *\n     * // Width stays the same\n     * console.log(bounds.width); // Still 100\n     * ```\n     */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /**\n     * The y position of the bounds in local space.\n     * Setting this value will move the bounds while maintaining its height.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get y position\n     * console.log(bounds.y); // 0\n     *\n     * // Move bounds vertically\n     * bounds.y = 50;\n     * console.log(bounds.minY, bounds.maxY); // 50, 150\n     *\n     * // Height stays the same\n     * console.log(bounds.height); // Still 100\n     * ```\n     */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /**\n     * The width value of the bounds.\n     * Represents the distance between minX and maxX coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get width\n     * console.log(bounds.width); // 100\n     * // Resize width\n     * bounds.width = 200;\n     * console.log(bounds.maxX - bounds.minX); // 200\n     * ```\n     */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /**\n     * The height value of the bounds.\n     * Represents the distance between minY and maxY coordinates.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Get height\n     * console.log(bounds.height); // 100\n     * // Resize height\n     * bounds.height = 150;\n     * console.log(bounds.maxY - bounds.minY); // 150\n     * ```\n     */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /**\n     * The left edge coordinate of the bounds.\n     * Alias for minX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(50, 0, 150, 100);\n     * console.log(bounds.left); // 50\n     * console.log(bounds.left === bounds.minX); // true\n     * ```\n     * @readonly\n     */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /**\n     * The right edge coordinate of the bounds.\n     * Alias for maxX.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.right); // 100\n     * console.log(bounds.right === bounds.maxX); // true\n     * ```\n     * @readonly\n     */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /**\n     * The top edge coordinate of the bounds.\n     * Alias for minY.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 25, 100, 125);\n     * console.log(bounds.top); // 25\n     * console.log(bounds.top === bounds.minY); // true\n     * ```\n     * @readonly\n     */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /**\n     * The bottom edge coordinate of the bounds.\n     * Alias for maxY.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 200);\n     * console.log(bounds.bottom); // 200\n     * console.log(bounds.bottom === bounds.maxY); // true\n     * ```\n     * @readonly\n     */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /**\n     * Whether the bounds has positive width and height.\n     * Checks if both dimensions are greater than zero.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Check if bounds are positive\n     * console.log(bounds.isPositive); // true\n     *\n     * // Negative bounds\n     * bounds.maxX = bounds.minX;\n     * console.log(bounds.isPositive); // false, width is 0\n     * ```\n     * @readonly\n     * @see {@link Bounds#isEmpty} For checking empty state\n     * @see {@link Bounds#isValid} For checking validity\n     */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    /**\n     * Whether the bounds has valid coordinates.\n     * Checks if the bounds has been initialized with real values.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     * console.log(bounds.isValid); // false, default state\n     *\n     * // Set valid bounds\n     * bounds.addFrame(0, 0, 100, 100);\n     * console.log(bounds.isValid); // true\n     * ```\n     * @readonly\n     * @see {@link Bounds#isEmpty} For checking empty state\n     * @see {@link Bounds#isPositive} For checking dimensions\n     */\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.\n     * Used for efficiently updating bounds from raw vertex data.\n     * @example\n     * ```ts\n     * const bounds = new Bounds();\n     *\n     * // Add vertices from geometry\n     * const vertices = new Float32Array([\n     *     0, 0,    // Vertex 1\n     *     100, 0,  // Vertex 2\n     *     100, 100 // Vertex 3\n     * ]);\n     * bounds.addVertexData(vertices, 0, 6);\n     *\n     * // Add transformed vertices\n     * const matrix = new Matrix()\n     *     .translate(50, 50)\n     *     .rotate(Math.PI / 4);\n     * bounds.addVertexData(vertices, 0, 6, matrix);\n     *\n     * // Add subset of vertices\n     * bounds.addVertexData(vertices, 2, 4); // Only second vertex\n     * ```\n     * @param vertexData - The array of vertices to add\n     * @param beginOffset - Starting index in the vertex array\n     * @param endOffset - Ending index in the vertex array (excluded)\n     * @param matrix - Optional transformation matrix\n     * @see {@link Bounds#addFrame} For adding rectangular frames\n     * @see {@link Matrix} For transformation details\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if a point is contained within the bounds.\n     * Returns true if the point's coordinates fall within the bounds' area.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * // Basic point check\n     * console.log(bounds.containsPoint(50, 50)); // true\n     * console.log(bounds.containsPoint(150, 150)); // false\n     *\n     * // Check edges\n     * console.log(bounds.containsPoint(0, 0));   // true, includes edges\n     * console.log(bounds.containsPoint(100, 100)); // true, includes edges\n     * ```\n     * @param x - x coordinate to check\n     * @param y - y coordinate to check\n     * @returns True if the point is inside the bounds\n     * @see {@link Bounds#isPositive} For valid bounds check\n     * @see {@link Bounds#rectangle} For Rectangle representation\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns a string representation of the bounds.\n     * Useful for debugging and logging bounds information.\n     * @example\n     * ```ts\n     * const bounds = new Bounds(0, 0, 100, 100);\n     * console.log(bounds.toString()); // \"[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]\"\n     * ```\n     * @returns A string describing the bounds\n     * @see {@link Bounds#copyFrom} For copying bounds\n     * @see {@link Bounds#clone} For creating a new instance\n     */\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n\n    /**\n     * Copies the bounds from another bounds object.\n     * Useful for reusing bounds objects and avoiding allocations.\n     * @example\n     * ```ts\n     * const sourceBounds = new Bounds(0, 0, 100, 100);\n     * // Copy bounds\n     * const targetBounds = new Bounds();\n     * targetBounds.copyFrom(sourceBounds);\n     * ```\n     * @param bounds - The bounds to copy from\n     * @returns This bounds object for chaining\n     * @see {@link Bounds#clone} For creating new instances\n     */\n    public copyFrom(bounds: Bounds): this\n    {\n        this.minX = bounds.minX;\n        this.minY = bounds.minY;\n        this.maxX = bounds.maxX;\n        this.maxY = bounds.maxY;\n\n        return this;\n    }\n}\n\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\n/** @internal */\nexport const matrixPool = BigPool.getPool<MatrixPoolItem>(Matrix);\n/** @internal */\nexport const boundsPool = BigPool.getPool<BoundsPoolItem>(Bounds);\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { type Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport { type RenderLayer } from '../../layers/RenderLayer';\nimport { Bounds } from '../bounds/Bounds';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { Container } from '../Container';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Interface for the GetFastGlobalBoundsMixin, which provides methods to compute\n * an approximate global bounding box for a container and its children.\n * @category scene\n * @advanced\n */\nexport interface GetFastGlobalBoundsMixin\n{\n    /**\n     * Computes an approximate global bounding box for the container and its children.\n     * This method is optimized for speed by using axis-aligned bounding boxes (AABBs),\n     * and uses the last render results from when it updated the transforms. This function does not update them.\n     * which may result in slightly larger bounds but never smaller than the actual bounds.\n     *\n     * for accurate (but less performant) results use `container.getGlobalBounds`\n     * @param {boolean} [factorRenderLayers] - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The output bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @advanced\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * This method is used internally by getFastGlobalBounds to traverse the scene graph.\n     * @param {boolean} factorRenderLayers - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {RenderLayer} currentLayer - The current render layer being processed.\n     * @internal\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: RenderLayer,\n    ): void;\n}\n\n/**\n * Mixin providing the implementation of the GetFastGlobalBoundsMixin interface.\n * It includes methods to compute and recursively calculate global bounds for containers.\n * @internal\n */\nexport const getFastGlobalBoundsMixin: Partial<Container> = {\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds\n    {\n        bounds ||= new Bounds();\n\n        // Initialize the bounds for fresh calculations.\n        bounds.clear();\n\n        // Calculate bounds recursively, starting from the current container.\n        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n\n        // Validate the calculated bounds, resetting if invalid.\n        if (!bounds.isValid)\n        {\n            bounds.set(0, 0, 0, 0);\n        }\n\n        // Apply the world transformation to the bounds.\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        bounds.applyMatrix(renderGroup.worldTransform);\n\n        return bounds;\n    },\n\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: RenderLayer,\n    )\n    {\n        let localBounds = bounds;\n\n        // Skip if the container is not in the current render layer when factoring render layers.\n        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;\n\n        // Skip if the container is not fully visible or not measurable.\n        if (this.localDisplayStatus !== 0b111 || (!this.measurable))\n        {\n            return;\n        }\n\n        // Determine if effects need to be managed, requiring separate bounds handling.\n        const manageEffects = !!this.effects.length;\n\n        // Use a temporary bounds object if the container is a render group or has effects.\n        if (this.renderGroup || manageEffects)\n        {\n            localBounds = boundsPool.get().clear();\n        }\n\n        // Add the container's own bounds area to the bounds if it exists.\n        if (this.boundsArea)\n        {\n            bounds.addRect(this.boundsArea, this.worldTransform);\n        }\n        else\n        {\n            // If the container is renderable, add its bounds to the local bounds.\n            if (this.renderPipeId)\n            {\n                const viewBounds = (this as Renderable).bounds;\n\n                localBounds.addFrame(\n                    viewBounds.minX,\n                    viewBounds.minY,\n                    viewBounds.maxX,\n                    viewBounds.maxY,\n                    this.groupTransform\n                );\n            }\n\n            // Recursively process each child to include their bounds.\n            const children = this.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n            }\n        }\n\n        // If effects are managed, apply them to the bounds.\n        if (manageEffects)\n        {\n            let advanced = false;\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            // Apply each effect that modifies bounds.\n            for (let i = 0; i < this.effects.length; i++)\n            {\n                if (this.effects[i].addBounds)\n                {\n                    if (!advanced)\n                    {\n                        advanced = true;\n                        localBounds.applyMatrix(renderGroup.worldTransform);\n                    }\n                    this.effects[i].addBounds(localBounds, true);\n                }\n            }\n\n            // Adjust bounds back to the local coordinate space if advanced bounds were calculated.\n            if (advanced)\n            {\n                localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n            }\n\n            // Add the local bounds to the final bounds and return the temporary bounds object.\n            bounds.addBounds(localBounds);\n            boundsPool.return(localBounds);\n        }\n        else if (this.renderGroup)\n        {\n            // If the container is a render group, add its local bounds to the final bounds.\n            bounds.addBounds(localBounds, this.relativeGroupTransform);\n            boundsPool.return(localBounds);\n        }\n    }\n\n} as Container;\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n/**\n * Gets the global bounds of a container, including all its children\n * @param target - The target container to get the bounds from\n * @param skipUpdateTransform - If true, the transform will not be updated before calculating bounds.\n * @param bounds - The output bounds object.\n * @returns The bounds.\n * @internal\n */\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        const renderableBounds = (target as Renderable).bounds;\n\n        if (renderableBounds && !renderableBounds.isEmpty())\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n            bounds.addBounds(renderableBounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\n/**\n * @param target\n * @param parentTransform\n * @internal\n */\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n", "/**\n * @param color1\n * @param color2\n * @internal\n */\nexport function multiplyHexColors(color1: number, color2: number): number\n{\n    if (color1 === 0xFFFFFF || !color2) return color2;\n    if (color2 === 0xFFFFFF || !color1) return color1;\n\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = ((r1 * r2) / 255) | 0;\n    const g = ((g1 * g2) / 255) | 0;\n    const b = ((b1 * b2) / 255) | 0;\n\n    return (r << 16) + (g << 8) + b;\n}\n", "import { multiplyHexColors } from './multiplyHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\n/**\n * @param localBGRColor\n * @param parentBGRColor\n * @internal\n */\nexport function multiplyColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR)\n    {\n        return parentBGRColor;\n    }\n\n    if (parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor;\n    }\n\n    return multiplyHexColors(localBGRColor, parentBGRColor);\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\nimport { multiplyColors } from '../utils/multiplyColors';\n\nimport type { Container } from '../Container';\n\n/**\n * Converts a color from BGR format to RGB format.\n * @param color - The color in BGR format (0xBBGGRR).\n * @returns The color in RGB format (0xRRGGBB).\n * @category utils\n * @internal\n */\nexport function bgr2rgb(color: number): number\n{\n    return ((color & 0xFF) << 16) + (color & 0xFF00) + ((color >> 16) & 0xFF);\n}\n\n/**\n * Interface for a mixin that provides methods to retrieve global properties of a container.\n * This mixin allows you to get the global alpha, transform matrix, and tint color of a container,\n * taking into account its parent containers and render groups.\n * It includes methods to optimize performance by using cached values when available.\n * @category scene\n * @advanced\n */\nexport interface GetGlobalMixin\n{\n    /**\n     * Returns the global (compound) alpha of the container within the scene.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n     *   - If true: Uses cached worldAlpha from the last render pass for better performance\n     * @returns The resulting alpha value (between 0 and 1)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire alpha chain\n     * const preciseAlpha = container.getGlobalAlpha();\n     *\n     * // Faster but may be outdated - uses cached alpha\n     * const cachedAlpha = container.getGlobalAlpha(true);\n     * ```\n     */\n    getGlobalAlpha(skipUpdate?: boolean): number;\n    /**\n     * Returns the global transform matrix of the container within the scene.\n     * @param {Matrix} matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire transform chain for accuracy\n     *   - If true: Uses cached worldTransform from the last render pass for better performance\n     * @returns The resulting transformation matrix (either the input matrix or a new one)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire transform chain\n     * const preciseTransform = container.getGlobalTransform();\n     *\n     * // Faster but may be outdated - uses cached transform\n     * const cachedTransform = container.getGlobalTransform(undefined, true);\n     *\n     * // Reuse existing matrix\n     * const existingMatrix = new Matrix();\n     * container.getGlobalTransform(existingMatrix);\n     * ```\n     */\n    getGlobalTransform(matrix?: Matrix, skipUpdate?: boolean): Matrix;\n    /**\n     * Returns the global (compound) tint color of the container within the scene.\n     * @param {boolean} skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n     *   - If true: Uses cached worldColor from the last render pass for better performance\n     * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n     * @example\n     * ```ts\n     * // Accurate but slower - recalculates entire tint chain\n     * const preciseTint = container.getGlobalTint();\n     *\n     * // Faster but may be outdated - uses cached tint\n     * const cachedTint = container.getGlobalTint(true);\n     * ```\n     */\n    getGlobalTint(skipUpdate?: boolean): number;\n}\n\n/** @internal */\nexport const getGlobalMixin: Partial<Container> = {\n    getGlobalAlpha(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return this.renderGroup.worldAlpha;\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return this.parentRenderGroup.worldAlpha * this.alpha;\n            }\n\n            return this.alpha;\n        }\n\n        let alpha = this.alpha;\n        let current = this.parent;\n\n        while (current)\n        {\n            alpha *= current.alpha;\n            current = current.parent;\n        }\n\n        return alpha;\n    },\n    getGlobalTransform(matrix = new Matrix(), skipUpdate?: boolean): Matrix\n    {\n        if (skipUpdate)\n        {\n            return matrix.copyFrom(this.worldTransform);\n        }\n\n        this.updateLocalTransform();\n\n        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n\n        matrix.appendFrom(this.localTransform, parentTransform);\n        matrixPool.return(parentTransform);\n\n        return matrix;\n    },\n    getGlobalTint(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return bgr2rgb(this.renderGroup.worldColor);\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return bgr2rgb(\n                    multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n                );\n            }\n\n            return this.tint;\n        }\n\n        let color = this.localColor;\n        let parent = this.parent;\n\n        while (parent)\n        {\n            color = multiplyColors(color, parent.localColor);\n            parent = parent.parent;\n        }\n\n        return bgr2rgb(color);\n    }\n\n} as Container;\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\n/**\n * @param target\n * @param bounds\n * @param relativeMatrix\n * @internal\n */\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            bounds.addBounds((target as Renderable).bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\n", "import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n * @internal\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const uid = child.uid;\n        const didChange = ((child._didViewChangeTick & 0xffff) << 16) | (child._didContainerChangeTick & 0xffff);\n\n        const index = previousData.index;\n\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange)\n        {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index = index + 2;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\n/**\n * A utility type that makes all properties of T optional except for the specified keys K.\n * @category utils\n * @internal\n */\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n/** @ignore */\nexport interface MeasureMixinConstructor\n{\n    /**\n     * The width of the display object, in pixels.\n     * @example\n     * ```ts\n     * new Container({ width: 100});\n     * ```\n     * @default 0\n     */\n    width?: number;\n    /**\n     * The height of the display object, in pixels.\n     * @example\n     * ```ts\n     * new Container({ height: 100});\n     * ```\n     * @default 0\n     */\n    height?: number;\n}\n/**\n * The MeasureMixin interface provides methods for measuring and manipulating the size and bounds of a display object.\n * It includes methods to get and set the size of the object, retrieve its local bounds,\n * and calculate its global bounds.\n * @category scene\n * @advanced\n */\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * Uses cached values when possible for better performance.\n     * @example\n     * ```ts\n     * // Basic bounds check\n     * const bounds = container.getLocalBounds();\n     * console.log(`Width: ${bounds.width}, Height: ${bounds.height}`);\n     * // subsequent calls will reuse the cached bounds\n     * const cachedBounds = container.getLocalBounds();\n     * console.log(bounds === cachedBounds); // true\n     * ```\n     * @returns The bounding area\n     * @see {@link Container#getBounds} For world space bounds\n     * @see {@link Bounds} For bounds properties\n     */\n    getLocalBounds(): Bounds;\n    /**\n     * Calculates and returns the (world) bounds of the display object as a Rectangle.\n     * Takes into account transforms and child bounds.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const bounds = sprite.getBounds();\n     * console.log(`World bounds: ${bounds.x}, ${bounds.y}, ${bounds.width}, ${bounds.height}`);\n     *\n     * // Reuse bounds object for performance\n     * const recycleBounds = new Bounds();\n     * sprite.getBounds(false, recycleBounds);\n     *\n     * // Skip update for performance\n     * const fastBounds = sprite.getBounds(true);\n     * ```\n     * @remarks\n     * - Includes transform calculations\n     * - Updates scene graph by default\n     * - Can reuse bounds objects\n     * - Common in hit testing\n     * @param {boolean} skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param {Bounds} bounds - Optional bounds to store the result of the bounds calculation\n     * @returns The minimum axis-aligned rectangle in world space that fits around this object\n     * @see {@link Container#getLocalBounds} For untransformed bounds\n     * @see {@link Bounds} For bounds properties\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    /** @private */\n    _localBoundsCacheData: LocalBoundsCacheData;\n    /** @private */\n    _localBoundsCacheId: number;\n    /** @private */\n    _setWidth(width: number, localWidth: number): void;\n    /** @private */\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\n/** @internal */\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n", "import type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\n\n/** @internal */\nexport interface OnRenderMixinConstructor\n{\n    /**\n     * This callback is used when the container is rendered. It runs every frame during the render process,\n     * making it ideal for per-frame updates and animations.\n     *\n     * > [!NOTE] In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * > and \"updateTransform\" is no longer called every frame\n     * @example\n     * ```ts\n     * // Basic rotation animation\n     * const container = new Container();\n     * container.onRender = () => {\n     *     container.rotation += 0.01;\n     * };\n     *\n     * // Cleanup when done\n     * container.onRender = null; // Removes callback\n     * ```\n     * @param renderer - The renderer instance\n     * @see {@link Renderer} For renderer capabilities\n     */\n    onRender?: ((renderer: Renderer) => void) | null;\n}\n\n/**\n * The OnRenderMixin interface provides a way to define a callback that is executed\n * every time the container is rendered. This is useful for adding custom rendering logic\n * or animations that need to be updated each frame.\n * @category scene\n * @advanced\n */\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    /** @private */\n    _onRender: ((renderer: Renderer) => void) | null;\n}\n\n/** @internal */\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: (renderer: Renderer) => void)\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    get onRender(): (renderer: Renderer) => void\n    {\n        return this._onRender;\n    }\n} as Container;\n", "import type { Container } from '../Container';\n\n/** @ignore */\nexport interface SortMixinConstructor\n{\n    /**\n     * The zIndex of the container.\n     *\n     * Controls the rendering order of children within their parent container.\n     *\n     * A higher value will mean it will be moved towards the front of the rendering order.\n     * @example\n     * ```ts\n     * // Add in any order\n     * container.addChild(character, background, foreground);\n     *\n     * // Adjust rendering order\n     * background.zIndex = 0;\n     * character.zIndex = 1;\n     * foreground.zIndex = 2;\n     * ```\n     * @see {@link Container#sortableChildren} For enabling sorting\n     * @see {@link Container#sortChildren} For manual sorting\n     * @default 0\n     */\n    zIndex?: number;\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @default false\n     * @internal\n     */\n    sortDirty?: boolean;\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array of children,\n     * so it will affect the rendering order.\n     *\n     * > [!NOTE] Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * > as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @example\n     * ```ts\n     * container.sortableChildren = true;\n     * ```\n     * @default false\n     */\n    sortableChildren?: boolean;\n}\n\n/**\n * The SortMixin interface provides methods and properties for sorting children of a container\n * based on their `zIndex` values. It allows for automatic sorting of children when their `zIndex`\n * changes or when new children are added. The mixin includes properties to manage sorting state\n * and methods to sort children explicitly.\n * @category scene\n * @advanced\n */\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    /** @internal */\n    _zIndex: number;\n    /**\n     * Sorts children by zIndex value. Only sorts if container is marked as dirty.\n     * @example\n     * ```ts\n     * // Basic sorting\n     * particles.zIndex = 2;     // Will mark as dirty\n     * container.sortChildren();\n     * ```\n     * @see {@link Container#sortableChildren} For enabling automatic sorting\n     * @see {@link Container#zIndex} For setting child order\n     */\n    sortChildren: () => void;\n    /** @internal */\n    depthOfChildModified: () => void;\n}\n\n/** @internal */\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    sortDirty: false,\n    sortableChildren: false,\n\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n    },\n\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n", "import { Point } from '../../../maths/point/Point';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\n/**\n * Interface for a mixin that provides methods to convert between local and global coordinates.\n * This mixin allows you to get the global position of a container,\n * convert a point from local to global coordinates,\n * and convert a point from global to local coordinates.\n *\n * It includes methods to optimize performance by using cached matrices when available.\n * @category scene\n * @advanced\n */\nexport interface ToLocalGlobalMixin\n{\n    /**\n     * Returns the global position of the container, taking into account the container hierarchy.\n     * @example\n     * ```ts\n     * // Basic position check\n     * const globalPos = sprite.getGlobalPosition();\n     * console.log(`Global: (${globalPos.x}, ${globalPos.y})`);\n     *\n     * // Reuse point object\n     * const point = new Point();\n     * sprite.getGlobalPosition(point);\n     *\n     * // Skip transform update for performance\n     * const fastPos = container.getGlobalPosition(undefined, true);\n     * ```\n     * @param {Point} point - The optional point to write the global value to\n     * @param {boolean} skipUpdate - Should we skip the update transform\n     * @returns The updated point\n     * @see {@link Container#toGlobal} For converting specific points\n     * @see {@link Container#toLocal} For converting to local space\n     */\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    /**\n     * Calculates the global position of a point relative to this container.\n     * Takes into account the container hierarchy and transforms.\n     * @example\n     * ```ts\n     * // Basic point conversion\n     * const localPoint = { x: 10, y: 20 };\n     * const globalPoint = container.toGlobal(localPoint);\n     *\n     * // With point reuse\n     * const reusePoint = new Point();\n     * container.toGlobal(localPoint, reusePoint);\n     *\n     * // Performance optimization\n     * const fastPoint = container.toGlobal(\n     *     { x: 50, y: 50 },\n     *     undefined,\n     *     true // Skip transform update\n     * );\n     * ```\n     * @param {PointData} position - The local point to convert\n     * @param {P} point - Optional point to store the result\n     * @param {boolean} skipUpdate - Whether to skip transform updates\n     * @returns The global position\n     * @see {@link Container#toLocal} For reverse conversion\n     * @see {@link Container#getGlobalPosition} For container position\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    /**\n     * Calculates the local position of the container relative to another point.\n     * Converts coordinates from any coordinate space to this container's local coordinate space.\n     * @example\n     * ```ts\n     * // Basic coordinate conversion\n     * const worldPoint = { x: 100, y: 100 };\n     * const localPos = container.toLocal(worldPoint);\n     *\n     * // Convert from another container\n     * const fromSprite = new Sprite(texture);\n     * fromSprite.position.set(50, 50);\n     * const pointInSprite = { x: 10, y: 10 };\n     * const localPoint = container.toLocal(pointInSprite, fromSprite);\n     *\n     * // With point reuse for performance\n     * const reusePoint = new Point();\n     * container.toLocal(worldPoint, undefined, reusePoint);\n     *\n     * // Skip transform update for static objects\n     * const fastLocal = container.toLocal(\n     *     worldPoint,\n     *     undefined,\n     *     undefined,\n     *     true\n     * );\n     * ```\n     * @param {PointData} position - The world origin to calculate from\n     * @param {Container} from - The Container to calculate the global position from\n     * @param {P} point - A Point object in which to store the value\n     * @param {boolean} skipUpdate - Should we skip the update transform\n     * @returns A point object representing the position in local space\n     * @see {@link Container#toGlobal} For reverse conversion\n     * @see {@link Container#getGlobalPosition} For container position\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\n/** @internal */\nexport const toLocalGlobalMixin: Partial<Container> = {\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.apply(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    },\n\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.applyInverse(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    }\n} as Container;\n", "import { uid } from '../../../../utils/data/uid';\n\nimport type { Renderable } from '../Renderable';\nimport type { Instruction } from './Instruction';\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @category rendering\n * @advanced\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid: number = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    public renderables: Renderable[] = [];\n    /** used by the garbage collector to track when the instruction set was last used */\n    public gcTick = 0;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n    }\n\n    /**\n     * Destroy the instruction set, clearing the instructions and renderables.\n     * @internal\n     */\n    public destroy()\n    {\n        this.instructions.length = 0;\n        this.renderables.length = 0;\n\n        this.renderPipes = null;\n        this.gcTick = 0;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n", "// Taken from the bit-twiddle package\n\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @category maths\n * @advanced\n */\nexport function nextPow2(v: number): number\n{\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n\n    return v + 1;\n}\n\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @category maths\n * @advanced\n */\nexport function isPow2(v: number): boolean\n{\n    return !(v & (v - 1)) && (!!v);\n}\n\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @category maths\n * @advanced\n */\nexport function log2(v: number): number\n{\n    let r = (v > 0xFFFF ? 1 : 0) << 4;\n\n    v >>>= r;\n\n    let shift = (v > 0xFF ? 1 : 0) << 3;\n\n    v >>>= shift; r |= shift;\n    shift = (v > 0xF ? 1 : 0) << 2;\n    v >>>= shift; r |= shift;\n    shift = (v > 0x3 ? 1 : 0) << 1;\n    v >>>= shift; r |= shift;\n\n    return r | (v >> 1);\n}\n", "/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @category utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T\n{\n    const result: Partial<T> = {};\n\n    for (const key in obj)\n    {\n        if (obj[key] !== undefined)\n        {\n            result[key] = obj[key];\n        }\n    }\n\n    return result as T;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\n/**\n * The options for the texture style.\n * @category rendering\n * @advanced\n */\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link COMPARE_FUNCTION}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @category rendering\n * @advanced\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    /** @internal */\n    public _resourceType = 'textureSampler';\n    /** @internal */\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link COMPARE_FUNCTION}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\nimport type { TextureResourceOrOptions } from '../utils/textureFrom';\n\n/**\n * options for creating a new TextureSource\n * @category rendering\n * @advanced\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @category rendering\n * @advanced\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid: number = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     * @internal\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    /** @internal */\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._style.maxAnisotropy = value;\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._style.maxAnisotropy;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no need to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution ||= this._resolution;\n        width ||= this.width;\n        height ||= this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n\n    /**\n     * A helper function that creates a new TextureSource based on the resource you provide.\n     * @param resource - The resource to create the texture source from.\n     */\n    public static from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n", "// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n//\n// This file implements the dihedral group of order 16, also called\n// of degree 8. That's why its called groupD8.\n\nimport { type RectangleLike } from '../../culling/Culler';\nimport { type Rectangle } from '../shapes/Rectangle';\nimport { Matrix } from './Matrix';\n\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nconst rotationCayley: number[][] = [];\n\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {Matrix[]}\n * @private\n */\nconst rotationMatrices: Matrix[] = [];\n\n/** Alias for `Math.sign`. */\nconst signum = Math.sign;\n\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init(): void\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row: number[] = [];\n\n        rotationCayley.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            /* Multiplies rotation matrices i and j. */\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy\n                      && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\n\ninit();\n\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n * @author Ivan: ivanpopelyshev\n * @groupDescription groupD8\n * @category maths\n * @advanced\n */\nexport const groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0°       | East      |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    E: 0,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45°↻     | Southeast |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    SE: 1,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90°↻     | South     |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    S: 2,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135°↻    | Southwest |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    SW: 3,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180°     | West      |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    W: 4,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135°/225°↻ | Northwest    |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    NW: 5,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90°/270°↻  | North        |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    N: 6,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45°/315°↻  | Northeast    |\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    NE: 7,\n\n    /**\n     * Reflection about Y-axis.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n\n    /**\n     * Reflection about the main diagonal.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n\n    /**\n     * Reflection about X-axis.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n\n    /**\n     * Reflection about reverse diagonal.\n     * @group groupD8\n     * @type {GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: (ind: GD8Symmetry): GD8Symmetry => ux[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: (ind: GD8Symmetry): GD8Symmetry => uy[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: (ind: GD8Symmetry): GD8Symmetry => vx[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: (ind: GD8Symmetry): GD8Symmetry => vy[ind],\n\n    /**\n     * @group groupD8\n     * @param {GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: (rotation: GD8Symmetry): GD8Symmetry =>\n    {\n        if (rotation & 8)// true only if between 8 & 15 (reflections)\n        {\n            return rotation & 15;// or rotation % 16\n        }\n\n        return (-rotation) & 7;// or (8 - rotation) % 8\n    },\n\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @group groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {GD8Symmetry} Composed operation\n     */\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][rotationFirst]\n    ),\n\n    /**\n     * Reverse of `add`.\n     * @group groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation\n     * @param {GD8Symmetry} rotationFirst - First operation\n     * @returns {GD8Symmetry} Result\n     */\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]\n    ),\n\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @group groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: (rotation: number): number => rotation ^ 4,\n\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @group groupD8\n     * @param {GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation: GD8Symmetry): boolean => (rotation & 3) === 2, // rotation % 4 === 2\n\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @group groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: (dx: number, dy: number): GD8Symmetry =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return groupD8.S;\n            }\n\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return groupD8.E;\n            }\n\n            return groupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return groupD8.SE;\n            }\n\n            return groupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return groupD8.NE;\n        }\n\n        return groupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @group groupD8\n     * @param {Matrix} matrix - sprite world matrix\n     * @param {GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx = 0, ty = 0): void =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat: Matrix = rotationMatrices[groupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n\n    /**\n     * Transforms rectangle coordinates based on texture packer rotation.\n     * Used when texture atlas pages are rotated and coordinates need to be adjusted.\n     * @group groupD8\n     * @param {RectangleLike} rect - Rectangle with original coordinates to transform\n     * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)\n     * @param {GD8Symmetry} rotation - The groupD8 rotation value\n     * @param {Rectangle} out - Rectangle to store the result\n     * @returns {Rectangle} Transformed coordinates (includes source frame offset)\n     */\n    transformRectCoords: (\n        rect: RectangleLike,\n        sourceFrame: RectangleLike,\n        rotation: GD8Symmetry,\n        out: Rectangle\n    ): Rectangle =>\n    {\n        const { x, y, width, height } = rect;\n        const { x: frameX, y: frameY, width: frameWidth, height: frameHeight } = sourceFrame;\n\n        if (rotation === groupD8.E)\n        {\n            // No rotation\n            out.set(x + frameX, y + frameY, width, height);\n\n            return out;\n        }\n        else if (rotation === groupD8.S)\n        {\n            // 90° clockwise rotation\n            return out.set(\n                (frameWidth - y - height) + frameX,\n                x + frameY,\n                height,\n                width\n            );\n        }\n        else if (rotation === groupD8.W)\n        {\n            // 180° rotation\n            return out.set(\n                (frameWidth - x - width) + frameX,\n                (frameHeight - y - height) + frameY,\n                width,\n                height\n            );\n        }\n        else if (rotation === groupD8.N)\n        {\n            // 270° clockwise rotation (90° counter-clockwise)\n            return out.set(\n                y + frameX,\n                (frameHeight - x - width) + frameY,\n                height,\n                width\n            );\n        }\n\n        // For other rotations (diagonal and reflections), fall back to no rotation\n        // These are less common in typical texture atlases\n        return out.set(x + frameX, y + frameY, width, height);\n    },\n};\n", "/** @internal */\nexport const NOOP = () =>\n{\n    // empty!\n};\n", "import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a BufferImageSource.\n * @category rendering\n * @advanced\n */\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\n/**\n * A texture source that uses a TypedArray or ArrayBuffer as its resource.\n * It automatically determines the format based on the type of TypedArray provided.\n * @category rendering\n * @advanced\n */\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @category rendering\n * @advanced\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferImageSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link NineSlicePlane} texture.\n * @category rendering\n * @advanced\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @category rendering\n * @advanced\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @category rendering\n * @standard\n */\nexport interface TextureOptions<TextureSourceType extends TextureSource = TextureSource>\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSourceType;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /**\n     * Set to true if you plan on modifying this texture's frame, UVs, or swapping its source at runtime.\n     * This is false by default as it improves performance. Generally, it's recommended to create new\n     * textures and swap those rather than modifying an existing texture's properties unless you are\n     * working with a dynamic frames.\n     * Not setting this to true when modifying the texture can lead to visual artifacts.\n     *\n     * If this is false and you modify the texture, you can manually update the sprite's texture by calling\n     * `sprite.onViewUpdate()`.\n     */\n    dynamic?: boolean;\n}\n\n/**\n * A texture that can be bound to a shader as it has a texture source.\n * @category rendering\n * @advanced\n */\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\n/**\n * A texture source can be a string, an image, a video, a canvas, or a texture resource.\n * @category rendering\n * @advanced\n * @see {@link TextureSource}\n * @see {@link TextureResourceOrOptions}\n * @see {@link Texture.from}\n */\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load a texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Assets.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Assets.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Assets.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @category rendering\n * @class\n * @standard\n */\nexport class Texture<TextureSourceType extends TextureSource = TextureSource> extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public readonly uid: number = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /** @internal */\n    public _source: TextureSourceType;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {TextureOptions} options - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions<TextureSourceType> = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = (source?.source ?? new TextureSource()) as TextureSourceType;\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSourceType)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSourceType\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /**\n     * Call this if you have modified the `texture outside` of the constructor.\n     *\n     * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n     */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture<BufferImageSource>;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n", "import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\nimport { TextureStyle } from './TextureStyle';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @category rendering\n * @advanced\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /** The default texture style for the pool */\n    public textureStyle: TextureStyle;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n        this.textureStyle = new TextureStyle(this.textureOptions);\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: false,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.\n     * useful if you modified the style of the texture after getting it from the pool.\n     * @param renderTexture - The renderTexture to free\n     * @param resetStyle - Whether to reset the style of the texture to the default texture style\n     */\n    public returnTexture(renderTexture: Texture, resetStyle = false): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        // we can skip the copy if we don't need to reset the style\n        if (resetStyle)\n        {\n            renderTexture.source.style = this.textureStyle;\n        }\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\n/**\n * The default texture pool instance.\n * @category rendering\n * @advanced\n */\nexport const TexturePool = new TexturePoolClass();\nGlobalResourceRegistry.register(TexturePool);\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type SCALE_MODE } from '../../rendering/renderers/shared/texture/const';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer } from '../../rendering/renderers/types';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BatchableSprite } from '../sprite/BatchableSprite';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Bounds } from './bounds/Bounds';\nimport type { Container } from './Container';\n\n/**\n * Options for caching a container as a texture.\n * @category rendering\n * @advanced\n */\nexport interface CacheAsTextureOptions\n{\n    /**\n     * If true, the texture will be antialiased. This smooths out the edges of the texture.\n     * @default false\n     */\n    antialias?: boolean;\n    /**\n     * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n     * By default the resolution is 1 which is the same as the rendererers resolution.\n     */\n    resolution?: number;\n    /**\n     * Scale Mode to use for the cached texture\n     * @type {SCALE_MODE}\n     * @default 'linear'\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.cacheAsTexture({ scaleMode: 'nearest' });\n     * ```\n     * @see {@link SCALE_MODE}\n     */\n    scaleMode?: SCALE_MODE;\n}\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @category rendering\n * @advanced\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n    public gcTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    public textureNeedsUpdate = true;\n\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    public isCachedAsTexture = false;\n\n    /**\n     * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n     * It can only be accessed after a render pass.\n     * @type {Texture | undefined}\n     */\n    public texture?: Texture;\n\n    /**\n     * The bounds of the cached texture.\n     * @type {Bounds | undefined}\n     * @ignore\n     */\n    public _textureBounds?: Bounds;\n\n    /**\n     * The options for caching the container as a texture.\n     * @type {CacheAsTextureOptions}\n     */\n    public textureOptions: CacheAsTextureOptions;\n\n    /**\n     *  holds a reference to the batchable render sprite\n     *  @ignore\n     */\n    public _batchableRenderGroup: BatchableSprite;\n\n    /**\n     * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @type {RenderGroup | null}\n     * @ignore\n     */\n    public _parentCacheAsTextureRenderGroup: RenderGroup;\n\n    private _inverseWorldTransform: Matrix;\n    private _textureOffsetInverseTransform: Matrix;\n    private _inverseParentTextureTransform: Matrix;\n\n    private _matrixDirty = 0b111;\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            // make sure the children are all updated on the first pass..\n            child._updateFlags = 0b1111;\n\n            this.addChild(child);\n        }\n    }\n\n    public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void\n    {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n\n    public disableCacheAsTexture(): void\n    {\n        this.isCachedAsTexture = false;\n        if (this.texture)\n        {\n            TexturePool.returnTexture(this.texture, true);\n            this.texture = null;\n        }\n    }\n\n    public updateCacheTexture(): void\n    {\n        this.textureNeedsUpdate = true;\n\n        const cachedParent = this._parentCacheAsTextureRenderGroup;\n\n        // It's worth going bottom-up and notify all parents cached as texture\n        // that cached child was updated.\n        if (cachedParent && !cachedParent.textureNeedsUpdate)\n        {\n            cachedParent.updateCacheTexture();\n        }\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n\n        this.disableCacheAsTexture();\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    public updateRenderable(renderable: ViewContainer)\n    {\n        if (renderable.globalDisplayStatus < 0b111) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender(renderer: Renderer)\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender(renderer);\n        }\n    }\n\n    public destroy()\n    {\n        this.disableCacheAsTexture();\n\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    public invalidateMatrices()\n    {\n        this._matrixDirty = 0b111;\n    }\n\n    /**\n     * Returns the inverse of the world transform matrix.\n     * @returns {Matrix} The inverse of the world transform matrix.\n     */\n    public get inverseWorldTransform()\n    {\n        if ((this._matrixDirty & 0b001) === 0) return this._inverseWorldTransform;\n\n        this._matrixDirty &= ~0b001;\n\n        // TODO - add dirty flag\n        this._inverseWorldTransform ||= new Matrix();\n\n        return this._inverseWorldTransform\n            .copyFrom(this.worldTransform)\n            .invert();\n    }\n\n    /**\n     * Returns the inverse of the texture offset transform matrix.\n     * @returns {Matrix} The inverse of the texture offset transform matrix.\n     */\n    public get textureOffsetInverseTransform()\n    {\n        if ((this._matrixDirty & 0b010) === 0) return this._textureOffsetInverseTransform;\n\n        this._matrixDirty &= ~0b010;\n\n        this._textureOffsetInverseTransform ||= new Matrix();\n\n        // TODO shared.. bad!\n        return this._textureOffsetInverseTransform\n            .copyFrom(this.inverseWorldTransform)\n            .translate(\n                -this._textureBounds.x,\n                -this._textureBounds.y\n            );\n    }\n\n    /**\n     * Returns the inverse of the parent texture transform matrix.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @returns {Matrix} The inverse of the parent texture transform matrix.\n     */\n    public get inverseParentTextureTransform()\n    {\n        if ((this._matrixDirty & 0b100) === 0) return this._inverseParentTextureTransform;\n\n        this._matrixDirty &= ~0b100;\n\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n\n        if (parentCacheAsTexture)\n        {\n            this._inverseParentTextureTransform ||= new Matrix();\n\n            // Get relative transform by removing parent's world transform\n            return this._inverseParentTextureTransform\n                .copyFrom(this.worldTransform)\n                .prepend(parentCacheAsTexture.inverseWorldTransform)\n                // Offset by texture bounds\n                .translate(\n                    -parentCacheAsTexture._textureBounds.x,\n                    -parentCacheAsTexture._textureBounds.y\n                );\n        }\n\n        return this.worldTransform;\n    }\n\n    /**\n     * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n     * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n     * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n     * or null if no parent is cached as texture.\n     */\n    public get cacheToLocalTransform()\n    {\n        if (this.isCachedAsTexture)\n        {\n            return this.textureOffsetInverseTransform;\n        }\n\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n", "/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n * @category utils\n * @internal\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { extensions } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { type RenderLayer } from '../layers/RenderLayer';\nimport { cacheAsTextureMixin } from './container-mixins/cacheAsTextureMixin';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { collectRenderablesMixin } from './container-mixins/collectRenderablesMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { getFastGlobalBoundsMixin } from './container-mixins/getFastGlobalBoundsMixin';\nimport { bgr2rgb, getGlobalMixin } from './container-mixins/getGlobalMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\n/**\n * The type of child that can be added to a {@link Container}.\n * This is a generic type that extends the {@link Container} class.\n * @category scene\n * @standard\n */\nexport type ContainerChild = Container;\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\nconst defaultOrigin = new ObservablePoint(null);\n\n/**\n * Events that can be emitted by a Container. These events provide lifecycle hooks and notifications\n * for container state changes.\n * @example\n * ```ts\n * import { Container, Sprite } from 'pixi.js';\n *\n * // Setup container with event listeners\n * const container = new Container();\n *\n * // Listen for child additions\n * container.on('childAdded', (child, container, index) => {\n *     console.log(`Child added at index ${index}:`, child);\n * });\n *\n * // Listen for child removals\n * container.on('childRemoved', (child, container, index) => {\n *     console.log(`Child removed from index ${index}:`, child);\n * });\n *\n * // Listen for when container is added to parent\n * container.on('added', (parent) => {\n *     console.log('Added to parent:', parent);\n * });\n *\n * // Listen for when container is removed from parent\n * container.on('removed', (parent) => {\n *     console.log('Removed from parent:', parent);\n * });\n *\n * // Listen for container destruction\n * container.on('destroyed', (container) => {\n *     console.log('Container destroyed:', container);\n * });\n * ```\n * @category scene\n * @standard\n */\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    /**\n     * Emitted when this container is added to a new container.\n     * Useful for setting up parent-specific behaviors.\n     * @param container - The parent container this was added to\n     * @example\n     * ```ts\n     * const child = new Container();\n     * child.on('added', (parent) => {\n     *     console.log('Child added to parent:', parent.label);\n     * });\n     * parentContainer.addChild(child);\n     * ```\n     */\n    added: [container: Container];\n\n    /**\n     * Emitted when a child is added to this container.\n     * Useful for tracking container composition changes.\n     * @param child - The child that was added\n     * @param container - The container the child was added to (this container)\n     * @param index - The index at which the child was added\n     * @example\n     * ```ts\n     * const parent = new Container();\n     * parent.on('childAdded', (child, container, index) => {\n     *     console.log(`New child at index ${index}:`, child);\n     * });\n     * ```\n     */\n    childAdded: [child: C, container: Container, index: number];\n\n    /**\n     * Emitted when this container is removed from its parent.\n     * Useful for cleanup and state management.\n     * @param container - The parent container this was removed from\n     * @example\n     * ```ts\n     * const child = new Container();\n     * child.on('removed', (oldParent) => {\n     *     console.log('Child removed from parent:', oldParent.label);\n     * });\n     * ```\n     */\n    removed: [container: Container];\n\n    /**\n     * Emitted when a child is removed from this container.\n     * Useful for cleanup and maintaining container state.\n     * @param child - The child that was removed\n     * @param container - The container the child was removed from (this container)\n     * @param index - The index from which the child was removed\n     * @example\n     * ```ts\n     * const parent = new Container();\n     * parent.on('childRemoved', (child, container, index) => {\n     *     console.log(`Child removed from index ${index}:`, child);\n     * });\n     * ```\n     */\n    childRemoved: [child: C, container: Container, index: number];\n\n    /**\n     * Emitted when the container is destroyed.\n     * Useful for final cleanup and resource management.\n     * @param container - The container that was destroyed\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.on('destroyed', (container) => {\n     *     console.log('Container destroyed:', container.label);\n     * });\n     * ```\n     */\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\n/** @internal */\nexport const UPDATE_COLOR = 0b0001;\n/** @internal */\nexport const UPDATE_BLEND = 0b0010;\n/** @internal */\nexport const UPDATE_VISIBLE = 0b0100;\n/** @internal */\nexport const UPDATE_TRANSFORM = 0b1000;\n\n/**\n * Options for updating the transform of a container.\n * @category scene\n * @standard\n */\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n    originX: number;\n    originY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @category scene\n * @standard\n * @see Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /**\n     * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n     *\n     * Setting to 'normal' will reset to default blending.\n     * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n     * @example\n     * ```ts\n     * // Basic blend modes\n     * new Container({ blendMode: 'normal' }); // Default blending\n     * new Container({ blendMode: 'add' });    // Additive blending\n     * new Container({ blendMode: 'multiply' }); // Multiply colors\n     * new Container({ blendMode: 'screen' }); // Screen blend\n     * ```\n     * @default 'normal'\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#tint} For color adjustments\n     */\n    blendMode?: BLEND_MODES;\n    /**\n     * The tint applied to the sprite.\n     *\n     * This can be any valid {@link ColorSource}.\n     * @example\n     * ```ts\n     * new Container({ tint: 0xff0000 }); // Red tint\n     * new Container({ tint: 'blue' }); // Blue tint\n     * new Container({ tint: '#00ff00' }); // Green tint\n     * new Container({ tint: 'rgb(0,0,255)' }); // Blue tint\n     * ```\n     * @default 0xFFFFFF\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#visible} For visibility control\n     */\n    tint?: ColorSource;\n\n    /**\n     * The opacity of the object relative to its parent's opacity.\n     * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n     * @example\n     * ```ts\n     * new Container({ alpha: 0.5 }); // 50% opacity\n     * new Container({ alpha: 1 }); // Fully opaque\n     * ```\n     * @default 1\n     * @see {@link Container#visible} For toggling visibility\n     * @see {@link Container#renderable} For render control\n     */\n    alpha?: number;\n    /**\n     * The angle of the object in degrees.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * new Container({ angle: 45 }); // Rotate 45 degrees\n     * new Container({ angle: 90 }); // Rotate 90 degrees\n     * ```\n     */\n    angle?: number;\n    /**\n     * The array of children of this container. Each child must be a Container or extend from it.\n     *\n     * The array is read-only, but its contents can be modified using Container methods.\n     * @example\n     * ```ts\n     * new Container({\n     *    children: [\n     *        new Container(), // First child\n     *        new Container(), // Second child\n     *    ],\n     * });\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing children\n     */\n    children?: C[];\n    /**\n     * The display object container that contains this display object.\n     * This represents the parent-child relationship in the display tree.\n     * @readonly\n     * @see {@link Container#addChild} For adding to a parent\n     * @see {@link Container#removeChild} For removing from parent\n     */\n    parent?: Container;\n    /**\n     * Controls whether this object can be rendered. If false the object will not be drawn,\n     * but the transform will still be updated. This is different from visible, which skips\n     * transform updates.\n     * @example\n     * ```ts\n     * new Container({ renderable: false }); // Will not be drawn, but transforms will update\n     * ```\n     * @default true\n     * @see {@link Container#visible} For skipping transform updates\n     * @see {@link Container#alpha} For transparency\n     */\n    renderable?: boolean;\n    /**\n     * The rotation of the object in radians.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * new Container({ rotation: Math.PI / 4 }); // Rotate 45 degrees\n     * new Container({ rotation: Math.PI / 2 }); // Rotate 90 degrees\n     * ```\n     */\n    rotation?: number;\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @example\n     * ```ts\n     * new Container({ scale: new Point(2, 2) }); // Scale by 2x\n     * new Container({ scale: 0.5 }); // Scale by 0.5x\n     * new Container({ scale: { x: 1.5, y: 1.5 } }); // Scale by 1.5x\n     * ```\n     */\n    scale?: PointData | number;\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space.\n     * The `position` is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @example\n     * ```ts\n     * new Container({ pivot: new Point(100, 200) }); // Set pivot to (100, 200)\n     * new Container({ pivot: 50 }); // Set pivot to (50, 50)\n     * new Container({ pivot: { x: 150, y: 150 } }); // Set pivot to (150, 150)\n     * ```\n     */\n    pivot?: PointData | number;\n    /**\n     * The origin point around which the container rotates and scales.\n     * Unlike pivot, changing origin will not move the container's position.\n     * @example\n     * ```ts\n     * new Container({ origin: new Point(100, 100) }); // Rotate around point (100,100)\n     * new Container({ origin: 50 }); // Rotate around point (50, 50)\n     * new Container({ origin: { x: 150, y: 150 } }); // Rotate around point (150, 150)\n     * ```\n     */\n    origin?: PointData | number;\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @example\n     * ```ts\n     * new Container({ position: new Point(100, 200) }); // Set position to (100, 200)\n     * new Container({ position: { x: 150, y: 150 } }); // Set position to (150, 150)\n     * ```\n     */\n    position?: PointData;\n    /**\n     * The skew factor for the object in radians. Skewing is a transformation that distorts\n     * the object by rotating it differently at each point, creating a non-uniform shape.\n     * @example\n     * ```ts\n     * new Container({ skew: new Point(0.1, 0.2) }); // Skew by 0.1 radians on x and 0.2 radians on y\n     * new Container({ skew: { x: 0.1, y: 0.2 } }); // Skew by 0.1 radians on x and 0.2 radians on y\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    skew?: PointData;\n    /**\n     * The visibility of the object. If false the object will not be drawn,\n     * and the transform will not be updated.\n     * @example\n     * ```ts\n     * new Container({ visible: false }); // Will not be drawn and transforms will not update\n     * new Container({ visible: true }); // Will be drawn and transforms will update\n     * ```\n     * @default true\n     * @see {@link Container#renderable} For render-only control\n     * @see {@link Container#alpha} For transparency\n     */\n    visible?: boolean;\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.x\n     * @example\n     * ```ts\n     * new Container({ x: 100 }); // Set x position to 100\n     * ```\n     */\n    x?: number;\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.y\n     * @example\n     * ```ts\n     * new Container({ y: 200 }); // Set y position to 200\n     * ```\n     */\n    y?: number;\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     *\n     * > [!IMPORTANT] This is great for optimisation! If for example you have a\n     * > 1000 spinning particles and you know they all sit within a specific bounds,\n     * > then setting it will mean the renderer will not need to measure the\n     * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n     * @example\n     * ```ts\n     * const container = new Container({\n     *    boundsArea: new Rectangle(0, 0, 500, 500) // Set a fixed bounds area\n     * });\n     * ```\n     */\n    boundsArea?: Rectangle;\n}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Container<C extends ContainerChild>\n    extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link Container#localTransform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *         ⍺ and \"skew.y\" is β, then the line x = 0 will be rotated by ⍺ (y = -x*cot⍺) and the line y = 0 will be\n *         rotated by β (y = x*tanβ). A line y = x*tanϴ (i.e. a line at angle ϴ to the x-axis in local-space) will\n *         be rotated by an angle between ⍺ and β.\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = -ϴ and \"skew.y\" = ϴ, it will produce an equivalent of \"rotation\" = ϴ.\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJS’s rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @category scene\n * @standard\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     * @deprecated since 8.8.0\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        // #if _DEBUG\n        deprecation('8.8.0', 'Container.mixin is deprecated, please use extensions.mixin instead.');\n        // #endif\n        extensions.mixin(Container, source);\n    }\n\n    /**\n     * unique id for this container\n     * @internal\n     */\n    public readonly uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // the render group this container owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    public parentRenderGroup: RenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    public parentRenderGroupIndex: number = 0;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container. Each child must be a Container or extend from it.\n     *\n     * The array is read-only, but its contents can be modified using Container methods.\n     * @example\n     * ```ts\n     * // Access children\n     * const firstChild = container.children[0];\n     * const lastChild = container.children[container.children.length - 1];\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChild} For removing children\n     */\n    public children: C[] = [];\n    /**\n     * The display object container that contains this display object.\n     * This represents the parent-child relationship in the display tree.\n     * @example\n     * ```ts\n     * // Basic parent access\n     * const parent = sprite.parent;\n     *\n     * // Walk up the tree\n     * let current = sprite;\n     * while (current.parent) {\n     *     console.log('Level up:', current.parent.constructor.name);\n     *     current = current.parent;\n     * }\n     * ```\n     * @readonly\n     * @see {@link Container#addChild} For adding to a parent\n     * @see {@link Container#removeChild} For removing from parent\n     */\n    public parent: Container | null = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    /**\n     * The RenderLayer this container belongs to, if any.\n     * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.\n     * @readonly\n     * @advanced\n     */\n    public parentRenderLayer: RenderLayer | null = null;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /** @internal */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * This matrix represents the local transformation without any parent influence.\n     * @example\n     * ```ts\n     * // Basic transform access\n     * const localMatrix = sprite.localTransform;\n     * console.log(localMatrix.toString());\n     * ```\n     * @readonly\n     * @see {@link Container#worldTransform} For global transform\n     * @see {@link Container#groupTransform} For render group transform\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     * @advanced\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     * @advanced\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /**\n     * Whether this object has been destroyed. If true, the object should no longer be used.\n     * After an object is destroyed, all of its functionality is disabled and references are removed.\n     * @example\n     * ```ts\n     * // Cleanup with destroy\n     * sprite.destroy();\n     * console.log(sprite.destroyed); // true\n     * ```\n     * @default false\n     * @see {@link Container#destroy} For destroying objects\n     */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The origin point around which the container rotates and scales.\n     * Unlike pivot, changing origin will not move the container's position.\n     * @private\n     */\n    public _origin: ObservablePoint = defaultOrigin;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    /** @internal */\n    public localColor = 0xFFFFFF;\n    /** @internal */\n    public localAlpha = 1;\n\n    /** @internal */\n    public groupAlpha = 1; // A\n    /** @internal */\n    public groupColor = 0xFFFFFF; // BGR\n    /** @internal */\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /** @internal */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /** @internal */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /** @internal */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    /** @internal */\n    public readonly renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     *\n     * > [!IMPORTANT] This is great for optimisation! If for example you have a\n     * > 1000 spinning particles and you know they all sit within a specific bounds,\n     * > then setting it will mean the renderer will not need to measure the\n     * > 1000 children to find the bounds. Instead it will just use the bounds you set.\n     * @example\n     * ```ts\n     * const container = new Container();\n     * container.boundsArea = new Rectangle(0, 0, 500, 500);\n     * ```\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    public _didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    public _didViewChangeTick = 0;\n\n    /** @internal */\n    public layerParentId: string;// = 'default';\n    /**\n     * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n     * @deprecated since 8.2.6\n     * @ignore\n     */\n    set _didChangeId(value: number)\n    {\n        this._didViewChangeTick = (value >> 12) & 0xFFF; // Extract the upper 12 bits\n        this._didContainerChangeTick = value & 0xFFF; // Extract the lower 12 bits\n    }\n    /** @ignore */\n    get _didChangeId(): number\n    {\n        return (this._didContainerChangeTick & 0xfff) | ((this._didViewChangeTick & 0xfff) << 12);\n    }\n\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        this.effects = [];\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     * The children will be rendered as part of this container's display list.\n     * @example\n     * ```ts\n     * // Add a single child\n     * container.addChild(sprite);\n     *\n     * // Add multiple children\n     * container.addChild(background, player, foreground);\n     *\n     * // Add with type checking\n     * const sprite = container.addChild<Sprite>(new Sprite(texture));\n     * sprite.tint = 'red';\n     * ```\n     * @param children - The Container(s) to add to the container\n     * @returns The first child that was added\n     * @see {@link Container#removeChild} For removing children\n     * @see {@link Container#addChildAt} For adding at specific index\n     */\n    public addChild<U extends C[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n\n        // TODO - Optimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        this._didViewChangeTick++;\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * When removing multiple children, events will be triggered for each child in sequence.\n     * @example\n     * ```ts\n     * // Remove a single child\n     * const removed = container.removeChild(sprite);\n     *\n     * // Remove multiple children\n     * const bg = container.removeChild(background, player, userInterface);\n     *\n     * // Remove with type checking\n     * const sprite = container.removeChild<Sprite>(childSprite);\n     * sprite.texture = newTexture;\n     * ```\n     * @param children - The Container(s) to remove\n     * @returns The first child that was removed\n     * @see {@link Container#addChild} For adding children\n     * @see {@link Container#removeChildren} For removing multiple children\n     */\n    public removeChild<U extends C[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0];\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._didViewChangeTick++;\n\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n            else if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.removeChild(child);\n            }\n\n            if (child.parentRenderLayer)\n            {\n                child.parentRenderLayer.detach(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didContainerChangeTick++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (!!this.renderGroup === value) return;\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n        else\n        {\n            this.disableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     * @advanced\n     */\n    get isRenderGroup(): boolean\n    {\n        return !!this.renderGroup;\n    }\n\n    /**\n     * Calling this enables a render group for this container.\n     * This means it will be rendered as a separate set of instructions.\n     * The transform of the container will also be handled on the GPU rather than the CPU.\n     * @advanced\n     */\n    public enableRenderGroup(): void\n    {\n        if (this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        this.renderGroup = BigPool.get(RenderGroup, this);\n\n        // this group matrix will now be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /**\n     * This will disable the render group for this container.\n     * @advanced\n     */\n    public disableRenderGroup(): void\n    {\n        if (!this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        BigPool.return(this.renderGroup);\n\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.renderGroup) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     *\n     * This matrix represents the absolute transformation in the scene graph.\n     * @example\n     * ```ts\n     * // Get world position\n     * const worldPos = container.worldTransform;\n     * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);\n     * ```\n     * @readonly\n     * @see {@link Container#localTransform} For local space transform\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        }\n        else if (this.parentRenderGroup)\n        {\n            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        }\n\n        return this._worldTransform;\n    }\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.x\n     * @example\n     * ```ts\n     * // Basic position\n     * container.x = 100;\n     * ```\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     *\n     * An alias to position.y\n     * @example\n     * ```ts\n     * // Basic position\n     * container.y = 200;\n     * ```\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @example\n     * ```ts\n     * // Basic position setting\n     * container.position.set(100, 200);\n     * container.position.set(100); // Sets both x and y to 100\n     * // Using point data\n     * container.position = { x: 50, y: 75 };\n     * ```\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * // Basic rotation\n     * container.rotation = Math.PI / 4; // 45 degrees\n     *\n     * // Convert from degrees\n     * const degrees = 45;\n     * container.rotation = degrees * Math.PI / 180;\n     *\n     * // Rotate around center\n     * container.pivot.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // 180 degrees\n     *\n     * // Rotate around center with origin\n     * container.origin.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // 180 degrees\n     * ```\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     *\n     * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;\n     * > rotation is in radians, angle is in degrees.\n     * @example\n     * ```ts\n     * // Basic angle rotation\n     * sprite.angle = 45; // 45 degrees\n     *\n     * // Rotate around center\n     * sprite.pivot.set(sprite.width / 2, sprite.height / 2);\n     * sprite.angle = 180; // Half rotation\n     *\n     * // Rotate around center with origin\n     * sprite.origin.set(sprite.width / 2, sprite.height / 2);\n     * sprite.angle = 180; // Half rotation\n     *\n     * // Reset rotation\n     * sprite.angle = 0;\n     * ```\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space.\n     * The `position` is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @example\n     * ```ts\n     * // Rotate around center\n     * container.pivot.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // Rotates around center\n     * ```\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n\n            // #if _DEBUG\n            if (this._origin !== defaultOrigin)\n            {\n                // eslint-disable-next-line max-len\n                warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);\n            }\n            // #endif\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians. Skewing is a transformation that distorts\n     * the object by rotating it differently at each point, creating a non-uniform shape.\n     * @example\n     * ```ts\n     * // Basic skewing\n     * container.skew.set(0.5, 0); // Skew horizontally\n     * container.skew.set(0, 0.5); // Skew vertically\n     *\n     * // Skew with point data\n     * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew\n     *\n     * // Reset skew\n     * container.skew.set(0, 0);\n     *\n     * // Animate skew\n     * app.ticker.add(() => {\n     *     // Create wave effect\n     *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;\n     * });\n     *\n     * // Combine with rotation\n     * container.rotation = Math.PI / 4; // 45 degrees\n     * container.skew.set(0.2, 0.2); // Skew the rotated object\n     * ```\n     * @since 4.0.0\n     * @type {ObservablePoint} Point-like object with x/y properties in radians\n     * @default {x: 0, y: 0}\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @example\n     * ```ts\n     * // Basic scaling\n     * container.scale.set(2, 2); // Scales to double size\n     * container.scale.set(2); // Scales uniformly to double size\n     * container.scale = 2; // Scales uniformly to double size\n     * // Scale to a specific width and height\n     * container.setSize(200, 100); // Sets width to 200 and height to 100\n     * ```\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number | string)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        if (typeof value === 'string')\n        {\n            value = parseFloat(value);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * @experimental\n     * The origin point around which the container rotates and scales without affecting its position.\n     * Unlike pivot, changing the origin will not move the container's position.\n     * @example\n     * ```ts\n     * // Rotate around center point\n     * container.origin.set(container.width / 2, container.height / 2);\n     * container.rotation = Math.PI; // Rotates around center\n     *\n     * // Reset origin\n     * container.origin.set(0, 0);\n     * ```\n     */\n    get origin(): ObservablePoint\n    {\n        if (this._origin === defaultOrigin)\n        {\n            this._origin = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._origin;\n    }\n\n    set origin(value: PointData | number)\n    {\n        if (this._origin === defaultOrigin)\n        {\n            this._origin = new ObservablePoint(this, 0, 0);\n\n            // #if _DEBUG\n            if (this._pivot !== defaultPivot)\n            {\n                // eslint-disable-next-line max-len\n                warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);\n            }\n            // #endif\n        }\n\n        typeof value === 'number' ? this._origin.set(value) : this._origin.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.\n     * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n     * as it is more optimized by not recalculating the local bounds twice.\n     * @example\n     * ```ts\n     * // Basic width setting\n     * container.width = 100;\n     * // Optimized width setting\n     * container.setSize(100, 100);\n     * ```\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container,\n     * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.\n     * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}\n     * as it is more optimized by not recalculating the local bounds twice.\n     * @example\n     * ```ts\n     * // Basic height setting\n     * container.height = 200;\n     * // Optimized height setting\n     * container.setSize(100, 200);\n     * ```\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     *\n     * This is faster than get the width and height separately.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const size = container.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * container.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in.\n     * @returns The size of the container.\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is more efficient than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * container.setSize(100, 200);\n     *\n     * // Set uniform size\n     * container.setSize(100); // Sets both width and height to 100\n     * ```\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, size.width);\n        height !== undefined && this._setHeight(height, size.height);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container.\n     * Allows partial updates of transform properties for optimized manipulation.\n     * @example\n     * ```ts\n     * // Basic transform update\n     * container.updateTransform({\n     *     x: 100,\n     *     y: 200,\n     *     rotation: Math.PI / 4\n     * });\n     *\n     * // Scale and rotate around center\n     * sprite.updateTransform({\n     *     pivotX: sprite.width / 2,\n     *     pivotY: sprite.height / 2,\n     *     scaleX: 2,\n     *     scaleY: 2,\n     *     rotation: Math.PI\n     * });\n     *\n     * // Update position only\n     * button.updateTransform({\n     *     x: button.x + 10, // Move right\n     *     y: button.y      // Keep same y\n     * });\n     * ```\n     * @param opts - Transform options to update\n     * @param opts.x - The x position\n     * @param opts.y - The y position\n     * @param opts.scaleX - The x-axis scale factor\n     * @param opts.scaleY - The y-axis scale factor\n     * @param opts.rotation - The rotation in radians\n     * @param opts.skewX - The x-axis skew factor\n     * @param opts.skewY - The y-axis skew factor\n     * @param opts.pivotX - The x-axis pivot point\n     * @param opts.pivotY - The y-axis pivot point\n     * @returns This container, for chaining\n     * @see {@link Container#setFromMatrix} For matrix-based transforms\n     * @see {@link Container#position} For direct position access\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n        this.origin.set(\n            typeof opts.originX === 'number' ? opts.originX : this.origin.x,\n            typeof opts.originY === 'number' ? opts.originY : this.origin.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform properties by decomposing the given matrix.\n     * Extracts position, scale, rotation, and skew from a transformation matrix.\n     * @example\n     * ```ts\n     * // Basic matrix transform\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4)\n     *     .scale(2, 2);\n     *\n     * container.setFromMatrix(matrix);\n     *\n     * // Copy transform from another container\n     * const source = new Container();\n     * source.position.set(100, 100);\n     * source.rotation = Math.PI / 2;\n     *\n     * target.setFromMatrix(source.localTransform);\n     *\n     * // Reset transform\n     * container.setFromMatrix(Matrix.IDENTITY);\n     * ```\n     * @param matrix - The matrix to use for updating the transform\n     * @see {@link Container#updateTransform} For property-based updates\n     * @see {@link Matrix#decompose} For matrix decomposition details\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        const localTransformChangeId = this._didContainerChangeTick;\n\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n\n        this._didLocalTransformChangeId = localTransformChangeId;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const origin = this._origin;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        const ox = -origin._x;\n        const oy = -origin._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c)) // Pivot offset\n            + ((ox * lt.a) + (oy * lt.c)) // Origin offset for rotation and scaling\n            - ox; // Remove origin to maintain position\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d)) // Pivot offset\n            + ((ox * lt.b) + (oy * lt.d)) // Origin offset for rotation and scaling\n            - oy; // Remove origin to maintain position\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The opacity of the object relative to its parent's opacity.\n     * Value ranges from 0 (fully transparent) to 1 (fully opaque).\n     * @example\n     * ```ts\n     * // Basic transparency\n     * sprite.alpha = 0.5; // 50% opacity\n     *\n     * // Inherited opacity\n     * container.alpha = 0.5;\n     * const child = new Sprite(texture);\n     * child.alpha = 0.5;\n     * container.addChild(child);\n     * // child's effective opacity is 0.25 (0.5 * 0.5)\n     * ```\n     * @default 1\n     * @see {@link Container#visible} For toggling visibility\n     * @see {@link Container#renderable} For render control\n     */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite.\n     *\n     * This can be any valid {@link ColorSource}.\n     * @example\n     * ```ts\n     * // Basic color tinting\n     * container.tint = 0xff0000; // Red tint\n     * container.tint = 'red';    // Same as above\n     * container.tint = '#00ff00'; // Green\n     * container.tint = 'rgb(0,0,255)'; // Blue\n     *\n     * // Remove tint\n     * container.tint = 0xffffff; // White = no tint\n     * container.tint = null;     // Also removes tint\n     * ```\n     * @default 0xFFFFFF\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#visible} For visibility control\n     */\n    get tint(): number\n    {\n        // convert bgr to rgb..\n        return bgr2rgb(this.localColor);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.\n     *\n     * Setting to 'normal' will reset to default blending.\n     * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.\n     * @example\n     * ```ts\n     * // Basic blend modes\n     * sprite.blendMode = 'add';        // Additive blending\n     * sprite.blendMode = 'multiply';   // Multiply colors\n     * sprite.blendMode = 'screen';     // Screen blend\n     *\n     * // Reset blend mode\n     * sprite.blendMode = 'normal';     // Normal blending\n     * ```\n     * @default 'normal'\n     * @see {@link Container#alpha} For transparency\n     * @see {@link Container#tint} For color adjustments\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /**\n     * The visibility of the object. If false the object will not be drawn,\n     * and the transform will not be updated.\n     * @example\n     * ```ts\n     * // Basic visibility toggle\n     * sprite.visible = false; // Hide sprite\n     * sprite.visible = true;  // Show sprite\n     * ```\n     * @default true\n     * @see {@link Container#renderable} For render-only control\n     * @see {@link Container#alpha} For transparency\n     */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 0b010 : 0;\n\n        if ((this.localDisplayStatus & 0b010) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 0 : 0b100;\n\n        if ((this.localDisplayStatus & 0b100) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /**\n     * Controls whether this object can be rendered. If false the object will not be drawn,\n     * but the transform will still be updated. This is different from visible, which skips\n     * transform updates.\n     * @example\n     * ```ts\n     * // Basic render control\n     * sprite.renderable = false; // Skip rendering\n     * sprite.renderable = true;  // Enable rendering\n     * ```\n     * @default true\n     * @see {@link Container#visible} For skipping transform updates\n     * @see {@link Container#alpha} For transparency\n     */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 0b001 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /**\n     * Whether or not the object should be rendered.\n     * @advanced\n     */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * ```ts\n     * container.destroy();\n     * container.destroy(true);\n     * container.destroy({ children: true });\n     * container.destroy({ children: true, texture: true, textureSource: true });\n     * ```\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        // remove children is faster than removeChild..\n\n        let oldChildren: ContainerChild[];\n\n        // we add this check as calling removeChildren on particle container will throw an error\n        // As we know it does cannot have any children, check before calling the function.\n        if (this.children.length)\n        {\n            oldChildren = this.removeChildren(0, this.children.length);\n        }\n\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._origin = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        if (destroyChildren && oldChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n\nextensions.mixin(\n    Container,\n    childrenHelperMixin,\n    getFastGlobalBoundsMixin,\n    toLocalGlobalMixin,\n    onRenderMixin,\n    measureMixin,\n    effectsMixin,\n    findMixin,\n    sortMixin,\n    cullingMixin,\n    cacheAsTextureMixin,\n    getGlobalMixin,\n    collectRenderablesMixin,\n);\n", "/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @enum {number}\n * @category ticker\n * @standard\n */\nexport enum UPDATE_PRIORITY\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link PrepareBase} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n", "import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n", "import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * The callback receives the Ticker instance as its parameter, providing access to timing properties.\n * @example\n * ```ts\n * ticker.add((ticker) => {\n *    // Access deltaTime (dimensionless scalar ~1.0 at 60fps)\n *    sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *    // Access deltaMS (milliseconds elapsed)\n *    const progress = ticker.deltaMS / animationDuration;\n * });\n * ```\n * @category ticker\n * @standard\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * Used for managing animation frames and timing in a PixiJS application.\n *\n * It provides a way to add listeners that will be called on each frame,\n * allowing for smooth animations and updates.\n *\n * ## Time Units\n * - `deltaTime`: Dimensionless scalar (typically ~1.0 at 60 FPS) for frame-independent animations\n * - `deltaMS`: Milliseconds elapsed (capped and speed-scaled) for time-based calculations\n * - `elapsedMS`: Raw milliseconds elapsed (uncapped, unscaled) for measurements\n * - `lastTime`: Timestamp in milliseconds since epoch (performance.now() format)\n *\n * Animation frames are requested\n * only when necessary, e.g., when the ticker is started and the emitter has listeners.\n * @example\n * ```ts\n * // Basic ticker usage with different time units\n * const ticker = new Ticker();\n * ticker.add((ticker) => {\n *     // Frame-independent animation using dimensionless deltaTime\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n *\n *     // Time-based animation using deltaMS (milliseconds)\n *     sprite.x += (100 / 1000) * ticker.deltaMS; // 100 pixels per second\n * });\n * ticker.start();\n *\n * // Control update priority\n * ticker.add(\n *     (ticker) => {\n *         // High priority updates run first\n *         physics.update(ticker.deltaTime);\n *     },\n *     undefined,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // One-time updates\n * ticker.addOnce(() => {\n *     console.log('Runs on next frame only');\n * });\n * ```\n * @see {@link TickerPlugin} For use with Application\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @see {@link TickerCallback} For listener function type\n * @category ticker\n * @standard\n */\nexport class Ticker\n{\n    /**\n     * Target frame rate in frames per millisecond.\n     * Used for converting deltaTime to a scalar time delta.\n     * @example\n     * ```ts\n     * // Default is 0.06 (60 FPS)\n     * console.log(Ticker.targetFPMS); // 0.06\n     *\n     * // Calculate target frame duration\n     * const frameDuration = 1 / Ticker.targetFPMS; // ≈ 16.67ms\n     *\n     * // Use in custom timing calculations\n     * const deltaTime = elapsedMS * Ticker.targetFPMS;\n     * ```\n     * @remarks\n     * - Default is 0.06 (equivalent to 60 FPS)\n     * - Used in deltaTime calculations\n     * - Affects all ticker instances\n     * @default 0.06\n     * @see {@link Ticker#deltaTime} For time scaling\n     * @see {@link Ticker#FPS} For actual frame rate\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method {@link Ticker#start|start}\n     * automatically when a listener is added.\n     * @example\n     * ```ts\n     * // Default behavior (manual start)\n     * const ticker = new Ticker();\n     * ticker.autoStart = false;\n     * ticker.add(() => {\n     *     // Won't run until ticker.start() is called\n     * });\n     *\n     * // Auto-start behavior\n     * const autoTicker = new Ticker();\n     * autoTicker.autoStart = true;\n     * autoTicker.add(() => {\n     *     // Runs immediately when added\n     * });\n     * ```\n     * @default false\n     * @see {@link Ticker#start} For manually starting the ticker\n     * @see {@link Ticker#stop} For manually stopping the ticker\n     */\n    public autoStart = false;\n    /**\n     * Scalar representing the delta time factor.\n     * This is a dimensionless value representing the fraction of a frame at the target framerate.\n     * At 60 FPS, this value is typically around 1.0.\n     *\n     * This is NOT in milliseconds - it's a scalar multiplier for frame-independent animations.\n     * For actual milliseconds, use {@link Ticker#deltaMS}.\n     * @member {number}\n     * @example\n     * ```ts\n     * // Frame-independent animation using deltaTime scalar\n     * ticker.add((ticker) => {\n     *     // Rotate sprite by 0.1 radians per frame, scaled by deltaTime\n     *     sprite.rotation += 0.1 * ticker.deltaTime;\n     * });\n     * ```\n     */\n    public deltaTime: number = 1;\n    /**\n     * Scalar time elapsed in milliseconds from last frame to this frame.\n     * Provides precise timing for animations and updates.\n     *\n     * This value is capped by setting {@link Ticker#minFPS|minFPS}\n     * and is scaled with {@link Ticker#speed|speed}.\n     *\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     *\n     * Defaults to target frame time\n     *\n     * > [!NOTE] The cap may be exceeded by scaling.\n     * @example\n     * ```ts\n     * // Animation timing\n     * ticker.add((ticker) => {\n     *     // Use millisecond timing for precise animations\n     *     const progress = (ticker.deltaMS / animationDuration);\n     *     sprite.alpha = Math.min(1, progress);\n     * });\n     * ```\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from the last frame to this frame.\n     * This value is not capped or scaled and provides raw timing information.\n     *\n     * Unlike {@link Ticker#deltaMS}, this value is unmodified by speed scaling or FPS capping.\n     * @member {number}\n     * @example\n     * ```ts\n     * ticker.add((ticker) => {\n     *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n     * });\n     * ```\n     */\n    public elapsedMS: number;\n    /**\n     * The last time update was invoked, in milliseconds since epoch.\n     * Similar to performance.now() timestamp format.\n     *\n     * Used internally for calculating time deltas between frames.\n     * @member {number}\n     * @example\n     * ```ts\n     * ticker.add((ticker) => {\n     *     const currentTime = performance.now();\n     *     const timeSinceLastFrame = currentTime - ticker.lastTime;\n     *     console.log(`Time since last frame: ${timeSinceLastFrame}ms`);\n     * });\n     * ```\n     */\n    public lastTime: number = -1;\n    /**\n     * Factor of current {@link Ticker#deltaTime|deltaTime}.\n     * Used to scale time for slow motion or fast-forward effects.\n     * @example\n     * ```ts\n     * // Basic speed adjustment\n     * ticker.speed = 0.5; // Half speed (slow motion)\n     * ticker.speed = 2.0; // Double speed (fast forward)\n     *\n     * // Temporary speed changes\n     * function slowMotion() {\n     *     const normalSpeed = ticker.speed;\n     *     ticker.speed = 0.2;\n     *     setTimeout(() => {\n     *         ticker.speed = normalSpeed;\n     *     }, 1000);\n     * }\n     * ```\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     *\n     * `true` if {@link Ticker#start|start} has been called.\n     * `false` if {@link Ticker#stop|Stop} has been called.\n     *\n     * While `false`, this value may change to `true` in the\n     * event of {@link Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     * @example\n     * ```ts\n     * // Check ticker state\n     * const ticker = new Ticker();\n     * console.log(ticker.started); // false\n     *\n     * // Start and verify\n     * ticker.start();\n     * console.log(ticker.started); // true\n     * ```\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /** Conditionally cancels a pending animation frame. */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events.\n     * @param fn - The listener function to add. Receives the Ticker instance as parameter\n     * @param context - The context for the listener\n     * @param priority - The priority of the listener\n     * @example\n     * ```ts\n     * // Access time properties through the ticker parameter\n     * ticker.add((ticker) => {\n     *     // Use deltaTime (dimensionless scalar) for frame-independent animations\n     *     sprite.rotation += 0.1 * ticker.deltaTime;\n     *\n     *     // Use deltaMS (milliseconds) for time-based calculations\n     *     const progress = ticker.deltaMS / animationDuration;\n     *\n     *     // Use elapsedMS for raw timing measurements\n     *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);\n     * });\n     * ```\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only executed once on the next frame.\n     * @example\n     * ```ts\n     * // Basic one-time update\n     * ticker.addOnce(() => {\n     *     console.log('Runs next frame only');\n     * });\n     *\n     * // With specific context\n     * const game = {\n     *     init(ticker) {\n     *         this.loadResources();\n     *         console.log('Game initialized');\n     *     }\n     * };\n     * ticker.addOnce(game.init, game);\n     *\n     * // With priority\n     * ticker.addOnce(\n     *     () => {\n     *         // High priority one-time setup\n     *         physics.init();\n     *     },\n     *     undefined,\n     *     UPDATE_PRIORITY.HIGH\n     * );\n     * ```\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)\n     * @returns This instance of a ticker\n     * @see {@link Ticker#add} For continuous updates\n     * @see {@link Ticker#remove} For removing handlers\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @example\n     * ```ts\n     * // Basic removal\n     * const onTick = () => {\n     *     sprite.rotation += 0.1;\n     * };\n     * ticker.add(onTick);\n     * ticker.remove(onTick);\n     *\n     * // Remove with context\n     * const game = {\n     *     update(ticker) {\n     *         this.physics.update(ticker.deltaTime);\n     *     }\n     * };\n     * ticker.add(game.update, game);\n     * ticker.remove(game.update, game);\n     *\n     * // Remove all matching handlers\n     * // (if same function was added multiple times)\n     * ticker.add(onTick);\n     * ticker.add(onTick);\n     * ticker.remove(onTick); // Removes all instances\n     * ```\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     * @see {@link Ticker#add} For adding handlers\n     * @see {@link Ticker#addOnce} For one-time handlers\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list.\n     * @example\n     * ```ts\n     * // Check number of active listeners\n     * const ticker = new Ticker();\n     * console.log(ticker.count); // 0\n     *\n     * // Add some listeners\n     * ticker.add(() => {});\n     * ticker.add(() => {});\n     * console.log(ticker.count); // 2\n     *\n     * // Check after cleanup\n     * ticker.destroy();\n     * console.log(ticker.count); // 0\n     * ```\n     * @readonly\n     * @see {@link Ticker#add} For adding listeners\n     * @see {@link Ticker#remove} For removing listeners\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /**\n     * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.\n     * @example\n     * ```ts\n     * // Basic manual start\n     * const ticker = new Ticker();\n     * ticker.add(() => {\n     *     // Animation code here\n     * });\n     * ticker.start();\n     * ```\n     * @see {@link Ticker#stop} For stopping the ticker\n     * @see {@link Ticker#autoStart} For automatic starting\n     * @see {@link Ticker#started} For checking ticker state\n     */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /**\n     * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.\n     * @example\n     * ```ts\n     * // Basic stop\n     * const ticker = new Ticker();\n     * ticker.stop();\n     * ```\n     * @see {@link Ticker#start} For starting the ticker\n     * @see {@link Ticker#started} For checking ticker state\n     * @see {@link Ticker#destroy} For cleaning up the ticker\n     */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /**\n     * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.\n     * @example\n     * ```ts\n     * // Clean up with active listeners\n     * const ticker = new Ticker();\n     * ticker.add(() => {});\n     * ticker.destroy(); // Removes all listeners\n     * ```\n     * @see {@link Ticker#stop} For stopping without destroying\n     * @see {@link Ticker#remove} For removing specific listeners\n     */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update.\n     *\n     * An update entails setting the\n     * current {@link Ticker#elapsedMS|elapsedMS},\n     * the current {@link Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     *\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @example\n     * ```ts\n     * // Basic manual update\n     * const ticker = new Ticker();\n     * ticker.update(performance.now());\n     * ```\n     * @param currentTime - The current time of execution (defaults to performance.now())\n     * @see {@link Ticker#deltaTime} For frame delta value\n     * @see {@link Ticker#elapsedMS} For raw elapsed time\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * > [!NOTE] This does not factor in the value of\n     * > {@link Ticker#speed|speed}, which is specific\n     * > to scaling {@link Ticker#deltaTime|deltaTime}.\n     * @example\n     * ```ts\n     * // Basic FPS monitoring\n     * ticker.add(() => {\n     *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);\n     * });\n     * ```\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link Ticker#update|update}.\n     *\n     * This value is used to cap {@link Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link Ticker#FPS|FPS}.\n     *\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @example\n     * ```ts\n     * // Set minimum acceptable frame rate\n     * const ticker = new Ticker();\n     * ticker.minFPS = 30; // Never go below 30 FPS\n     *\n     * // Use with maxFPS for frame rate clamping\n     * ticker.minFPS = 30;\n     * ticker.maxFPS = 60;\n     *\n     * // Monitor delta capping\n     * ticker.add(() => {\n     *     // Delta time will be capped based on minFPS\n     *     console.log(`Delta time: ${ticker.deltaTime}`);\n     * });\n     * ```\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link Ticker#update|update}.\n     *\n     * This will effect the measured value of {@link Ticker#FPS|FPS}.\n     *\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @example\n     * ```ts\n     * // Set minimum acceptable frame rate\n     * const ticker = new Ticker();\n     * ticker.maxFPS = 60; // Never go above 60 FPS\n     *\n     * // Use with maxFPS for frame rate clamping\n     * ticker.minFPS = 30;\n     * ticker.maxFPS = 60;\n     *\n     * // Monitor delta capping\n     * ticker.add(() => {\n     *     // Delta time will be capped based on maxFPS\n     *     console.log(`Delta time: ${ticker.deltaTime}`);\n     * });\n     * ```\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoSource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @type {Ticker}\n     * @readonly\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link PrepareBase} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @type {Ticker}\n     * @readonly\n     * @advanced\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n", "import { type Renderer } from '../rendering/renderers/types';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\n/**\n * CanvasObserver class synchronizes the DOM element's transform with the canvas size and position.\n * It uses ResizeObserver for efficient updates and requestAnimationFrame for fallback.\n * This ensures that the DOM element is always correctly positioned and scaled relative to the canvas.\n * @internal\n */\nexport class CanvasObserver\n{\n    /** A cached value of the last transform applied to the DOM element. */\n    private _lastTransform = '';\n    /** A ResizeObserver instance to observe changes in the canvas size. */\n    private _observer: ResizeObserver | null = null;\n    /** The canvas element that this observer is associated with. */\n    private _canvas: HTMLCanvasElement;\n    /** The DOM element that will be transformed based on the canvas size and position. */\n    private readonly _domElement: HTMLElement;\n    /** The renderer instance that this observer is associated with. */\n    private readonly _renderer: Renderer;\n    /** The last scale values applied to the DOM element, used to avoid unnecessary updates. */\n    private _lastScaleX: number;\n    /** The last scale values applied to the DOM element, used to avoid unnecessary updates. */\n    private _lastScaleY: number;\n    /** A flag to indicate whether the observer is attached to the Ticker for continuous updates. */\n    private _tickerAttached = false;\n\n    constructor(options: { domElement: HTMLElement; renderer: Renderer })\n    {\n        this._domElement = options.domElement;\n        this._renderer = options.renderer;\n\n        // We need to ensure that the canvas is not an OffscreenCanvas\n        if (globalThis.OffscreenCanvas && this._renderer.canvas instanceof OffscreenCanvas) return;\n        this._canvas = this._renderer.canvas;\n        this._attachObserver();\n    }\n\n    /** The canvas element that this CanvasObserver is associated with. */\n    public get canvas(): HTMLCanvasElement\n    {\n        return this._canvas;\n    }\n\n    /** Attaches the DOM element to the canvas parent if it is not already attached. */\n    public ensureAttached()\n    {\n        if (!this._domElement.parentNode && this._canvas.parentNode)\n        {\n            this._canvas.parentNode.appendChild(this._domElement);\n            this.updateTranslation();\n        }\n    }\n\n    /**\n     * Updates the transform of the DOM element based on the canvas size and position.\n     * This method calculates the scale and translation needed to keep the DOM element in sync with the canvas.\n     */\n    public readonly updateTranslation = () =>\n    {\n        if (!this._canvas) return;\n\n        const rect = this._canvas.getBoundingClientRect(); // still needed for left/top\n        const contentWidth = this._canvas.width;\n        const contentHeight = this._canvas.height;\n\n        const sx = (rect.width / contentWidth) * this._renderer.resolution;\n        const sy = (rect.height / contentHeight) * this._renderer.resolution;\n        const tx = rect.left;\n        const ty = rect.top;\n\n        const newTransform = `translate(${tx}px, ${ty}px) scale(${sx}, ${sy})`;\n\n        if (newTransform !== this._lastTransform)\n        {\n            this._domElement.style.transform = newTransform;\n            this._lastTransform = newTransform;\n        }\n    };\n\n    /** Sets up a ResizeObserver if available. This ensures that the DOM element is kept in sync with the canvas size . */\n    private _attachObserver()\n    {\n        if ('ResizeObserver' in globalThis)\n        {\n            if (this._observer)\n            {\n                this._observer.disconnect();\n                this._observer = null;\n            }\n\n            this._observer = new ResizeObserver((entries) =>\n            {\n                for (const entry of entries)\n                {\n                    if (entry.target !== this._canvas)\n                    {\n                        continue;\n                    }\n\n                    const contentWidth = this.canvas.width;\n                    const contentHeight = this.canvas.height;\n                    const sx = (entry.contentRect.width / contentWidth) * this._renderer.resolution;\n                    const sy = (entry.contentRect.height / contentHeight) * this._renderer.resolution;\n\n                    // Only refetch position if scale actually changed\n                    const needsUpdate = this._lastScaleX !== sx || this._lastScaleY !== sy;\n\n                    if (needsUpdate)\n                    {\n                        this.updateTranslation(); // safely fetch `left` and `top` only when needed\n                        this._lastScaleX = sx;\n                        this._lastScaleY = sy;\n                    }\n                }\n            });\n            this._observer.observe(this._canvas);\n        }\n        else if (!this._tickerAttached)\n        {\n            Ticker.shared.add(this.updateTranslation, this, UPDATE_PRIORITY.HIGH);\n        }\n    }\n\n    /** Destroys the CanvasObserver instance, cleaning up observers and Ticker. */\n    public destroy()\n    {\n        if (this._observer)\n        {\n            this._observer.disconnect();\n            this._observer = null;\n        }\n        else if (this._tickerAttached)\n        {\n            Ticker.shared.remove(this.updateTranslation);\n        }\n\n        (this._domElement as null) = null;\n        (this._renderer as null) = null;\n        this._canvas = null;\n        this._tickerAttached = false;\n        this._lastTransform = '';\n        this._lastScaleX = null;\n        this._lastScaleY = null;\n    }\n}\n", "import { Point } from '../maths/point/Point';\n\nimport type { Container } from '../scene/container/Container';\nimport type { EventBoundary } from './EventBoundary';\n\n/**\n * A PixiJS compatible touch event interface that extends the standard DOM Touch interface.\n * Provides additional properties to normalize touch input with mouse/pointer events.\n * @example\n * ```ts\n * // Access touch information\n * sprite.on('touchstart', (event) => {\n *     // Standard touch properties\n *     console.log('Touch position:', event.clientX, event.clientY);\n *     console.log('Touch ID:', event.pointerId);\n *\n *     // Additional PixiJS properties\n *     console.log('Pressure:', event.pressure);\n *     console.log('Size:', event.width, event.height);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n * });\n * ```\n * @category events\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch} DOM Touch Interface\n * @standard\n */\nexport interface PixiTouch extends Touch\n{\n    /** The button being pressed (0: left, 1: middle, 2: right) */\n    button: number;\n\n    /** Bitmap of currently pressed buttons */\n    buttons: number;\n\n    /** Whether this is the primary touch point */\n    isPrimary: boolean;\n\n    /** The width of the touch contact area */\n    width: number;\n\n    /** The height of the touch contact area */\n    height: number;\n\n    /** The angle of tilt along the x-axis (in degrees) */\n    tiltX: number;\n\n    /** The angle of tilt along the y-axis (in degrees) */\n    tiltY: number;\n\n    /** The type of pointer that triggered this event */\n    pointerType: string;\n\n    /** Unique identifier for this touch point */\n    pointerId: number;\n\n    /** The normalized pressure of the pointer (0 to 1) */\n    pressure: number;\n\n    /** The rotation angle of the pointer (e.g., pen) */\n    twist: number;\n\n    /** The normalized tangential pressure of the pointer */\n    tangentialPressure: number;\n\n    /** The x coordinate relative to the current layer */\n    layerX: number;\n\n    /** The y coordinate relative to the current layer */\n    layerY: number;\n\n    /** The x coordinate relative to the target's offset parent */\n    offsetX: number;\n\n    /** The y coordinate relative to the target's offset parent */\n    offsetY: number;\n\n    /** Whether the event was normalized by PixiJS */\n    isNormalized: boolean;\n\n    /** The type of touch event */\n    type: string;\n}\n\n/**\n * A DOM-compatible synthetic event implementation for PixiJS's event system.\n * This class implements the standard DOM Event interface while providing additional\n * functionality specific to PixiJS events.\n * > [!NOTE] You wont receive an instance of this class directly, but rather a subclass\n * > of this class, such as {@link FederatedPointerEvent}, {@link FederatedMouseEvent}, or\n * > {@link FederatedWheelEvent}. This class is the base for all federated events.\n * @example\n * ```ts\n * // Basic event handling\n * sprite.on('pointerdown', (event: FederatedEvent) => {\n *     // Access standard DOM event properties\n *     console.log('Target:', event.target);\n *     console.log('Phase:', event.eventPhase);\n *     console.log('Type:', event.type);\n *\n *     // Control propagation\n *     event.stopPropagation();\n * });\n * ```\n * @typeParam N - The type of native event held. Can be either a UIEvent or PixiTouch.\n * @remarks\n * - Implements the standard DOM UIEvent interface\n * - Provides event bubbling and capturing phases\n * - Supports propagation control\n * - Manages event paths through display tree\n * - Normalizes native browser events\n * @see {@link https://dom.spec.whatwg.org/#event} DOM Event Specification\n * @see {@link FederatedPointerEvent} For pointer-specific events\n * @see {@link FederatedMouseEvent} For mouse-specific events\n * @see {@link FederatedWheelEvent} For wheel-specific events\n * @category events\n * @standard\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated since 7.0.0 */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: Container;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public returnValue: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: Container;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. `\"mouseup\"`. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The `target` is at the end. */\n    public path: Container[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    public which: number;\n\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated `InteractionEvent.data`.\n     * @deprecated since 7.0.0\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /**\n     * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n     * @advanced\n     */\n    public composedPath(): Container[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n     * @deprecated\n     * @ignore\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    public initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n     * @ignore\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    public initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Prevent default behavior of both PixiJS and the user agent.\n     * @example\n     * ```ts\n     * sprite.on('click', (event) => {\n     *     // Prevent both browser's default click behavior\n     *     // and PixiJS's default handling\n     *     event.preventDefault();\n     *\n     *     // Custom handling\n     *     customClickHandler();\n     * });\n     * ```\n     * @remarks\n     * - Only works if the native event is cancelable\n     * - Does not stop event propagation\n     */\n    public preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any additional listeners, including those\n     * on the current target and any following targets in the propagation path.\n     * @example\n     * ```ts\n     * container.on('pointerdown', (event) => {\n     *     // Stop all further event handling\n     *     event.stopImmediatePropagation();\n     *\n     *     // These handlers won't be called:\n     *     // - Other pointerdown listeners on this container\n     *     // - Any pointerdown listeners on parent containers\n     * });\n     * ```\n     * @remarks\n     * - Immediately stops all event propagation\n     * - Prevents other listeners on same target from being called\n     * - More aggressive than stopPropagation()\n     */\n    public stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next target in the propagation path.\n     * The rest of the listeners on the current target will still be notified.\n     * @example\n     * ```ts\n     * child.on('pointermove', (event) => {\n     *     // Handle event on child\n     *     updateChild();\n     *\n     *     // Prevent parent handlers from being called\n     *     event.stopPropagation();\n     * });\n     *\n     * // This won't be called if child handles the event\n     * parent.on('pointermove', (event) => {\n     *     updateParent();\n     * });\n     * ```\n     * @remarks\n     * - Stops event bubbling to parent containers\n     * - Does not prevent other listeners on same target\n     * - Less aggressive than stopImmediatePropagation()\n     */\n    public stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */\n    public readonly NONE = 0;\n    /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */\n    public readonly CAPTURING_PHASE = 1;\n    /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */\n    public readonly AT_TARGET = 2;\n    /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */\n    public readonly BUBBLING_PHASE = 3;\n}\n", "const appleIphone = /iPhone/i;\nconst appleIpod = /iPod/i;\nconst appleTablet = /iPad/i;\nconst appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\nconst androidTablet = /Android/i;\nconst amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i; // Match 'Silk' AND 'Mobile'\nconst amazonTablet = /Silk/i;\nconst windowsPhone = /Windows Phone/i;\nconst windowsTablet = /\\bWindows(?:.+)ARM\\b/i; // Match 'Windows' AND 'ARM'\nconst otherBlackBerry = /BlackBerry/i;\nconst otherBlackBerry10 = /BB10/i;\nconst otherOpera = /Opera Mini/i;\nconst otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nconst otherFirefox = /Mobile(?:.+)Firefox\\b/i; // Match 'Mobile' AND 'Firefox'\n\nexport type UserAgent = string;\nexport type Navigator = {\n  userAgent: string;\n  platform: string;\n  maxTouchPoints?: number;\n};\n\nconst isAppleTabletOnIos13 = (navigator?: Navigator): boolean => {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.platform === 'MacIntel' &&\n    typeof navigator.maxTouchPoints === 'number' &&\n    navigator.maxTouchPoints > 1 &&\n    typeof MSStream === 'undefined'\n  );\n};\n\nfunction createMatch(userAgent: UserAgent): (regex: RegExp) => boolean {\n  return (regex: RegExp): boolean => regex.test(userAgent);\n}\n\nexport type isMobileResult = {\n  apple: {\n    phone: boolean;\n    ipod: boolean;\n    tablet: boolean;\n    universal: boolean;\n    device: boolean;\n  };\n  amazon: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  android: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  windows: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  other: {\n    blackberry: boolean;\n    blackberry10: boolean;\n    opera: boolean;\n    firefox: boolean;\n    chrome: boolean;\n    device: boolean;\n  };\n  phone: boolean;\n  tablet: boolean;\n  any: boolean;\n};\n\nexport type IsMobileParameter = UserAgent | Navigator;\n\nexport default function isMobile(param?: IsMobileParameter): isMobileResult {\n  let nav: Navigator = {\n    userAgent: '',\n    platform: '',\n    maxTouchPoints: 0,\n  };\n\n  if (!param && typeof navigator !== 'undefined') {\n    nav = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      maxTouchPoints: navigator.maxTouchPoints || 0,\n    };\n  } else if (typeof param === 'string') {\n    nav.userAgent = param;\n  } else if (param && param.userAgent) {\n    nav = {\n      userAgent: param.userAgent,\n      platform: param.platform,\n      maxTouchPoints: param.maxTouchPoints || 0,\n    };\n  }\n\n  let userAgent = nav.userAgent;\n\n  // Facebook mobile app's integrated browser adds a bunch of strings that\n  // match everything. Strip it out if it exists.\n  let tmp = userAgent.split('[FBAN');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  // Twitter mobile app's integrated browser on iPad adds a \"Twitter for\n  // iPhone\" string. Same probably happens on other tablet platforms.\n  // This will confuse detection so strip it out if it exists.\n  tmp = userAgent.split('Twitter');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  const match = createMatch(userAgent);\n\n  const result: isMobileResult = {\n    apple: {\n      phone: match(appleIphone) && !match(windowsPhone),\n      ipod: match(appleIpod),\n      tablet:\n        !match(appleIphone) &&\n        (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n      universal: match(appleUniversal),\n      device:\n        (match(appleIphone) ||\n          match(appleIpod) ||\n          match(appleTablet) ||\n          match(appleUniversal) ||\n          isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n    },\n    amazon: {\n      phone: match(amazonPhone),\n      tablet: !match(amazonPhone) && match(amazonTablet),\n      device: match(amazonPhone) || match(amazonTablet),\n    },\n    android: {\n      phone:\n        (!match(windowsPhone) && match(amazonPhone)) ||\n        (!match(windowsPhone) && match(androidPhone)),\n      tablet:\n        !match(windowsPhone) &&\n        !match(amazonPhone) &&\n        !match(androidPhone) &&\n        (match(amazonTablet) || match(androidTablet)),\n      device:\n        (!match(windowsPhone) &&\n          (match(amazonPhone) ||\n            match(amazonTablet) ||\n            match(androidPhone) ||\n            match(androidTablet))) ||\n        match(/\\bokhttp\\b/i),\n    },\n    windows: {\n      phone: match(windowsPhone),\n      tablet: match(windowsTablet),\n      device: match(windowsPhone) || match(windowsTablet),\n    },\n    other: {\n      blackberry: match(otherBlackBerry),\n      blackberry10: match(otherBlackBerry10),\n      opera: match(otherOpera),\n      firefox: match(otherFirefox),\n      chrome: match(otherChrome),\n      device:\n        match(otherBlackBerry) ||\n        match(otherBlackBerry10) ||\n        match(otherOpera) ||\n        match(otherFirefox) ||\n        match(otherChrome),\n    },\n    any: false,\n    phone: false,\n    tablet: false,\n  };\n\n  result.any =\n    result.apple.device ||\n    result.android.device ||\n    result.windows.device ||\n    result.other.device;\n  // excludes 'other' devices and ipods, targeting touchscreen phones\n  result.phone =\n    result.apple.phone || result.android.phone || result.windows.phone;\n  result.tablet =\n    result.apple.tablet || result.android.tablet || result.windows.tablet;\n\n  return result;\n}\n", "export * from './isMobile';\nexport { default } from './isMobile';\n", "import isMobileJs from 'ismobilejs';\n\n// ismobilejs have different import behavior for CJS and ESM, so here is the hack\ntype isMobileJsType = typeof isMobileJs & { default?: typeof isMobileJs };\nconst isMobileCall = (isMobileJs as isMobileJsType).default ?? isMobileJs;\n\n/**\n * The result of the mobile device detection system.\n * Provides detailed information about device type and platform.\n * @example\n * ```ts\n * // Type usage with isMobile\n * const deviceInfo: isMobileResult = isMobile;\n *\n * // Check device categories\n * if (deviceInfo.apple.device) {\n *     console.log('iOS Device Details:', {\n *         isPhone: deviceInfo.apple.phone,\n *         isTablet: deviceInfo.apple.tablet,\n *         isUniversal: deviceInfo.apple.universal\n *     });\n * }\n *\n * // Platform-specific checks\n * const platformInfo = {\n *     isApple: deviceInfo.apple.device,\n *     isAndroid: deviceInfo.android.device,\n *     isAmazon: deviceInfo.amazon.device,\n *     isWindows: deviceInfo.windows.device\n * };\n * ```\n * @category utils\n * @standard\n */\nexport type isMobileResult = {\n    /**\n     * Apple device detection information.\n     * Provides detailed iOS device categorization.\n     * @example\n     * ```ts\n     * // iOS device checks\n     * if (isMobile.apple.device) {\n     *     if (isMobile.apple.tablet) {\n     *         // iPad-specific code\n     *         useTabletLayout();\n     *     } else if (isMobile.apple.phone) {\n     *         // iPhone-specific code\n     *         usePhoneLayout();\n     *     }\n     * }\n     * ```\n     */\n    apple: {\n        /** Whether the device is an iPhone */\n        phone: boolean;\n        /** Whether the device is an iPod Touch */\n        ipod: boolean;\n        /** Whether the device is an iPad */\n        tablet: boolean;\n        /** Whether app is running in iOS universal mode */\n        universal: boolean;\n        /** Whether device is any Apple mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Amazon device detection information.\n     * Identifies Amazon Fire tablets and phones.\n     * @example\n     * ```ts\n     * // Amazon Fire tablet detection\n     * if (isMobile.amazon.tablet) {\n     *     // Fire tablet optimizations\n     *     optimizeForFireTablet();\n     * }\n     * ```\n     */\n    amazon: {\n        /** Whether device is a Fire Phone */\n        phone: boolean;\n        /** Whether device is a Fire Tablet */\n        tablet: boolean;\n        /** Whether device is any Amazon mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Android device detection information.\n     * Categorizes Android phones and tablets.\n     * @example\n     * ```ts\n     * // Android device handling\n     * if (isMobile.android.device) {\n     *     // Check specific type\n     *     const deviceType = isMobile.android.tablet ?\n     *         'tablet' : 'phone';\n     *     console.log(`Android ${deviceType} detected`);\n     * }\n     * ```\n     */\n    android: {\n        /** Whether device is an Android phone */\n        phone: boolean;\n        /** Whether device is an Android tablet */\n        tablet: boolean;\n        /** Whether device is any Android device */\n        device: boolean;\n    };\n\n    /**\n     * Windows device detection information.\n     * Identifies Windows phones and tablets.\n     * @example\n     * ```ts\n     * // Windows device checks\n     * if (isMobile.windows.tablet) {\n     *     // Surface tablet optimizations\n     *     enableTouchFeatures();\n     * }\n     * ```\n     */\n    windows: {\n        /** Whether device is a Windows Phone */\n        phone: boolean;\n        /** Whether device is a Windows tablet */\n        tablet: boolean;\n        /** Whether device is any Windows mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Other device detection information.\n     * Covers additional platforms and browsers.\n     * @example\n     * ```ts\n     * // Check other platforms\n     * if (isMobile.other.blackberry10) {\n     *     // BlackBerry 10 specific code\n     * } else if (isMobile.other.chrome) {\n     *     // Chrome mobile specific code\n     * }\n     * ```\n     */\n    other: {\n        /** Whether device is a BlackBerry */\n        blackberry: boolean;\n        /** Whether device is a BlackBerry 10 */\n        blackberry10: boolean;\n        /** Whether browser is Opera Mobile */\n        opera: boolean;\n        /** Whether browser is Firefox Mobile */\n        firefox: boolean;\n        /** Whether browser is Chrome Mobile */\n        chrome: boolean;\n        /** Whether device is any other mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Whether the device is any type of phone.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a phone\n     * if (isMobile.phone) {\n     *     console.log('Running on a mobile phone');\n     * }\n     * ```\n     */\n    phone: boolean;\n\n    /**\n     * Whether the device is any type of tablet.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a tablet\n     * if (isMobile.tablet) {\n     *     console.log('Running on a mobile tablet');\n     * }\n     * ```\n     */\n    tablet: boolean;\n\n    /**\n     * Whether the device is any type of mobile device.\n     * True if any mobile platform is detected.\n     * @example\n     * ```ts\n     * // Check if device is mobile\n     * if (isMobile.any) {\n     *     console.log('Running on a mobile device');\n     * }\n     * ```\n     */\n    any: boolean;\n};\n\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * Provides a comprehensive detection system for mobile platforms and devices.\n * @example\n * ```ts\n * import { isMobile } from 'pixi.js';\n *\n * // Check specific device types\n * if (isMobile.apple.tablet) {\n *    console.log('Running on iPad');\n * }\n *\n * // Check platform categories\n * if (isMobile.android.any) {\n *    console.log('Running on Android');\n * }\n *\n * // Conditional rendering\n * if (isMobile.phone) {\n *    renderer.resolution = 2;\n *    view.style.width = '100vw';\n * }\n * ```\n * @remarks\n * - Detects all major mobile platforms\n * - Distinguishes between phones and tablets\n * - Updates when navigator changes\n * - Common in responsive design\n * @category utils\n * @standard\n * @see {@link isMobileResult} For full type definition\n */\nexport const isMobile: isMobileResult = isMobileCall(globalThis.navigator);\n", "/* eslint-disable no-restricted-globals */\nimport { CanvasObserver } from '../dom/CanvasObserver';\nimport { FederatedEvent } from '../events/FederatedEvent';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { isMobile } from '../utils/browser/isMobile';\nimport { removeItems } from '../utils/data/removeItems';\nimport { type AccessibleHTMLElement } from './accessibilityTarget';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { isMobileResult } from '../utils/browser/isMobile';\n\n/** @ignore */\nconst KEY_CODE_TAB = 9;\n\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\n\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1000;\nconst DIV_HOOK_POS_Y = -1000;\nconst DIV_HOOK_ZINDEX = 2;\n\n/**\n * Initialisation options for the accessibility system when used with an Application.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilitySystemOptions\n{\n    /** Options for the accessibility system */\n    accessibilityOptions?: AccessibilityOptions;\n}\n\n/**\n * The options for the accessibility system.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilityOptions\n{\n    /** Whether to enable accessibility features on initialization instead of waiting for tab key */\n    enabledByDefault?: boolean;\n    /** Whether to visually show the accessibility divs for debugging */\n    debug?: boolean;\n    /** Whether to allow tab key press to activate accessibility features */\n    activateOnTab?: boolean;\n    /** Whether to deactivate accessibility when mouse moves */\n    deactivateOnMouseMove?: boolean;\n}\n\n/**\n * The Accessibility system provides screen reader and keyboard navigation support for PixiJS content.\n * It creates an accessible DOM layer over the canvas that can be controlled programmatically or through user interaction.\n *\n * By default, the system activates when users press the tab key. This behavior can be customized through options:\n * ```js\n * const app = new Application({\n *     accessibilityOptions: {\n *     // Enable immediately instead of waiting for tab\n *     enabledByDefault: true,\n *     // Disable tab key activation\n *     activateOnTab: false,\n *     // Show/hide accessibility divs\n *     debug: false,\n *     // Prevent accessibility from being deactivated when mouse moves\n *     deactivateOnMouseMove: false,\n * }\n * });\n * ```\n *\n * The system can also be controlled programmatically by accessing the `renderer.accessibility` property:\n * ```js\n * app.renderer.accessibility.setAccessibilityEnabled(true);\n * ```\n *\n * To make individual containers accessible:\n * ```js\n * container.accessible = true;\n * ```\n * There are several properties that can be set on a Container to control its accessibility which can\n * be found here: {@link AccessibleOptions}.\n * @category accessibility\n * @standard\n */\nexport class AccessibilitySystem implements System<AccessibilitySystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'accessibility',\n    } as const;\n\n    /**\n     * The default options used by the system.\n     * You can set these before initializing the {@link Application} to change the default behavior.\n     * @example\n     * ```js\n     * import { AccessibilitySystem } from 'pixi.js';\n     *\n     * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n     *\n     * const app = new Application()\n     * app.init()\n     * ```\n     */\n    public static defaultOptions: AccessibilityOptions = {\n        /**\n         * Whether to enable accessibility features on initialization\n         * @default false\n         */\n        enabledByDefault: false,\n        /**\n         * Whether to visually show the accessibility divs for debugging\n         * @default false\n         */\n        debug: false,\n        /**\n         * Whether to activate accessibility when tab key is pressed\n         * @default true\n         */\n        activateOnTab: true,\n        /**\n         * Whether to deactivate accessibility when mouse moves\n         * @default true\n         */\n        deactivateOnMouseMove: true,\n    };\n\n    /** Whether accessibility divs are visible for debugging */\n    public debug = false;\n\n    /** Whether to activate on tab key press */\n    private _activateOnTab = true;\n\n    /** Whether to deactivate accessibility when mouse moves */\n    private _deactivateOnMouseMove = true;\n\n    /**\n     * The renderer this accessibility manager works for.\n     * @type {WebGLRenderer|WebGPURenderer}\n     */\n    private _renderer: Renderer;\n\n    /** Internal variable, see isActive getter. */\n    private _isActive = false;\n\n    /** Internal variable, see isMobileAccessibility getter. */\n    private _isMobileAccessibility = false;\n\n    /** Button element for handling touch hooks. */\n    private _hookDiv: HTMLElement | null;\n\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    private _div: HTMLElement | null = null;\n\n    /** A simple pool for storing divs. */\n    private _pools: Record<string, AccessibleHTMLElement[]> = {};\n\n    /** This is a tick used to check if an object is no longer being rendered. */\n    private _renderId = 0;\n\n    /** The array of currently active accessible items. */\n    private _children: Container[] = [];\n\n    /** Count to throttle div updates on android devices. */\n    private _androidUpdateCount = 0;\n\n    /**  The frequency to update the div elements. */\n    private readonly _androidUpdateFrequency = 500; // 2fps\n    private _canvasObserver: CanvasObserver;\n\n    // eslint-disable-next-line @typescript-eslint/prefer-readonly\n    private _isRunningTests: boolean = false;\n\n    /** Bound function references for proper event listener removal */\n    private _boundOnKeyDown: (e: KeyboardEvent) => void = this._onKeyDown.bind(this);\n    private _boundOnMouseMove: (e: MouseEvent) => void = this._onMouseMove.bind(this);\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer, private readonly _mobileInfo: isMobileResult = isMobile)\n    {\n        this._hookDiv = null;\n\n        if (_mobileInfo.tablet || _mobileInfo.phone)\n        {\n            this._createTouchHook();\n        }\n\n        this._renderer = renderer;\n    }\n\n    /**\n     * Value of `true` if accessibility is currently active and accessibility layers are showing.\n     * @type {boolean}\n     * @readonly\n     */\n    get isActive(): boolean\n    {\n        return this._isActive;\n    }\n\n    /**\n     * Value of `true` if accessibility is enabled for touch devices.\n     * @type {boolean}\n     * @readonly\n     */\n    get isMobileAccessibility(): boolean\n    {\n        return this._isMobileAccessibility;\n    }\n\n    /**\n     * Button element for handling touch hooks.\n     * @readonly\n     */\n    get hookDiv()\n    {\n        return this._hookDiv;\n    }\n\n    /**\n     * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n     * @readonly\n     */\n    get div()\n    {\n        return this._div;\n    }\n\n    /**\n     * Creates the touch hooks.\n     * @private\n     */\n    private _createTouchHook(): void\n    {\n        const hookDiv = document.createElement('button');\n\n        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = 'absolute';\n        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = '#FF0000';\n        hookDiv.title = 'select to enable accessibility for this content';\n\n        hookDiv.addEventListener('focus', () =>\n        {\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n\n    /**\n     * Destroys the touch hooks.\n     * @private\n     */\n    private _destroyTouchHook(): void\n    {\n        if (!this._hookDiv)\n        {\n            return;\n        }\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n\n    /**\n     * Activating will cause the Accessibility layer to be shown.\n     * This is called when a user presses the tab key.\n     * @private\n     */\n    private _activate(): void\n    {\n        if (this._isActive)\n        {\n            return;\n        }\n\n        this._isActive = true;\n\n        // Create and add div if needed\n        if (!this._div)\n        {\n            this._div = document.createElement('div');\n            this._div.style.position = 'absolute';\n            this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n            this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n            this._div.style.pointerEvents = 'none';\n            this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n\n            // Initialize the CanvasTransformSync to keep the DOM element in sync with the canvas\n            this._canvasObserver = new CanvasObserver({\n                domElement: this._div,\n                renderer: this._renderer,\n            });\n        }\n\n        // Add listeners using the stored bound references\n        if (this._activateOnTab)\n        {\n            globalThis.addEventListener('keydown', this._boundOnKeyDown, false);\n        }\n\n        if (this._deactivateOnMouseMove)\n        {\n            globalThis.document.addEventListener('mousemove', this._boundOnMouseMove, true);\n        }\n\n        // Check if canvas is in DOM\n        const canvas = this._renderer.view.canvas;\n\n        if (!canvas.parentNode)\n        {\n            const observer = new MutationObserver(() =>\n            {\n                if (canvas.parentNode)\n                {\n                    observer.disconnect();\n\n                    // Add to DOM\n                    this._canvasObserver.ensureAttached();\n                    // Only start the postrender runner after div is ready\n                    this._initAccessibilitySetup();\n                }\n            });\n\n            observer.observe(document.body, { childList: true, subtree: true });\n        }\n        else\n        {\n            // Add to DOM\n            this._canvasObserver.ensureAttached();\n            // Div is ready, initialize accessibility\n            this._initAccessibilitySetup();\n        }\n    }\n\n    // New method to handle initialization after div is ready\n    private _initAccessibilitySetup(): void\n    {\n        // Add the postrender runner to start processing accessible objects\n        this._renderer.runners.postrender.add(this);\n\n        // Force an initial update of accessible objects\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n        }\n    }\n\n    /**\n     * Deactivates the accessibility system. Removes listeners and accessibility elements.\n     * @private\n     */\n    private _deactivate(): void\n    {\n        if (!this._isActive || this._isMobileAccessibility)\n        {\n            return;\n        }\n\n        this._isActive = false;\n\n        // Switch listeners\n        globalThis.document.removeEventListener('mousemove', this._boundOnMouseMove, true);\n        if (this._activateOnTab)\n        {\n            globalThis.addEventListener('keydown', this._boundOnKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n\n        // Remove all active accessibility elements\n        for (const child of this._children)\n        {\n            if (child._accessibleDiv && child._accessibleDiv.parentNode)\n            {\n                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n                child._accessibleDiv = null;\n            }\n            child._accessibleActive = false;\n        }\n\n        // Clear the pool of divs\n        for (const accessibleType in this._pools)\n        {\n            const pool = this._pools[accessibleType];\n\n            pool.forEach((div) =>\n            {\n                if (div.parentNode)\n                {\n                    div.parentNode.removeChild(div);\n                }\n            });\n            delete this._pools[accessibleType];\n        }\n\n        // Remove parent div from DOM\n        if (this._div && this._div.parentNode)\n        {\n            this._div.parentNode.removeChild(this._div);\n        }\n\n        this._pools = {};\n        this._children = [];\n    }\n\n    /**\n     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n     * @private\n     * @param {Container} container - The Container to check.\n     */\n    private _updateAccessibleObjects(container: Container): void\n    {\n        if (!container.visible || !container.accessibleChildren)\n        {\n            return;\n        }\n\n        // Separate check for accessibility without requiring interactivity\n        if (container.accessible)\n        {\n            if (!container._accessibleActive)\n            {\n                this._addChild(container);\n            }\n\n            container._renderId = this._renderId;\n        }\n\n        const children = container.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._updateAccessibleObjects(children[i] as Container);\n            }\n        }\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options?: AccessibilitySystemOptions): void\n    {\n        // Ensure we have the accessibilityOptions object\n        const defaultOpts = AccessibilitySystem.defaultOptions;\n        const mergedOptions = {\n            accessibilityOptions: {\n                ...defaultOpts,\n                ...(options?.accessibilityOptions || {})\n            }\n        };\n\n        this.debug = mergedOptions.accessibilityOptions.debug;\n        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n\n        if (mergedOptions.accessibilityOptions.enabledByDefault)\n        {\n            this._activate();\n        }\n\n        this._renderer.runners.postrender.remove(this);\n    }\n\n    /**\n     * Updates the accessibility layer during rendering.\n     * - Removes divs for containers no longer in the scene\n     * - Updates the position and dimensions of the root div\n     * - Updates positions of active accessibility divs\n     * Only fires while the accessibility system is active.\n     * @ignore\n     */\n    public postrender(): void\n    {\n        /* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,\n        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,\n        *  so I am just running update every half a second, seems to fix it.\n        */\n        const now = performance.now();\n\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount)\n        {\n            return;\n        }\n\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n\n        if ((!this._renderer.renderingToScreen || !this._renderer.view.canvas)\n            && !this._isRunningTests)\n        {\n            return;\n        }\n\n        // Track which containers are still active this frame\n        const activeIds = new Set<number>();\n\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n\n            // Mark all updated containers as active\n            for (const child of this._children)\n            {\n                if (child._renderId === this._renderId)\n                {\n                    activeIds.add(this._children.indexOf(child));\n                }\n            }\n        }\n\n        // Remove any containers that weren't updated this frame\n        for (let i = this._children.length - 1; i >= 0; i--)\n        {\n            const child = this._children[i];\n\n            if (!activeIds.has(i))\n            {\n                // Container was removed, clean up its accessibility div\n                if (child._accessibleDiv && child._accessibleDiv.parentNode)\n                {\n                    child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n\n                    const pool = this._getPool(child.accessibleType);\n\n                    pool.push(child._accessibleDiv);\n                    child._accessibleDiv = null;\n                }\n                child._accessibleActive = false;\n                removeItems(this._children, i, 1);\n            }\n        }\n\n        // Update root div dimensions if needed\n        if (this._renderer.renderingToScreen)\n        {\n            // Ensure the main DOM element is attached to the same parent as the canvas\n            this._canvasObserver.ensureAttached();\n        }\n\n        // Update positions of existing divs\n        for (let i = 0; i < this._children.length; i++)\n        {\n            const child = this._children[i];\n\n            if (!child._accessibleActive || !child._accessibleDiv)\n            {\n                continue;\n            }\n\n            // Only update position-related properties\n            const div = child._accessibleDiv;\n            const hitArea = (child.hitArea || child.getBounds().rectangle) as Rectangle;\n\n            if (child.hitArea)\n            {\n                const wt = child.worldTransform;\n\n                div.style.left = `${(wt.tx + (hitArea.x * wt.a))}px`;\n                div.style.top = `${(wt.ty + (hitArea.y * wt.d))}px`;\n                div.style.width = `${hitArea.width * wt.a}px`;\n                div.style.height = `${hitArea.height * wt.d}px`;\n            }\n            else\n            {\n                this._capHitArea(hitArea);\n                div.style.left = `${hitArea.x}px`;\n                div.style.top = `${hitArea.y}px`;\n                div.style.width = `${hitArea.width}px`;\n                div.style.height = `${hitArea.height}px`;\n            }\n        }\n\n        // increment the render id..\n        this._renderId++;\n    }\n\n    /**\n     * private function that will visually add the information to the\n     * accessibility div\n     * @param {HTMLElement} div -\n     */\n    private _updateDebugHTML(div: AccessibleHTMLElement): void\n    {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n\n    /**\n     * Adjust the hit area based on the bounds of a display object\n     * @param {Rectangle} hitArea - Bounds of the child\n     */\n    private _capHitArea(hitArea: Rectangle): void\n    {\n        if (hitArea.x < 0)\n        {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n\n        if (hitArea.y < 0)\n        {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n\n        if (hitArea.x + hitArea.width > viewWidth)\n        {\n            hitArea.width = viewWidth - hitArea.x;\n        }\n\n        if (hitArea.y + hitArea.height > viewHeight)\n        {\n            hitArea.height = viewHeight - hitArea.y;\n        }\n    }\n\n    /**\n     * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n     * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n     * @private\n     * @param {Container} container - The child to make accessible.\n     */\n    private _addChild<T extends Container>(container: T): void\n    {\n        const pool = this._getPool(container.accessibleType);\n\n        let div = pool.pop();\n\n        if (div)\n        {\n            /*\n             * Reset these properties so we don't have outdated metadata.\n             * It was possible to end up with:\n             * - the old tabIndex if container.interactive is false\n             * - the old aria-label if container.accessibleHint is not set\n             */\n            div.innerHTML = '';\n            div.removeAttribute('title');\n            div.removeAttribute('aria-label');\n            div.tabIndex = 0;\n        }\n        else\n        {\n            if (container.accessibleType === 'button')\n            {\n                div = document.createElement('button');\n            }\n            else\n            {\n                div = document.createElement(container.accessibleType);\n                div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n                if (container.accessibleText)\n                {\n                    div.innerText = container.accessibleText;\n                }\n            }\n            div.style.width = `${DIV_TOUCH_SIZE}px`;\n            div.style.height = `${DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent';\n            div.style.position = 'absolute';\n            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = 'none';\n\n            // ARIA attributes ensure that button title and hint updates are announced properly\n            if (navigator.userAgent.toLowerCase().includes('chrome'))\n            {\n                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.\n                div.setAttribute('aria-live', 'off');\n            }\n            else\n            {\n                div.setAttribute('aria-live', 'polite');\n            }\n\n            if (navigator.userAgent.match(/rv:.*Gecko\\//))\n            {\n                // FireFox needs this to announce only the new button name\n                div.setAttribute('aria-relevant', 'additions');\n            }\n            else\n            {\n                // required by IE, other browsers don't much care\n                div.setAttribute('aria-relevant', 'text');\n            }\n\n            div.addEventListener('click', this._onClick.bind(this));\n            div.addEventListener('focus', this._onFocus.bind(this));\n            div.addEventListener('focusout', this._onFocusOut.bind(this));\n        }\n\n        // set pointer events\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        // set the type, this defaults to button!\n        div.type = container.accessibleType;\n\n        if (container.accessibleTitle && container.accessibleTitle !== null)\n        {\n            div.title = container.accessibleTitle;\n        }\n        else if (!container.accessibleHint\n            || container.accessibleHint === null)\n        {\n            div.title = `container ${container.tabIndex}`;\n        }\n\n        if (container.accessibleHint\n            && container.accessibleHint !== null)\n        {\n            div.setAttribute('aria-label', container.accessibleHint);\n        }\n\n        if (container.interactive)\n        {\n            div.tabIndex = container.tabIndex;\n        }\n        else\n        {\n            // reset tabIndex back to 0 in case this div instance was pulled from the pool and already had a value\n            div.tabIndex = 0;\n        }\n\n        if (this.debug)\n        {\n            this._updateDebugHTML(div);\n        }\n\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n    }\n\n    /**\n     * Dispatch events with the EventSystem.\n     * @param e\n     * @param type\n     * @private\n     */\n    private _dispatchEvent(e: UIEvent, type: string[]): void\n    {\n        const { container: target } = e.target as AccessibleHTMLElement;\n        const boundary = this._renderer.events.rootBoundary;\n        const event: FederatedEvent = Object.assign(new FederatedEvent(boundary), { target });\n\n        boundary.rootTarget = this._renderer.lastObjectRendered as Container;\n        type.forEach((type) => boundary.dispatchEvent(event, type));\n    }\n\n    /**\n     * Maps the div button press to pixi's EventSystem (click)\n     * @private\n     * @param {MouseEvent} e - The click event.\n     */\n    private _onClick(e: MouseEvent): void\n    {\n        this._dispatchEvent(e, ['click', 'pointertap', 'tap']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseover)\n     * @private\n     * @param {FocusEvent} e - The focus event.\n     */\n    private _onFocus(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'assertive');\n        }\n\n        this._dispatchEvent(e, ['mouseover']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseout)\n     * @private\n     * @param {FocusEvent} e - The focusout event.\n     */\n    private _onFocusOut(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'polite');\n        }\n\n        this._dispatchEvent(e, ['mouseout']);\n    }\n\n    /**\n     * Is called when a key is pressed\n     * @private\n     * @param {KeyboardEvent} e - The keydown event.\n     */\n    private _onKeyDown(e: KeyboardEvent): void\n    {\n        if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab)\n        {\n            return;\n        }\n\n        this._activate();\n    }\n\n    /**\n     * Is called when the mouse moves across the renderer element\n     * @private\n     * @param {MouseEvent} e - The mouse event.\n     */\n    private _onMouseMove(e: MouseEvent): void\n    {\n        if (e.movementX === 0 && e.movementY === 0)\n        {\n            return;\n        }\n\n        this._deactivate();\n    }\n\n    /**\n     * Destroys the accessibility system. Removes all elements and listeners.\n     * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n     * > A typically user should not need to call this method directly.\n     */\n    public destroy(): void\n    {\n        this._deactivate();\n        this._destroyTouchHook();\n\n        this._canvasObserver?.destroy();\n        this._canvasObserver = null;\n\n        this._div = null;\n        this._pools = null;\n        this._children = null;\n        this._renderer = null;\n        this._hookDiv = null;\n\n        // Remove listeners using the stored bound references\n        globalThis.removeEventListener('keydown', this._boundOnKeyDown);\n        this._boundOnKeyDown = null;\n        globalThis.document.removeEventListener('mousemove', this._boundOnMouseMove, true);\n        this._boundOnMouseMove = null;\n    }\n\n    /**\n     * Enables or disables the accessibility system.\n     * @param enabled - Whether to enable or disable accessibility.\n     * @example\n     * ```js\n     * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n     * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n     * ```\n     */\n    public setAccessibilityEnabled(enabled: boolean): void\n    {\n        if (enabled)\n        {\n            this._activate();\n        }\n        else\n        {\n            this._deactivate();\n        }\n    }\n\n    private _getPool(accessibleType: string): AccessibleHTMLElement[]\n    {\n        if (!this._pools[accessibleType])\n        {\n            this._pools[accessibleType] = [];\n        }\n\n        return this._pools[accessibleType];\n    }\n}\n", "import type { Container } from '../scene/container/Container';\n\n/**\n * The type of the pointer event to listen for.\n * @category accessibility\n * @standard\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = 'auto'\n| 'none'\n| 'visiblePainted'\n| 'visibleFill'\n| 'visibleStroke'\n| 'visible'\n| 'painted'\n| 'fill'\n| 'stroke'\n| 'all'\n| 'inherit';\n\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @example\n * const container = new Container();\n * container.accessible = true;\n * container.accessibleTitle = 'My Container';\n * container.accessibleHint = 'This is a container';\n * container.tabIndex = 0;\n * @category accessibility\n * @standard\n */\nexport interface AccessibleOptions\n{\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @default false\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * ```\n     */\n    accessible: boolean;\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @type {string}\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleTitle = 'My Container';\n     * ```\n     */\n    accessibleTitle: string | null;\n    /**\n     * Sets the aria-label attribute of the shadow div\n     * @default null\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleHint = 'This is a container';\n     * ```\n     */\n    accessibleHint: string | null;\n    /**\n     * Sets the tabIndex of the shadow div. You can use this to set the order of the\n     * elements when using the tab key to navigate.\n     * @default 0\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.tabIndex = 0;\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true;\n     * sprite.tabIndex = 1;\n     * ```\n     */\n    tabIndex: number;\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @default 'button'\n     * @type {string}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleType = 'button'; // or 'link', 'checkbox', etc.\n     * ```\n     */\n    accessibleType: keyof HTMLElementTagNameMap;\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @default 'auto'\n     * @type {PointerEvents}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessiblePointerEvents = 'none'; // or 'auto', 'visiblePainted', etc.\n     * ```\n     */\n    accessiblePointerEvents: PointerEvents;\n\n    /**\n     * Sets the text content of the shadow\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleText = 'This is a container';\n     * ```\n     */\n    accessibleText: string | null;\n\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @default true\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleChildren = false; // This will prevent any children from being accessible\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true; // This will not work since accessibleChildren is false\n     * ```\n     */\n    accessibleChildren: boolean;\n}\n\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions\n{\n    /** @private */\n    _accessibleActive: boolean;\n    /** @private */\n    _accessibleDiv: AccessibleHTMLElement | null;\n    /** @private */\n    _renderId: number;\n}\n\n/** @internal */\nexport interface AccessibleHTMLElement extends HTMLElement\n{\n    type?: string;\n    container?: Container;\n}\n\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @internal\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget = {\n    accessible: false,\n    accessibleTitle: null,\n    accessibleHint: null,\n    tabIndex: 0,\n    accessibleType: 'button',\n    accessibleText: null,\n    accessiblePointerEvents: 'auto',\n    accessibleChildren: true,\n    _accessibleActive: false,\n    _accessibleDiv: null,\n    _renderId: -1,\n};\n", "import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { AccessibilitySystem } from './AccessibilitySystem';\nimport { accessibilityTarget } from './accessibilityTarget';\n\nextensions.add(AccessibilitySystem);\nextensions.mixin(Container, accessibilityTarget);\n", "import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * ```ts\n * // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n * ```\n * @category app\n * @standard\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     resizeTo: window, // Resize to the entire window\n     *     // or\n     *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n     *     // or\n     *     resizeTo: null, // Disable auto-resize\n     * });\n     * ```\n     * @default null\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * ```ts\n * import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n * ```\n * @category app\n * @standard\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    /** @internal */\n    public static resizeTo: Window | HTMLElement;\n    /** @internal */\n    public static resize: () => void;\n    /** @internal */\n    public static renderer: ResizeableRenderer;\n    /** @internal */\n    public static queueResize: () => void;\n    /** @internal */\n    public static render: () => void;\n    /** @internal */\n    private static _resizeId: number;\n    /** @internal */\n    private static _resizeTo: Window | HTMLElement;\n    /** @internal */\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n * ```\n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For update priority constants\n * @category app\n * @standard\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Controls whether the animation loop starts automatically after initialization.\n     * > [!IMPORTANT]\n     * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n     * > You must stop the shared ticker manually if needed.\n     * @example\n     * ```ts\n     * // Auto-start (default behavior)\n     * await app.init({ autoStart: true });\n     *\n     * // Manual start\n     * await app.init({ autoStart: false });\n     * app.start(); // Start when ready\n     * ```\n     * @default true\n     */\n    autoStart?: boolean;\n\n    /**\n     * Controls whether to use the shared global ticker or create a new instance.\n     *\n     * The shared ticker is useful when you have multiple instances that should sync their updates.\n     * However, it has some limitations regarding update order control.\n     *\n     * Update Order:\n     * 1. System ticker (always runs first)\n     * 2. Shared ticker (if enabled)\n     * 3. App ticker (if using own ticker)\n     * @example\n     * ```ts\n     * // Use shared ticker (global instance)\n     * await app.init({ sharedTicker: true });\n     *\n     * // Use dedicated ticker (default)\n     * await app.init({ sharedTicker: false });\n     *\n     * // Access ticker properties\n     * console.log(app.ticker.FPS);    // Current FPS\n     * console.log(app.ticker.deltaMS); // MS since last update\n     * ```\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * ```ts\n * import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n * ```\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @category app\n * @standard\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    /** @internal */\n    public static start: () => void;\n    /** @internal */\n    public static stop: () => void;\n    /** @internal */\n    private static _ticker: Ticker;\n    /** @internal */\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n", "import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n", "import { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { EventSystem } from './EventSystem';\n\n/** @advanced */\nclass EventsTickerClass\n{\n    /** The event system. */\n    public events: EventSystem;\n    /** The DOM element to listen to events on. */\n    public domElement: HTMLElement;\n    /** The frequency that fake events will be fired. */\n    public interactionFrequency = 10;\n\n    private _deltaTime = 0;\n    private _didMove = false;\n    private _tickerAdded = false;\n    private _pauseUpdate = true;\n\n    /**\n     * Initializes the event ticker.\n     * @param events - The event system.\n     */\n    public init(events: EventSystem): void\n    {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n\n    /** Whether to pause the update checks or not. */\n    get pauseUpdate(): boolean\n    {\n        return this._pauseUpdate;\n    }\n\n    set pauseUpdate(paused: boolean)\n    {\n        this._pauseUpdate = paused;\n    }\n\n    /** Adds the ticker listener. */\n    public addTickerListener(): void\n    {\n        if (this._tickerAdded || !this.domElement)\n        {\n            return;\n        }\n\n        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this._tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    public removeTickerListener(): void\n    {\n        if (!this._tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this._tickerUpdate, this);\n\n        this._tickerAdded = false;\n    }\n\n    /** Sets flag to not fire extra events when the user has already moved there mouse */\n    public pointerMoved(): void\n    {\n        this._didMove = true;\n    }\n\n    /** Updates the state of interactive objects. */\n    private _update(): void\n    {\n        if (!this.domElement || this._pauseUpdate)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        // eslint-disable-next-line dot-notation\n        const rootPointerEvent = this.events['_rootPointerEvent'];\n\n        if (this.events.supportsTouchEvents && (rootPointerEvent as PointerEvent).pointerType === 'touch')\n        {\n            return;\n        }\n\n        globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent('pointermove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId,\n        }) : new MouseEvent('mousemove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n        }));\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link Ticker.system}.\n     * @param ticker - The throttled ticker.\n     */\n    private _tickerUpdate(ticker: Ticker): void\n    {\n        this._deltaTime += ticker.deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this._update();\n    }\n\n    /** Destroys the event ticker. */\n    public destroy(): void\n    {\n        this.removeTickerListener();\n        this.events = null;\n        this.domElement = null;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n}\n\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @category events\n * @class\n * @advanced\n */\nexport const EventsTicker = new EventsTickerClass();\n", "import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\n\n/**\n * A specialized event class for mouse interactions in PixiJS applications.\n * Extends {@link FederatedEvent} to provide mouse-specific properties and methods\n * while maintaining compatibility with the DOM MouseEvent interface.\n *\n * Key features:\n * - Tracks mouse button states\n * - Provides modifier key states\n * - Supports coordinate systems (client, screen, global)\n * - Enables precise position tracking\n * @example\n * ```ts\n * // Basic mouse event handling\n * sprite.on('mousemove', (event: FederatedMouseEvent) => {\n *     // Get coordinates in different spaces\n *     console.log('Global position:', event.global.x, event.global.y);\n *     console.log('Client position:', event.client.x, event.client.y);\n *     console.log('Screen position:', event.screen.x, event.screen.y);\n *\n *     // Check button and modifier states\n *     if (event.buttons === 1 && event.ctrlKey) {\n *         console.log('Left click + Control key');\n *     }\n *\n *     // Get local coordinates relative to any container\n *     const localPos = event.getLocalPosition(container);\n *     console.log('Local position:', localPos.x, localPos.y);\n * });\n *\n * // Handle mouse button states\n * sprite.on('mousedown', (event: FederatedMouseEvent) => {\n *     console.log('Mouse button:', event.button); // 0=left, 1=middle, 2=right\n *     console.log('Active buttons:', event.buttons);\n * });\n * ```\n * @category events\n * @see {@link FederatedEvent} For base event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} DOM MouseEvent Interface\n * @standard\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    public altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    public button: number;\n\n    /** The button depressed when this event occurred. */\n    public buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    public ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    public metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    public relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    public shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * Converts global coordinates into container-local coordinates.\n     *\n     * This method transforms coordinates from world space to a container's local space,\n     * useful for precise positioning and hit testing.\n     * @param container - The Container to get local coordinates for\n     * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n     * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n     * @returns The local coordinates as a Point object\n     * @example\n     * ```ts\n     * // Basic usage - get local coordinates relative to a container\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Get position relative to the sprite\n     *     const localPos = event.getLocalPosition(sprite);\n     *     console.log('Local position:', localPos.x, localPos.y);\n     * });\n     * // Using custom global coordinates\n     * const customGlobal = new Point(100, 100);\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Transform custom coordinates\n     *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n     *     console.log('Custom local position:', localPos.x, localPos.y);\n     * });\n     * ```\n     * @see {@link Container.worldTransform} For the transformation matrix\n     * @see {@link Point} For the point class used to store coordinates\n     */\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for pointer interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide advanced pointer-specific features\n * while maintaining compatibility with the DOM PointerEvent interface.\n *\n * Key features:\n * - Supports multi-touch interactions\n * - Provides pressure sensitivity\n * - Handles stylus input\n * - Tracks pointer dimensions\n * - Supports tilt detection\n * @example\n * ```ts\n * // Basic pointer event handling\n * sprite.on('pointerdown', (event: FederatedPointerEvent) => {\n *     // Access pointer information\n *     console.log('Pointer ID:', event.pointerId);\n *     console.log('Pointer Type:', event.pointerType);\n *     console.log('Is Primary:', event.isPrimary);\n *\n *     // Get pressure and tilt data\n *     console.log('Pressure:', event.pressure);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n *\n *     // Access contact geometry\n *     console.log('Size:', event.width, event.height);\n * });\n *\n * // Handle stylus-specific features\n * sprite.on('pointermove', (event: FederatedPointerEvent) => {\n *     if (event.pointerType === 'pen') {\n *         // Handle stylus tilt\n *         const tiltAngle = Math.atan2(event.tiltY, event.tiltX);\n *         console.log('Tilt angle:', tiltAngle);\n *\n *         // Use barrel button pressure\n *         console.log('Tangential pressure:', event.tangentialPressure);\n *     }\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent} DOM PointerEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring the vertical angle between\n     * the device's surface to the pointer or stylus.\n     * A stylus at 0 degrees would be directly parallel whereas at π/2 degrees it would be perpendicular.\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/altitudeAngle)\n     */\n    public altitudeAngle: number;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring an arc from the X axis of the device to\n     * the pointer or stylus projected onto the screen's plane.\n     * A stylus at 0 degrees would be pointing to the \"0 o'clock\" whereas at π/2 degrees it would be pointing at \"6 o'clock\".\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/azimuthAngle)\n     */\n    public azimuthAngle: number;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for wheel/scroll interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide wheel-specific properties while\n * maintaining compatibility with the DOM WheelEvent interface.\n *\n * Key features:\n * - Provides scroll delta information\n * - Supports different scroll modes (pixel, line, page)\n * - Inherits mouse event properties\n * - Normalizes cross-browser wheel events\n * @example\n * ```ts\n * // Basic wheel event handling\n * sprite.on('wheel', (event: FederatedWheelEvent) => {\n *     // Get scroll amount\n *     console.log('Vertical scroll:', event.deltaY);\n *     console.log('Horizontal scroll:', event.deltaX);\n *\n *     // Check scroll mode\n *     if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_LINE) {\n *         console.log('Scrolling by lines');\n *     } else if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_PAGE) {\n *         console.log('Scrolling by pages');\n *     } else {\n *         console.log('Scrolling by pixels');\n *     }\n *\n *     // Get scroll position\n *     console.log('Scroll at:', event.global.x, event.global.y);\n * });\n *\n * // Common use case: Zoom control\n * container.on('wheel', (event: FederatedWheelEvent) => {\n *     // Prevent page scrolling\n *     event.preventDefault();\n *\n *     // Zoom in/out based on scroll direction\n *     const zoomFactor = 1 + (event.deltaY / 1000);\n *     container.scale.set(container.scale.x * zoomFactor);\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent} DOM WheelEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    public deltaMode: number;\n\n    /** Horizontal scroll amount */\n    public deltaX: number;\n\n    /** Vertical scroll amount */\n    public deltaY: number;\n\n    /** z-axis scroll amount. */\n    public deltaZ: number;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PAGE = 2;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PAGE = 2;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @category events\n * @advanced\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | (string & {});\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: Container[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: Container[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target `e.target`.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * `target`. The last element in the path is `target`.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: Container): Container[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable || !container.measurable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._maskEffect} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        if (!e.currentTarget.isInteractive())\n        {\n            return;\n        }\n\n        type ??= e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof Container;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: Container[]): Container\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The `originalEvent` for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: Container\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as Container\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose `originalEvent` is `from`.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event `from`, with an optional `type` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     * @returns An event of the given type.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.defaultPrevented = false;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/**\n * Options for configuring the PixiJS event system. These options control how the event system\n * handles different types of interactions and event propagation.\n * @example\n * ```ts\n * // Basic event system configuration\n * const app = new Application();\n * await app.init({\n *     // Configure default interaction mode\n *     eventMode: 'static',\n *\n *     // Configure event features\n *     eventFeatures: {\n *         move: true,           // Enable pointer movement events\n *         globalMove: false,    // Disable global move events\n *         click: true,          // Enable click events\n *         wheel: true          // Enable wheel/scroll events\n *     }\n * });\n *\n * // Access event system after initialization\n * const eventSystem = app.renderer.events;\n * console.log(eventSystem.features); // Check enabled features\n * ```\n * @see {@link EventSystem} For the main event system implementation\n * @see {@link EventMode} For interaction mode details\n * @see {@link EventSystemFeatures} For all available feature options\n * @advanced\n * @category events\n */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode for all display objects.\n     * Controls how objects respond to interaction events.\n     *\n     * Possible values:\n     * - `'none'`: No interaction events\n     * - `'passive'`: Only container's children receive events (default)\n     * - `'auto'`: Receives events when parent is interactive\n     * - `'static'`: Standard interaction events\n     * - `'dynamic'`: Like static but with additional synthetic events\n     * @default 'passive'\n     */\n    eventMode?: EventMode;\n\n    /**\n     * Configuration for enabling/disabling specific event features.\n     * Use this to optimize performance by turning off unused functionality.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     eventFeatures: {\n     *         // Core interaction events\n     *         move: true,        // Pointer/mouse/touch movement\n     *         click: true,       // Click/tap events\n     *         wheel: true,       // Mouse wheel/scroll events\n     *         // Global tracking\n     *         globalMove: false  // Global pointer movement\n     *     }\n     * });\n     * ```\n     */\n    eventFeatures?: Partial<EventSystemFeatures>;\n}\n\n/**\n * The event features that are enabled by the EventSystem. These features control\n * different types of interaction events in your PixiJS application.\n * @example\n * ```ts\n * // Configure features during application initialization\n * const app = new Application();\n * await app.init({\n *     eventFeatures: {\n *         // Basic interaction events\n *         move: true,        // Enable pointer movement tracking\n *         click: true,       // Enable click/tap events\n *         wheel: true,       // Enable mouse wheel/scroll events\n *         // Advanced features\n *         globalMove: false  // Disable global move tracking for performance\n *     }\n * });\n *\n * // Or configure after initialization\n * app.renderer.events.features.move = false;      // Disable movement events\n * app.renderer.events.features.globalMove = true; // Enable global tracking\n * ```\n * @since 7.2.0\n * @category events\n * @advanced\n */\nexport interface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement.\n     *\n     * When enabled, these events will fire:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     * @example\n     * ```ts\n     * // Enable movement events\n     * app.renderer.events.features.move = true;\n     *\n     * // Listen for movement\n     * sprite.on('pointermove', (event) => {\n     *     console.log('Pointer position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    move: boolean;\n\n    /**\n     * Enables global pointer move events that fire regardless of target.\n     *\n     * When enabled, these events will fire:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchmove`\n     * @example\n     * ```ts\n     * // Enable global tracking\n     * app.renderer.events.features.globalMove = true;\n     *\n     * // Track pointer globally\n     * sprite.on('globalpointermove', (event) => {\n     *     // Fires even when pointer is not over sprite\n     *     console.log('Global position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking/tapping.\n     *\n     * When enabled, these events will fire:\n     * - `pointerdown` / `mousedown` / `touchstart` / `rightdown`\n     * - `pointerup` / `mouseup` / `touchend` / `rightup`\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / `rightupoutside`\n     * - `click` / `tap`\n     * @example\n     * ```ts\n     * // Enable click events\n     * app.renderer.events.features.click = true;\n     *\n     * // Handle clicks\n     * sprite.on('click', (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    click: boolean;\n    /**\n     * Enables mouse wheel/scroll events.\n     * @example\n     * ```ts\n     * // Enable wheel events\n     * app.renderer.events.features.wheel = true;\n     *\n     * // Handle scrolling\n     * sprite.on('wheel', (event) => {\n     *     // Zoom based on scroll direction\n     *     const scale = 1 + (event.deltaY / 1000);\n     *     sprite.scale.set(sprite.scale.x * scale);\n     * });\n     * ```\n     * @default true\n     */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events in PixiJS applications. This class manages mouse, touch, and pointer events,\n * normalizing them into a consistent event model.\n * @example\n * ```ts\n * // Access event system through renderer\n * const eventSystem = app.renderer.events;\n *\n * // Configure event features\n * eventSystem.features.globalMove = false;  // Disable global move events\n * eventSystem.features.click = true;        // Enable click events\n *\n * // Set custom cursor styles\n * eventSystem.cursorStyles.default = 'pointer';\n * eventSystem.cursorStyles.grab = 'grab';\n *\n * // Get current pointer position\n * const pointer = eventSystem.pointer;\n * console.log(pointer.global.x, pointer.global.y);\n * ```\n *\n * Features:\n * - Normalizes browser events into consistent format\n * - Supports mouse, touch, and pointer events\n * - Handles event delegation and bubbling\n * - Provides cursor management\n * - Configurable event features\n * @see {@link EventBoundary} For event propagation and handling\n * @see {@link FederatedEvent} For the base event class\n * @see {@link EventMode} For interaction modes\n * @category events\n * @standard\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * ```ts\n     * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n     * // Access the default event features\n     * EventSystem.defaultEventFeatures = {\n     *     // Enable pointer movement events\n     *     move: true,\n     *     // Enable global pointer move events\n     *     globalMove: true,\n     *     // Enable click events\n     *     click: true,\n     *     // Enable wheel events\n     *     wheel: true,\n     * };\n     * ```\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     * @advanced\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default 'ontouchstart' in globalThis\n     */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Controls whether default browser actions are automatically prevented on pointer events.\n     * When true, prevents default browser actions from occurring on pointer events.\n     * @remarks\n     * - Does not apply to pointer events for backwards compatibility\n     * - preventDefault on pointer events stops mouse events from firing\n     * - For every pointer event, there will always be either a mouse or touch event alongside it\n     * - Setting this to false allows default browser actions (text selection, dragging images, etc.)\n     * @example\n     * ```ts\n     * // Allow default browser actions\n     * app.renderer.events.autoPreventDefault = false;\n     *\n     * // Block default actions (default)\n     * app.renderer.events.autoPreventDefault = true;\n     *\n     * // Example with text selection\n     * const text = new Text('Selectable text');\n     * text.eventMode = 'static';\n     * app.renderer.events.autoPreventDefault = false; // Allow text selection\n     * ```\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of custom cursor styles that can be used across the application.\n     * Used to define how different cursor modes are handled when interacting with display objects.\n     * @example\n     * ```ts\n     * // Access event system through renderer\n     * const eventSystem = app.renderer.events;\n     *\n     * // Set string-based cursor styles\n     * eventSystem.cursorStyles.default = 'pointer';\n     * eventSystem.cursorStyles.hover = 'grab';\n     * eventSystem.cursorStyles.drag = 'grabbing';\n     *\n     * // Use CSS object for complex styling\n     * eventSystem.cursorStyles.custom = {\n     *     cursor: 'url(\"custom.png\") 2 2, auto',\n     *     userSelect: 'none'\n     * };\n     *\n     * // Use a url for custom cursors\n     * const defaultIcon = 'url(\\'https://pixijs.com/assets/bunny.png\\'),auto';\n     * eventSystem.cursorStyles.icon = defaultIcon;\n     *\n     * // Use callback function for dynamic cursors\n     * eventSystem.cursorStyles.dynamic = (mode) => {\n     *     // Update cursor based on mode\n     *     document.body.style.cursor = mode === 'hover'\n     *         ? 'pointer'\n     *         : 'default';\n     * };\n     *\n     * // Apply cursor style to a sprite\n     * sprite.cursor = 'hover'; // Will use the hover style defined above\n     * sprite.cursor = 'icon'; // Will apply the icon cursor\n     * sprite.cursor = 'custom'; // Will apply the custom CSS styles\n     * sprite.cursor = 'drag'; // Will apply the grabbing cursor\n     * sprite.cursor = 'default'; // Will apply the default pointer cursor\n     * sprite.cursor = 'dynamic'; // Will call the dynamic function\n     * ```\n     * @remarks\n     * - Strings are treated as CSS cursor values\n     * - Objects are applied as CSS styles to the DOM element\n     * - Functions are called directly for custom cursor handling\n     * - Default styles for 'default' and 'pointer' are provided\n     * @default\n     * ```ts\n     * {\n     *     default: 'inherit',\n     *     pointer: 'pointer' // Default cursor styles\n     * }\n     * ```\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        EventsTicker.destroy();\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n     * @param mode - Cursor mode to set. Can be:\n     * - A CSS cursor string (e.g., 'pointer', 'grab')\n     * - A key from the cursorStyles dictionary\n     * - null/undefined to reset to default\n     * @example\n     * ```ts\n     * // Using predefined cursor styles\n     * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n     * app.renderer.events.setCursor('grab');       // Set grab cursor\n     * app.renderer.events.setCursor(null);         // Reset to default\n     *\n     * // Using custom cursor styles\n     * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n     * app.renderer.events.setCursor('custom');     // Apply custom cursor\n     *\n     * // Using callback-based cursor\n     * app.renderer.events.cursorStyles.dynamic = (mode) => {\n     *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n     * };\n     * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n     * ```\n     * @remarks\n     * - Has no effect on OffscreenCanvas except for callback-based cursors\n     * - Caches current cursor to avoid unnecessary DOM updates\n     * - Supports CSS cursor values, style objects, and callback functions\n     * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n     */\n    public setCursor(mode: string): void\n    {\n        mode ||= 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event instance containing the most recent pointer state.\n     * This is useful for accessing pointer information without listening to events.\n     * @example\n     * ```ts\n     * // Access current pointer position at any time\n     * const eventSystem = app.renderer.events;\n     * const pointer = eventSystem.pointer;\n     *\n     * // Get global coordinates\n     * console.log('Position:', pointer.global.x, pointer.global.y);\n     *\n     * // Check button state\n     * console.log('Buttons pressed:', pointer.buttons);\n     *\n     * // Get pointer type and pressure\n     * console.log('Type:', pointer.pointerType);\n     * console.log('Pressure:', pointer.pressure);\n     * ```\n     * @readonly\n     * @since 7.2.0\n     * @see {@link FederatedPointerEvent} For all available pointer properties\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     * This method manages the DOM event bindings for the event system, allowing you to\n     * change or remove the target element that receives input events.\n     * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n     * > should not need to call this unless you are using a custom element.\n     * @param element - The new DOM element to bind events to, or null to remove all event bindings\n     * @example\n     * ```ts\n     * // Set a new canvas element as the target\n     * const canvas = document.createElement('canvas');\n     * app.renderer.events.setTargetElement(canvas);\n     *\n     * // Remove all event bindings\n     * app.renderer.events.setTargetElement(null);\n     *\n     * // Switch to a different canvas\n     * const newCanvas = document.querySelector('#game-canvas');\n     * app.renderer.events.setTargetElement(newCanvas);\n     * ```\n     * @remarks\n     * - Automatically removes event listeners from previous element\n     * - Required for the event system to function\n     * - Safe to call multiple times\n     * @see {@link EventSystem#domElement} The current DOM element\n     * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n     * This takes into account the current scale, position, and resolution of the DOM element.\n     * @param point - The point to store the mapped coordinates in\n     * @param x - The x coordinate in DOM/client space\n     * @param y - The y coordinate in DOM/client space\n     * @example\n     * ```ts\n     * // Map mouse coordinates to PixiJS space\n     * const point = new Point();\n     * app.renderer.events.mapPositionToPoint(\n     *     point,\n     *     event.clientX,\n     *     event.clientY\n     * );\n     * console.log('Mapped position:', point.x, point.y);\n     *\n     * // Using with pointer events\n     * sprite.on('pointermove', (event) => {\n     *     // event.global already contains mapped coordinates\n     *     console.log('Global:', event.global.x, event.global.y);\n     *\n     *     // Map to local coordinates\n     *     const local = event.getLocalPosition(sprite);\n     *     console.log('Local:', local.x, local.y);\n     * });\n     * ```\n     * @remarks\n     * - Accounts for element scaling and positioning\n     * - Adjusts for device pixel ratio/resolution\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n", "import { EventSystem } from './EventSystem';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { Container } from '../scene/container/Container';\nimport type { AllFederatedEventMap } from './FederatedEventMap';\nimport type { FederatedPointerEvent } from './FederatedPointerEvent';\nimport type { FederatedWheelEvent } from './FederatedWheelEvent';\n\n/**\n * The type of cursor to use when the mouse pointer is hovering over an interactive element.\n * Accepts any valid CSS cursor value.\n * @example\n * ```ts\n * // Basic cursor types\n * sprite.cursor = 'pointer';    // Hand cursor for clickable elements\n * sprite.cursor = 'grab';       // Grab cursor for draggable elements\n * sprite.cursor = 'crosshair';  // Precise cursor for selection\n *\n * // Direction cursors\n * sprite.cursor = 'n-resize';   // North resize\n * sprite.cursor = 'ew-resize';  // East-west resize\n * sprite.cursor = 'nesw-resize';// Northeast-southwest resize\n *\n * // Custom cursor with fallback\n * sprite.cursor = 'url(\"custom.png\"), auto';\n * ```\n *\n * Common cursor values:\n * - Basic: `auto`, `default`, `none`, `pointer`, `wait`\n * - Text: `text`, `vertical-text`\n * - Links: `alias`, `copy`, `move`\n * - Selection: `cell`, `crosshair`\n * - Drag: `grab`, `grabbing`\n * - Disabled: `not-allowed`, `no-drop`\n * - Resize: `n-resize`, `e-resize`, `s-resize`, `w-resize`\n * - Bidirectional: `ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`\n * - Other: `help`, `progress`\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n * @category events\n * @standard\n */\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n/**\n * Interface defining a hit area for pointer interaction. The hit area specifies\n * the region in which pointer events should be captured by a display object.\n * @example\n * ```ts\n * // Create a rectangular hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Create a circular hit area\n * sprite.hitArea = new Circle(50, 50, 50);\n *\n * // Custom hit area implementation\n * sprite.hitArea = {\n *     contains(x: number, y: number) {\n *         // Custom hit testing logic\n *         return x >= 0 && x <= 100 && y >= 0 && y <= 100;\n *     }\n * };\n * ```\n * @remarks\n * - Hit areas override the default bounds-based hit testing\n * - Can improve performance by simplifying hit tests\n * - Useful for irregular shapes or precise interaction areas\n * - Common implementations include Rectangle, Circle, Polygon\n * @see {@link Container.eventMode} For enabling interactivity\n * @see {@link Container.interactive} For backwards compatibility\n * @category events\n * @standard\n */\nexport interface IHitArea\n{\n    /**\n     * Checks if the given coordinates are inside this hit area.\n     * @param {number} x - The x coordinate to check\n     * @param {number} y - The y coordinate to check\n     * @returns True if the coordinates are inside the hit area\n     */\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Function type for handlers, e.g., onclick\n * @category events\n * @advanced\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n\n/**\n * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n * @example\n * ```ts\n * // Basic event mode setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';    // Enable standard interaction\n * sprite.on('pointerdown', () => { console.log('clicked!'); });\n *\n * // Different event modes\n * sprite.eventMode = 'none';      // Disable all interaction\n * sprite.eventMode = 'passive';   // Only allow interaction on children\n * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n * sprite.eventMode = 'dynamic';   // For moving/animated objects\n * ```\n *\n * Available modes:\n * - `'none'`: Ignores all interaction events, even on its children\n * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n * a ticker to allow for interaction when the mouse isn't moving\n *\n * Performance tips:\n * - Use `'none'` for pure visual elements\n * - Use `'passive'` for containers with some interactive children\n * - Use `'static'` for standard buttons/controls\n * - Use `'dynamic'` only for moving/animated interactive elements\n * @since 7.2.0\n * @category events\n * @standard\n */\nexport type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic';\n\n/**\n * The properties available for any interactive object. This interface defines the core interaction\n * properties and event handlers that can be set on any Container in PixiJS.\n * @example\n * ```ts\n * // Basic interactive setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';\n * sprite.cursor = 'pointer';\n *\n * // Using event handlers\n * sprite.on('click', (event) => console.log('Sprite clicked!', event));\n * sprite.on('pointerdown', (event) => console.log('Pointer down!', event));\n *\n * // Using property-based event handlers\n * sprite.onclick = (event) => console.log('Clicked!');\n * sprite.onpointerenter = () => sprite.alpha = 0.7;\n * sprite.onpointerleave = () => sprite.alpha = 1.0;\n *\n * // Custom hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n * ```\n *\n * Core Properties:\n * - `eventMode`: Controls how the object handles interaction events\n * - `cursor`: Sets the mouse cursor when hovering\n * - `hitArea`: Defines custom hit testing area\n * - `interactive`: Alias for `eventMode` to enable interaction with \"static\" or \"passive\" modes\n * - `interactiveChildren`: Controls hit testing on children\n *\n * Event Handlers:\n * - Mouse: click, mousedown, mouseup, mousemove, mouseenter, mouseleave\n * - Touch: touchstart, touchend, touchmove, tap\n * - Pointer: pointerdown, pointerup, pointermove, pointerover\n * - Global: globalpointermove, globalmousemove, globaltouchmove\n * > [!IMPORTANT] Global events are fired when the pointer moves even if it is outside the bounds of the Container.\n * @see {@link EventMode} For interaction mode details\n * @see {@link Cursor} For cursor style options\n * @see {@link IHitArea} For hit area implementation\n * @category events\n * @standard\n */\nexport interface FederatedOptions\n{\n    /**\n     * The cursor style to display when the mouse pointer is hovering over the object.\n     * Accepts any valid CSS cursor value or custom cursor URL.\n     * @example\n     * ```ts\n     * // Common cursor types\n     * sprite.cursor = 'pointer';     // Hand cursor for clickable elements\n     * sprite.cursor = 'grab';        // Grab cursor for draggable elements\n     * sprite.cursor = 'crosshair';   // Precise cursor for selection\n     * sprite.cursor = 'not-allowed'; // Indicate disabled state\n     *\n     * // Direction cursors\n     * sprite.cursor = 'n-resize';    // North resize\n     * sprite.cursor = 'ew-resize';   // East-west resize\n     * sprite.cursor = 'nesw-resize'; // Northeast-southwest resize\n     *\n     * // Custom cursor with fallback\n     * sprite.cursor = 'url(\"custom.png\"), auto';\n     * sprite.cursor = 'url(\"cursor.cur\") 2 2, pointer'; // With hotspot offset\n     * ```\n     * @type {Cursor | string}\n     * @default undefined\n     * @see {@link EventSystem.cursorStyles} For setting global cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n     */\n    cursor?: Cursor | (string & {});\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse events are supported.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     *\n     * // Enable standard interaction (like buttons)\n     * sprite.eventMode = 'static';\n     * sprite.on('pointerdown', () => console.log('clicked!'));\n     *\n     * // Enable for moving objects\n     * sprite.eventMode = 'dynamic';\n     * sprite.on('pointermove', () => updatePosition());\n     *\n     * // Disable all interaction\n     * sprite.eventMode = 'none';\n     *\n     * // Only allow child interactions\n     * sprite.eventMode = 'passive';\n     * ```\n     *\n     * Available modes:\n     *\n     * - `'none'`: Ignores all interaction events, even on its children. Best for pure visuals.\n     * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive\n     * children. Interactive children will still emit events.\n     * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7.\n     * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7. Best for buttons/UI.\n     * - `'dynamic'`: Like static but also receives synthetic events when pointer is idle. Best for moving objects.\n     *\n     * Performance tips:\n     * - Use `'none'` for pure visual elements\n     * - Use `'passive'` for containers with some interactive children\n     * - Use `'static'` for standard UI elements\n     * - Use `'dynamic'` only when needed for moving/animated elements\n     * @since 7.2.0\n     */\n    eventMode?: EventMode;\n    /**\n     * Whether this object should fire UI events. This is an alias for `eventMode` set to `'static'` or `'passive'`.\n     * Setting this to true will enable interaction events like `pointerdown`, `click`, etc.\n     * Setting it to false will disable all interaction events on this object.\n     * @see {@link Container.eventMode}\n     * @example\n     * ```ts\n     * // Enable interaction events\n     * sprite.interactive = true;  // Sets eventMode = 'static'\n     * sprite.interactive = false; // Sets eventMode = 'passive'\n     * ```\n     */\n    interactive?: boolean\n    /**\n     * Controls whether children of this container can receive pointer events.\n     *\n     * Setting this to false allows PixiJS to skip hit testing on all children,\n     * improving performance for containers with many non-interactive children.\n     * @default true\n     * @example\n     * ```ts\n     * // Container with many visual-only children\n     * const container = new Container();\n     * container.interactiveChildren = false; // Skip hit testing children\n     *\n     * // Menu with interactive buttons\n     * const menu = new Container();\n     * menu.interactiveChildren = true; // Test all children\n     * menu.addChild(button1, button2, button3);\n     *\n     * // Performance optimization\n     * background.interactiveChildren = false;\n     * foreground.interactiveChildren = true;\n     * ```\n     */\n    interactiveChildren?: boolean;\n    /**\n     * Defines a custom hit area for pointer interaction testing. When set, this shape will be used\n     * for hit testing instead of the container's standard bounds.\n     * @example\n     * ```ts\n     * import { Rectangle, Circle, Sprite } from 'pixi.js';\n     *\n     * // Rectangular hit area\n     * const button = new Sprite(texture);\n     * button.eventMode = 'static';\n     * button.hitArea = new Rectangle(0, 0, 100, 50);\n     *\n     * // Circular hit area\n     * const icon = new Sprite(texture);\n     * icon.eventMode = 'static';\n     * icon.hitArea = new Circle(32, 32, 32);\n     *\n     * // Custom hit area with polygon\n     * const custom = new Sprite(texture);\n     * custom.eventMode = 'static';\n     * custom.hitArea = new Polygon([0,0, 100,0, 100,100, 0,100]);\n     *\n     * // Custom hit testing logic\n     * sprite.hitArea = {\n     *     contains(x: number, y: number) {\n     *         // Custom collision detection\n     *         return x >= 0 && x <= width && y >= 0 && y <= height;\n     *     }\n     * };\n     * ```\n     * @remarks\n     * - Takes precedence over the container's bounds for hit testing\n     * - Can improve performance by simplifying collision checks\n     * - Useful for irregular shapes or precise click areas\n     */\n    hitArea?: IHitArea | null;\n\n    /**\n     * Property-based event handler for the `click` event.\n     * Fired when a pointer device (mouse, touch, etc.) completes a click action.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('click', (event) => {\n     *    console.log('Sprite clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onclick = (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousedown` event.\n     * Fired when a mouse button is pressed while the pointer is over the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousedown', (event) => {\n     *    sprite.alpha = 0.5; // Visual feedback\n     *    console.log('Mouse button:', event.button);\n     * });\n     * // Using property-based handler\n     * sprite.onmousedown = (event) => {\n     *     sprite.alpha = 0.5; // Visual feedback\n     *     console.log('Mouse button:', event.button);\n     * };\n     * ```\n     * @default null\n     */\n    onmousedown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseenter` event.\n     * Fired when the mouse pointer enters the bounds of the object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseenter', (event) => {\n     *     sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseenter = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseleave` event.\n     * Fired when the pointer leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseleave', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousemove` event.\n     * Fired when the pointer moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousemove', (event) => {\n     *    // Get coordinates relative to the sprite\n     *   console.log('Local:', event.getLocalPosition(sprite));\n     * });\n     * // Using property-based handler\n     * sprite.onmousemove = (event) => {\n     *     // Get coordinates relative to the sprite\n     *     console.log('Local:', event.getLocalPosition(sprite));\n     * };\n     * ```\n     * @default null\n     */\n    onmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalmousemove` event.\n     *\n     * Fired when the mouse moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalmousemove', (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalmousemove = (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseout = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseover` event.\n     * Fired when the pointer moves onto the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseover', (event) => {\n     *      sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseover = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseup` event.\n     * Fired when a mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseup = (event) => {\n     *      sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseupoutside` event.\n     * Fired when a mouse button is released outside the display object that initially\n     * registered a mousedown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointercancel` event.\n     * Fired when a pointer device interaction is canceled or lost.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointercancel', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointercancel = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointercancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerdown` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is pressed.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerdown', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerdown = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerenter` event.\n     * Fired when a pointer device enters the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerenter', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerenter = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerleave` event.\n     * Fired when a pointer device leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * // Using emitter handler\n     * sprite.on('pointerleave', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointermove` event.\n     * Fired when a pointer device moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalpointermove` event.\n     *\n     * Fired when the pointer moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalpointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerout = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerover` event.\n     * Fired when the pointer moves over the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerover', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerover = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointertap` event.\n     * Fired when a pointer device completes a tap action (e.g., touch or mouse click).\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointertap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointertap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointertap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerup` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is released.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerupoutside` event.\n     * Fired when a pointer device button is released outside the bounds of the display object\n     * that initially registered a pointerdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightclick` event.\n     * Fired when a right-click (context menu) action is performed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightclick', (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onrightclick = (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onrightclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightdown` event.\n     * Fired when a right mouse button is pressed down over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightdown', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.onrightdown = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    onrightdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightup` event.\n     * Fired when a right mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightupoutside` event.\n     * Fired when a right mouse button is released outside the bounds of the display object\n     * that initially registered a rightdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `tap` event.\n     * Fired when a tap action (touch) is completed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('tap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchcancel` event.\n     * Fired when a touch interaction is canceled, such as when the touch is interrupted.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchcancel', (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchcancel = (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchcancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchend` event.\n     * Fired when a touch interaction ends, such as when the finger is lifted from the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchend', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchend = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchend?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchendoutside` event.\n     * Fired when a touch interaction ends outside the bounds of the display object\n     * that initially registered a touchstart.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchendoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchendoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchendoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchmove` event.\n     * Fired when a touch interaction moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globaltouchmove` event.\n     *\n     * Fired when a touch interaction moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globaltouchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobaltouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the touch is outside the object's bounds\n     * - Useful for drag operations or global touch tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globalmousemove`\n     */\n    onglobaltouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchstart` event.\n     * Fired when a touch interaction starts, such as when a finger touches the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchstart', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchstart = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchstart?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `wheel` event.\n     * Fired when the mouse wheel is scrolled while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('wheel', (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * });\n     * // Using property-based handler\n     * sprite.onwheel = (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * };\n     * ```\n     * @default null\n     */\n    onwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n\n/**\n * The options for the `addEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n * @category events\n * @advanced\n */\nexport type AddListenerOptions = boolean | AddEventListenerOptions;\n/**\n * The options for the `removeEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener}\n * @category events\n * @advanced\n */\nexport type RemoveListenerOptions = boolean | EventListenerOptions;\n\n/**\n * Additional properties for a Container that is used for interaction events.\n * @category events\n * @advanced\n */\nexport interface IFederatedContainer extends FederatedOptions\n{\n    /** The parent of this event target. */\n    readonly parent?: Container | null;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<Container>;\n\n    /** @private */\n    _internalEventMode: EventMode;\n\n    /**\n     * Determines if the container is interactive or not\n     * @returns {boolean} Whether the container is interactive or not\n     * @since 7.2.0\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'dynamic';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'none';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'passive';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'auto';\n     * sprite.isInteractive(); // false\n     */\n    isInteractive: () => boolean;\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * @param {any} type - The type of event to listen to.\n     * @param {any} listener - The listener callback or object.\n     * @param {any} options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *     handleEvent(e): {\n     *         let prefix;\n     *\n     *         switch (e.detail) {\n     *             case 1: prefix = 'single'; break;\n     *             case 2: prefix = 'double'; break;\n     *             case 3: prefix = 'triple'; break;\n     *             default: prefix = e.detail + 'th'; break;\n     *         }\n     *\n     *         console.log('That was a ' + prefix + 'click');\n     *     }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *     e.stopImmediatePropagation();\n     *     button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *     capture: true,\n     * });\n     */\n    addEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void;\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * @param {K} type - The type of event the listener is bound to.\n     * @param {any} listener - The listener callback or object.\n     * @param {RemoveListenerOptions} options - The original listener options.\n     * This is required to deregister a capture phase listener.\n     */\n    removeEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void;\n    /**\n     * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     * @param {FederatedEvent} e - The event to dispatch.\n     * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: FederatedEvent): boolean;\n}\n\n/** @internal */\nexport const FederatedContainer: IFederatedContainer = {\n    onclick: null,\n    onmousedown: null,\n    onmouseenter: null,\n    onmouseleave: null,\n    onmousemove: null,\n    onglobalmousemove: null,\n    onmouseout: null,\n    onmouseover:  null,\n    onmouseup:  null,\n    onmouseupoutside: null,\n    onpointercancel: null,\n    onpointerdown:  null,\n    onpointerenter: null,\n    onpointerleave:  null,\n    onpointermove:  null,\n    onglobalpointermove:  null,\n    onpointerout:  null,\n    onpointerover:  null,\n    onpointertap:  null,\n    onpointerup:  null,\n    onpointerupoutside:  null,\n    onrightclick:  null,\n    onrightdown:  null,\n    onrightup:  null,\n    onrightupoutside:  null,\n    ontap:  null,\n    ontouchcancel:  null,\n    ontouchend:  null,\n    ontouchendoutside:  null,\n    ontouchmove:  null,\n    onglobaltouchmove:  null,\n    ontouchstart:  null,\n    onwheel:  null,\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static';\n    },\n    set interactive(value: boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive';\n    },\n    _internalEventMode: undefined,\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode;\n    },\n    set eventMode(value)\n    {\n        this._internalEventMode = value;\n    },\n    isInteractive(): boolean\n    {\n        return this.eventMode === 'static' || this.eventMode === 'dynamic';\n    },\n    interactiveChildren: true,\n    hitArea: null,\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture);\n        const signal = typeof options === 'object' ? options.signal : undefined;\n        const once = typeof options === 'object' ? (options.once === true) : false;\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        const emitter = (this as unknown as EventEmitter);\n\n        if (signal)\n        {\n            signal.addEventListener('abort', () =>\n            {\n                emitter.off(type, listenerFn, context);\n            });\n        }\n\n        if (once)\n        {\n            emitter.once(type, listenerFn, context);\n        }\n        else\n        {\n            emitter.on(type, listenerFn, context);\n        }\n    },\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as Container;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n", "import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { EventSystem } from './EventSystem';\nimport { FederatedContainer } from './FederatedEventTarget';\n\nextensions.add(EventSystem);\nextensions.mixin(Container, FederatedContainer);\n", "/* eslint-disable no-restricted-globals */\nimport { ExtensionType } from '../extensions/Extensions';\nimport { CanvasObserver } from './CanvasObserver';\nimport { type DOMContainer } from './DOMContainer';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\n\n/**\n * The DOMPipe class is responsible for managing and rendering DOM elements within a PixiJS scene.\n * It maps dom elements to the canvas and ensures they are correctly positioned and visible.\n * @internal\n */\nexport class DOMPipe implements RenderPipe<DOMContainer>\n{\n    /**\n     * Static property defining the extension type and name for the DOMPipe.\n     * This is used to register the DOMPipe with different rendering pipelines.\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'dom',\n    } as const;\n\n    private _renderer: Renderer;\n\n    /** Array to keep track of attached DOM elements */\n    private readonly _attachedDomElements: DOMContainer[] = [];\n    /** The main DOM element that acts as a container for other DOM elements */\n    private readonly _domElement: HTMLDivElement;\n    /** The CanvasTransformSync instance that keeps the DOM element in sync with the canvas */\n    private _canvasObserver: CanvasObserver;\n\n    /**\n     * Constructor for the DOMPipe class.\n     * @param renderer - The renderer instance that this DOMPipe will be associated with.\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        // Add this DOMPipe to the postrender runner of the renderer\n        // we want to dom elements are calculated after all things have been rendered\n        this._renderer.runners.postrender.add(this);\n\n        // add DOMPipe to init runners\n        this._renderer.runners.init.add(this);\n\n        // Create a main DOM element to contain other DOM elements\n        this._domElement = document.createElement('div');\n        this._domElement.style.position = 'absolute';\n        this._domElement.style.top = '0';\n        this._domElement.style.left = '0';\n        this._domElement.style.pointerEvents = 'none';\n        this._domElement.style.zIndex = '1000';\n    }\n\n    /** Initializes the DOMPipe, setting up the main DOM element and adding it to the document body. */\n    public init(): void\n    {\n        // Initialize the CanvasTransformSync to keep the DOM element in sync with the canvas\n        this._canvasObserver = new CanvasObserver({\n            domElement: this._domElement,\n            renderer: this._renderer,\n        });\n    }\n\n    /**\n     * Adds a renderable DOM container to the list of attached elements.\n     * @param domContainer - The DOM container to be added.\n     * @param _instructionSet - The instruction set (unused).\n     */\n    public addRenderable(domContainer: DOMContainer, _instructionSet: InstructionSet): void\n    {\n        if (!this._attachedDomElements.includes(domContainer))\n        {\n            this._attachedDomElements.push(domContainer);\n        }\n    }\n\n    /**\n     * Updates a renderable DOM container.\n     * @param _domContainer - The DOM container to be updated (unused).\n     */\n    public updateRenderable(_domContainer: DOMContainer): void\n    {\n        // Updates happen in postrender\n    }\n\n    /**\n     * Validates a renderable DOM container.\n     * @param _domContainer - The DOM container to be validated (unused).\n     * @returns Always returns true as validation is not required.\n     */\n    public validateRenderable(_domContainer: DOMContainer): boolean\n    {\n        return true;\n    }\n\n    /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n    public postrender(): void\n    {\n        const attachedDomElements = this._attachedDomElements;\n\n        if (attachedDomElements.length === 0)\n        {\n            this._domElement.remove();\n\n            return;\n        }\n\n        // Ensure the main DOM element is attached to the same parent as the canvas\n        this._canvasObserver.ensureAttached();\n\n        for (let i = 0; i < attachedDomElements.length; i++)\n        {\n            const domContainer = attachedDomElements[i];\n            const element = domContainer.element;\n\n            if (!domContainer.parent || domContainer.globalDisplayStatus < 0b111)\n            {\n                element?.remove();\n                attachedDomElements.splice(i, 1);\n                i--;\n            }\n            else\n            {\n                if (!this._domElement.contains(element))\n                {\n                    element.style.position = 'absolute';\n                    element.style.pointerEvents = 'auto';\n                    this._domElement.appendChild(element);\n                }\n\n                const wt = domContainer.worldTransform;\n                const anchor = domContainer._anchor;\n                const ax = domContainer.width * anchor.x;\n                const ay = domContainer.height * anchor.y;\n\n                element.style.transformOrigin = `${ax}px ${ay}px`;\n                element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n                element.style.opacity = domContainer.groupAlpha.toString();\n            }\n        }\n    }\n\n    /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n    public destroy(): void\n    {\n        this._renderer.runners.postrender.remove(this);\n\n        for (let i = 0; i < this._attachedDomElements.length; i++)\n        {\n            const domContainer = this._attachedDomElements[i];\n\n            domContainer.element?.remove();\n        }\n\n        this._attachedDomElements.length = 0;\n        this._domElement.remove();\n        this._canvasObserver.destroy();\n        this._renderer = null;\n    }\n}\n", "import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container, type ContainerOptions } from '../container/Container';\nimport { type RenderLayer } from '../layers/RenderLayer';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/** @internal */\nexport interface GPUData\n{\n    destroy: () => void;\n}\n\n/**\n * Options for the construction of a ViewContainer.\n * @category scene\n * @advanced\n */\nexport interface ViewContainerOptions extends ContainerOptions, PixiMixins.ViewContainerOptions {}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface ViewContainer<GPU_DATA extends GPUData = any> extends PixiMixins.ViewContainer, Container\n{\n    // eslint-disable-next-line requireMemberAPI/require-member-api-doc\n    _gpuData: Record<number, GPU_DATA>;\n}\n\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @category scene\n * @advanced\n */\nexport abstract class ViewContainer<GPU_DATA extends GPUData = any> extends Container implements View\n{\n    /** @internal */\n    public override readonly renderPipeId: string;\n    /** @internal */\n    public readonly canBundle = true;\n    /** @internal */\n    public override allowChildren = false;\n\n    /** @internal */\n    public _roundPixels: 0 | 1 = 0;\n    /** @internal */\n    public _lastUsed = -1;\n\n    /** @internal */\n    public _gpuData: Record<number, GPU_DATA> = Object.create(null);\n\n    protected _bounds: Bounds = new Bounds(0, 1, 0, 0);\n    protected _boundsDirty = true;\n\n    /**\n     * The local bounds of the view in its own coordinate space.\n     * Bounds are automatically updated when the view's content changes.\n     * @example\n     * ```ts\n     * // Get bounds dimensions\n     * const bounds = view.bounds;\n     * console.log(`Width: ${bounds.maxX - bounds.minX}`);\n     * console.log(`Height: ${bounds.maxY - bounds.minY}`);\n     * ```\n     * @returns The rectangular bounds of the view\n     * @see {@link Bounds} For bounds operations\n     */\n    public get bounds()\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this.updateBounds();\n\n        this._boundsDirty = false;\n\n        return this._bounds;\n    }\n\n    /** @private */\n    protected abstract updateBounds(): void;\n\n    /**\n     * Whether or not to round the x/y position of the sprite.\n     * @example\n     * ```ts\n     * // Enable pixel rounding for crisp rendering\n     * view.roundPixels = true;\n     * ```\n     * @default false\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(options: ViewContainerOptions)\n    {\n        super(options);\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Uses the view's bounds for hit testing.\n     * @example\n     * ```ts\n     * // Basic point check\n     * const localPoint = { x: 50, y: 25 };\n     * const contains = view.containsPoint(localPoint);\n     * console.log('Point is inside:', contains);\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the view's bounds\n     * @see {@link ViewContainer#bounds} For the bounds used in hit testing\n     * @see {@link Container#toLocal} For converting global coordinates to local\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n        const { x, y } = point;\n\n        return (x >= bounds.minX\n            && x <= bounds.maxX\n            && y >= bounds.minY\n            && y <= bounds.maxY);\n    }\n\n    /** @private */\n    public abstract batched: boolean;\n\n    /** @private */\n    protected onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        this._bounds = null;\n\n        for (const key in this._gpuData)\n        {\n            (this._gpuData[key] as GPU_DATA).destroy?.();\n        }\n\n        this._gpuData = null;\n    }\n\n    /**\n     * Collects renderables for the view container.\n     * @param instructionSet - The instruction set to collect renderables for.\n     * @param renderer - The renderer to collect renderables for.\n     * @param currentLayer - The current render layer.\n     * @internal\n     */\n    public override collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: RenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[this.renderPipeId].addRenderable(this, instructionSet);\n\n        this.didViewUpdate = false;\n\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n        renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n}\n", "import { extensions } from '../extensions/Extensions';\nimport { DOMPipe } from './DOMPipe';\n\nexport * from './index';\n\nextensions.add(DOMPipe);\n", "import type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { ResolvedAsset } from '../../types';\nimport type { Loader } from '../Loader';\n\n/**\n * The extension priority for loader parsers.\n * Helpful when managing multiple parsers that share the same extension test.\n * The higher priority parsers will be checked first.\n * @category assets\n * @advanced\n */\nexport enum LoaderParserPriority\n{\n    /** Generic parsers: txt, json, webfonts */\n    Low = 0,\n    /** PixiJS assets with generic extensions: spritesheets, bitmapfonts  */\n    Normal = 1,\n    /** Specific texture types: svg, png, ktx, dds, basis */\n    High = 2,\n}\n\n/**\n * A more verbose version of the LoaderParser, allowing you to set the loaded, parsed, and unloaded asset separately\n * @category assets\n * @advanced\n */\nexport interface LoaderParserAdvanced<\n    ASSET = any,\n    PARSED_ASSET = ASSET,\n    UNLOAD_ASSET = ASSET,\n    META_DATA = any,\n    CONFIG = Record<string, any>\n>\n{\n    /** Should be ExtensionType.LoaderParser */\n    extension?: ExtensionMetadata;\n\n    /** A config to adjust the parser */\n    config?: CONFIG;\n\n    /**\n     * @deprecated Use `id` instead.\n     */\n    name?: string;\n    /** The name of the parser (this can be used when specifying parser in a ResolvedAsset) */\n    id: string;\n\n    /**\n     * Each URL to load will be tested here,\n     * if the test is passed the assets are loaded using the load function below.\n     * Good place to test for things like file extensions!\n     * @param url - The URL to test\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    test?: (url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => boolean;\n\n    /**\n     * This is the promise that loads the URL provided\n     * resolves with a loaded asset if returned by the parser.\n     * @param url - The URL to load\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    load?: <T>(url: string, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<ASSET | T>;\n\n    /**\n     * This function is used to test if the parse function should be run on the asset\n     * If this returns true then parse is called with the asset\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    testParse?: (asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<boolean>;\n\n    /**\n     * Gets called on the asset it testParse passes. Useful to convert a raw asset into something more useful\n     * @param asset - The loaded asset data\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    parse?: <T>(asset: ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<PARSED_ASSET | T>;\n\n    /**\n     * If an asset is parsed using this parser, the unload function will be called when the user requests an asset\n     * to be unloaded. This is useful for things like sounds or textures that can be unloaded from memory\n     * @param asset - The asset to unload/destroy\n     * @param resolvedAsset - Any custom additional information relevant to the asset being loaded\n     * @param loader - The loader instance\n     */\n    unload?: (asset: UNLOAD_ASSET, resolvedAsset?: ResolvedAsset<META_DATA>, loader?: Loader) => Promise<void> | void;\n}\n\n/**\n * The interface to define a loader parser *(all functions are optional)*.\n *\n * When you create a `parser` object, the flow for every asset loaded is:\n *\n * 1. `parser.test()` - Each URL to load will be tested here, if the test is passed the assets are\n * loaded using the load function below. Good place to test for things like file extensions!\n * 2. `parser.load()` - This is the promise that loads the URL provided resolves with a loaded asset\n * if returned by the parser.\n * 3. `parser.testParse()` - This function is used to test if the parse function should be run on the\n *  asset If this returns true then parse is called with the asset\n * 4. `parse.parse()` - Gets called on the asset it testParse passes. Useful to convert a raw asset\n *  into something more useful\n *\n * <br/>\n * Some loaders may only be used for parsing, some only for loading, and some for both!\n * @category assets\n * @advanced\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface LoaderParser<ASSET = any, META_DATA = any, CONFIG = Record<string, any>>\n    extends LoaderParserAdvanced<ASSET, ASSET, ASSET, META_DATA, CONFIG> {}\n", "/* eslint-disable no-restricted-globals */\nimport { type Adapter } from '../environment/adapter';\nimport { type ImageLike } from '../environment/ImageLike';\n\n/**\n * This is an implementation of the {@link Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @category environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n * @advanced\n */\nexport const BrowserAdapter = {\n    createCanvas: (width: number, height: number): HTMLCanvasElement =>\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        return canvas;\n    },\n    createImage: (): ImageLike => new Image(),\n    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => (document.baseURI ?? window.location.href),\n    getFontFaceSet: () => document.fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n", "import { BrowserAdapter } from '../environment-browser/BrowserAdapter';\nimport { type ImageLike } from './ImageLike';\n\nimport type { ICanvas } from './canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from './canvas/ICanvasRenderingContext2D';\n\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @category environment\n * @advanced\n */\nexport interface Adapter\n{\n    /** Returns a canvas object that can be used to create a webgl context. */\n    createCanvas: (width?: number, height?: number) => ICanvas;\n    /** Returns an IImage (HTMLImageElement) that can be used to create a texture. */\n    createImage: () => ImageLike;\n    /** Returns a 2D rendering context. */\n    getCanvasRenderingContext2D: () => { prototype: ICanvasRenderingContext2D; };\n    /** Returns a WebGL rendering context. */\n    getWebGLRenderingContext: () => typeof WebGLRenderingContext;\n    /** Returns a partial implementation of the browsers window.navigator */\n    getNavigator: () => { userAgent: string, gpu: GPU | null };\n    /** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n    getBaseUrl: () => string;\n    /** Return the font face set if available */\n    getFontFaceSet: () => FontFaceSet | null;\n    /** Returns a Response object that has been fetched from the given URL. */\n    fetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n    /** Returns Document object that has been parsed from the given XML string. */\n    parseXML: (xml: string) => Document;\n}\n\nlet currentAdapter: Adapter = BrowserAdapter;\n\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link Adapter} interface to abstract away the differences between these environments\n * and uses the {@link BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @category environment\n * @advanced\n */\nexport const DOMAdapter = {\n    /**\n     * Returns the current adapter.\n     * @returns {environment.Adapter} The current adapter.\n     */\n    get(): Adapter\n    {\n        return currentAdapter;\n    },\n    /**\n     * Sets the current adapter.\n     * @param adapter - The new adapter.\n     */\n    set(adapter: Adapter): void\n    {\n        currentAdapter = adapter;\n    },\n};\n", "import { DOMAdapter } from '../environment/adapter';\n\nfunction assertPath(path: string)\n{\n    if (typeof path !== 'string')\n    {\n        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);\n    }\n}\n\nfunction removeUrlParams(url: string): string\n{\n    const re = url.split('?')[0];\n\n    return re.split('#')[0];\n}\n\nfunction escapeRegExp(string: string)\n{\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction replaceAll(str: string, find: string, replace: string)\n{\n    return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean)\n{\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = -1;\n\n    for (let i = 0; i <= path.length; ++i)\n    {\n        if (i < path.length)\n        {\n            code = path.charCodeAt(i);\n        }\n        else if (code === 47)\n        {\n            break;\n        }\n        else\n        {\n            code = 47;\n        }\n        if (code === 47)\n        {\n            if (lastSlash === i - 1 || dots === 1)\n            {\n                // NOOP\n            }\n            else if (lastSlash !== i - 1 && dots === 2)\n            {\n                if (\n                    res.length < 2\n                    || lastSegmentLength !== 2\n                    || res.charCodeAt(res.length - 1) !== 46\n                    || res.charCodeAt(res.length - 2) !== 46\n                )\n                {\n                    if (res.length > 2)\n                    {\n                        const lastSlashIndex = res.lastIndexOf('/');\n\n                        if (lastSlashIndex !== res.length - 1)\n                        {\n                            if (lastSlashIndex === -1)\n                            {\n                                res = '';\n                                lastSegmentLength = 0;\n                            }\n                            else\n                            {\n                                res = res.slice(0, lastSlashIndex);\n                                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n                            }\n                            lastSlash = i;\n                            dots = 0;\n                            continue;\n                        }\n                    }\n                    else if (res.length === 2 || res.length === 1)\n                    {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot)\n                {\n                    if (res.length > 0)\n                    { res += '/..'; }\n                    else\n                    { res = '..'; }\n                    lastSegmentLength = 2;\n                }\n            }\n            else\n            {\n                if (res.length > 0)\n                {\n                    res += `/${path.slice(lastSlash + 1, i)}`;\n                }\n                else\n                {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === 46 && dots !== -1)\n        {\n            ++dots;\n        }\n        else\n        {\n            dots = -1;\n        }\n    }\n\n    return res;\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * ```js\n * import { path } from 'pixi.js';\n *\n * path.normalize('http://www.example.com/foo/bar/../baz'); // http://www.example.com/foo/baz\n * ```\n * @category utils\n * @advanced\n */\nexport interface Path\n{\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     */\n    toPosix: (path: string) => string;\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     */\n    isUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     */\n    isDataUrl: (path: string) => boolean;\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     */\n    isBlobUrl: (path: string) => boolean;\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     */\n    hasProtocol: (path: string) => boolean;\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     */\n    getProtocol: (path: string) => string;\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param baseUrl - The base URL to use\n     * @param rootUrl - The root URL to use\n     */\n    toAbsolute: (url: string, baseUrl?: string, rootUrl?: string) => string;\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     */\n    normalize: (path: string) => string;\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     */\n    isAbsolute: (path: string) => boolean;\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param paths - The segments of the path to join\n     */\n    join: (...paths: string[]) => string;\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     */\n    dirname: (path: string) => string;\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     */\n    rootname: (path: string) => string;\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     */\n    basename: (path: string, ext?: string) => string;\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     */\n    extname: (path: string) => string;\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     */\n    parse: (path: string) => { root?: string, dir?: string, base?: string, ext?: string, name?: string };\n    sep: string,\n    delimiter: string,\n    joinExtensions: string[],\n}\n\n/**\n * Path utilities for working with URLs and file paths in a cross-platform way.\n * All paths that are passed in will become normalized to have posix separators.\n * @example\n * ```ts\n * import { path } from 'pixi.js';\n *\n * // Basic path normalization\n * path.normalize('http://www.example.com/foo/bar/../baz');\n * // -> 'http://www.example.com/foo/baz'\n *\n * // Working with file paths\n * path.join('assets', 'images', 'sprite.png');\n * // -> 'assets/images/sprite.png'\n *\n * // URL handling\n * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n * // -> 'http://example.com/assets/images/texture.png'\n * ```\n * @remarks\n * - Normalizes to POSIX separators (forward slashes)\n * - Handles URLs, data URLs, and file paths\n * - Supports path composition and decomposition\n * - Common in asset loading and URL management\n * @category utils\n * @standard\n * @see {@link Path} For full API reference\n * @see {@link DOMAdapter} For platform-specific path handling\n */\nexport const path: Path = {\n    /**\n     * Converts a path to posix format.\n     * @param path - The path to convert to posix\n     * @example\n     * ```ts\n     * // Convert a Windows path to POSIX format\n     * path.toPosix('C:\\\\Users\\\\User\\\\Documents\\\\file.txt');\n     * // -> 'C:/Users/User/Documents/file.txt'\n     * ```\n     */\n    toPosix(path: string) { return replaceAll(path, '\\\\', '/'); },\n    /**\n     * Checks if the path is a URL e.g. http://, https://\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a URL\n     * path.isUrl('http://www.example.com');\n     * // -> true\n     * path.isUrl('C:/Users/User/Documents/file.txt');\n     * // -> false\n     * ```\n     */\n    isUrl(path: string) { return (/^https?:/).test(this.toPosix(path)); },\n    /**\n     * Checks if the path is a data URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a data URL\n     * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');\n     * // -> true\n     * ```\n     */\n    isDataUrl(path: string)\n    {\n        // eslint-disable-next-line max-len\n        return (/^data:([a-z]+\\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s<>]*?)$/i)\n            .test(path);\n    },\n    /**\n     * Checks if the path is a blob URL\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path is a blob URL\n     * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');\n     * // -> true\n     * ```\n     */\n    isBlobUrl(path: string)\n    {\n        // Not necessary to have an exact regex to match the blob URLs\n        return path.startsWith('blob:');\n    },\n    /**\n     * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/\n     * This will return true for windows file paths\n     * @param path - The path to check\n     * @example\n     * ```ts\n     * // Check if a path has a protocol\n     * path.hasProtocol('http://www.example.com');\n     * // -> true\n     * path.hasProtocol('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    hasProtocol(path: string) { return (/^[^/:]+:/).test(this.toPosix(path)); },\n    /**\n     * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/\n     * @param path - The path to get the protocol from\n     * @example\n     * ```ts\n     * // Get the protocol from a URL\n     * path.getProtocol('http://www.example.com/path/to/resource');\n     * // -> 'http://'\n     * // Get the protocol from a file path\n     * path.getProtocol('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    getProtocol(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        const matchFile = (/^file:\\/\\/\\//).exec(path);\n\n        if (matchFile)\n        {\n            return matchFile[0];\n        }\n\n        const matchProtocol = (/^[^/:]+:\\/{0,2}/).exec(path);\n\n        if (matchProtocol)\n        {\n            return matchProtocol[0];\n        }\n\n        return '';\n    },\n\n    /**\n     * Converts URL to an absolute path.\n     * When loading from a Web Worker, we must use absolute paths.\n     * If the URL is already absolute we return it as is\n     * If it's not, we convert it\n     * @param url - The URL to test\n     * @param customBaseUrl - The base URL to use\n     * @param customRootUrl - The root URL to use\n     * @example\n     * ```ts\n     * // Convert a relative URL to an absolute path\n     * path.toAbsolute('images/texture.png', 'http://example.com/assets/');\n     * // -> 'http://example.com/assets/images/texture.png'\n     * ```\n     */\n    toAbsolute(url: string, customBaseUrl?: string, customRootUrl?: string)\n    {\n        assertPath(url);\n\n        if (this.isDataUrl(url) || this.isBlobUrl(url)) return url;\n\n        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));\n        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));\n\n        url = this.toPosix(url);\n\n        // root relative url\n        if (url.startsWith('/'))\n        {\n            return path.join(rootUrl, url.slice(1));\n        }\n\n        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);\n\n        return absolutePath;\n    },\n\n    /**\n     * Normalizes the given path, resolving '..' and '.' segments\n     * @param path - The path to normalize\n     * @example\n     * ```ts\n     * // Normalize a path with relative segments\n     * path.normalize('http://www.example.com/foo/bar/../baz');\n     * // -> 'http://www.example.com/foo/baz'\n     * // Normalize a file path with relative segments\n     * path.normalize('C:\\\\Users\\\\User\\\\Documents\\\\..\\\\file.txt');\n     * // -> 'C:/Users/User/file.txt'\n     * ```\n     */\n    normalize(path: string)\n    {\n        assertPath(path);\n\n        if (path.length === 0) return '.';\n        if (this.isDataUrl(path) || this.isBlobUrl(path)) return path;\n\n        path = this.toPosix(path);\n\n        let protocol = '';\n        const isAbsolute = path.startsWith('/');\n\n        if (this.hasProtocol(path))\n        {\n            protocol = this.rootname(path);\n            path = path.slice(protocol.length);\n        }\n\n        const trailingSeparator = path.endsWith('/');\n\n        // Normalize the path\n        path = normalizeStringPosix(path, false);\n\n        if (path.length > 0 && trailingSeparator) path += '/';\n        if (isAbsolute) return `/${path}`;\n\n        return protocol + path;\n    },\n\n    /**\n     * Determines if path is an absolute path.\n     * Absolute paths can be urls, data urls, or paths on disk\n     * @param path - The path to test\n     * @example\n     * ```ts\n     * // Check if a path is absolute\n     * path.isAbsolute('http://www.example.com/foo/bar');\n     * // -> true\n     * path.isAbsolute('C:/Users/User/Documents/file.txt');\n     * // -> true\n     * ```\n     */\n    isAbsolute(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        if (this.hasProtocol(path)) return true;\n\n        return path.startsWith('/');\n    },\n\n    /**\n     * Joins all given path segments together using the platform-specific separator as a delimiter,\n     * then normalizes the resulting path\n     * @param segments - The segments of the path to join\n     * @example\n     * ```ts\n     * // Join multiple path segments\n     * path.join('assets', 'images', 'sprite.png');\n     * // -> 'assets/images/sprite.png'\n     * // Join with relative segments\n     * path.join('assets', 'images', '../textures', 'sprite.png');\n     * // -> 'assets/textures/sprite.png'\n     * ```\n     */\n    join(...segments: string[])\n    {\n        if (segments.length === 0)\n        { return '.'; }\n        let joined;\n\n        for (let i = 0; i < segments.length; ++i)\n        {\n            const arg = segments[i];\n\n            assertPath(arg);\n            if (arg.length > 0)\n            {\n                if (joined === undefined) joined = arg;\n                else\n                {\n                    const prevArg = segments[i - 1] ?? '';\n\n                    if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase()))\n                    {\n                        joined += `/../${arg}`;\n                    }\n                    else\n                    {\n                        joined += `/${arg}`;\n                    }\n                }\n            }\n        }\n        if (joined === undefined) { return '.'; }\n\n        return this.normalize(joined);\n    },\n\n    /**\n     * Returns the directory name of a path\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the directory name of a path\n     * path.dirname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/foo/bar'\n     * // Get the directory name of a file path\n     * path.dirname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/Users/User/Documents'\n     * ```\n     */\n    dirname(path: string)\n    {\n        assertPath(path);\n        if (path.length === 0) return '.';\n        path = this.toPosix(path);\n        let code = path.charCodeAt(0);\n        const hasRoot = code === 47;\n        let end = -1;\n        let matchedSlash = true;\n\n        const proto = this.getProtocol(path);\n        const origpath = path;\n\n        path = path.slice(proto.length);\n\n        for (let i = path.length - 1; i >= 1; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                if (!matchedSlash)\n                {\n                    end = i;\n                    break;\n                }\n            }\n            else\n            {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n\n        // if end is -1 and its a url then we need to add the path back\n        // eslint-disable-next-line no-nested-ternary\n        if (end === -1) return hasRoot ? '/' : this.isUrl(origpath) ? proto + path : proto;\n        if (hasRoot && end === 1) return '//';\n\n        return proto + path.slice(0, end);\n    },\n\n    /**\n     * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the root of a URL\n     * path.rootname('http://www.example.com/foo/bar/baz.png');\n     * // -> 'http://www.example.com/'\n     * // Get the root of a file path\n     * path.rootname('C:/Users/User/Documents/file.txt');\n     * // -> 'C:/'\n     * ```\n     */\n    rootname(path: string)\n    {\n        assertPath(path);\n        path = this.toPosix(path);\n\n        let root = '';\n\n        if (path.startsWith('/')) root = '/';\n        else\n        {\n            root = this.getProtocol(path);\n        }\n\n        if (this.isUrl(path))\n        {\n            // need to find the first path separator\n            const index = path.indexOf('/', root.length);\n\n            if (index !== -1)\n            {\n                root = path.slice(0, index);\n            }\n            else root = path;\n\n            if (!root.endsWith('/')) root += '/';\n        }\n\n        return root;\n    },\n\n    /**\n     * Returns the last portion of a path\n     * @param path - The path to test\n     * @param ext - Optional extension to remove\n     * @example\n     * ```ts\n     * // Get the basename of a URL\n     * path.basename('http://www.example.com/foo/bar/baz.png');\n     * // -> 'baz.png'\n     * // Get the basename of a file path\n     * path.basename('C:/Users/User/Documents/file.txt');\n     * // -> 'file.txt'\n     * ```\n     */\n    basename(path: string, ext?: string)\n    {\n        assertPath(path);\n        if (ext) assertPath(ext);\n\n        path = removeUrlParams(this.toPosix(path));\n\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i: number;\n\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length)\n        {\n            if (ext.length === path.length && ext === path) return '';\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n\n            for (i = path.length - 1; i >= 0; --i)\n            {\n                const code = path.charCodeAt(i);\n\n                if (code === 47)\n                {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash)\n                    {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else\n                {\n                    if (firstNonSlashEnd === -1)\n                    {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0)\n                    {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx))\n                        {\n                            if (--extIdx === -1)\n                            {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else\n                        {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n\n            if (start === end) end = firstNonSlashEnd; else if (end === -1) end = path.length;\n\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i)\n        {\n            if (path.charCodeAt(i) === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n\n        if (end === -1) return '';\n\n        return path.slice(start, end);\n    },\n\n    /**\n     * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last\n     * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than\n     * the first character of the basename of path, an empty string is returned.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Get the extension of a URL\n     * path.extname('http://www.example.com/foo/bar/baz.png');\n     * // -> '.png'\n     * // Get the extension of a file path\n     * path.extname('C:/Users/User/Documents/file.txt');\n     * // -> '.txt'\n     * ```\n     */\n    extname(path: string)\n    {\n        assertPath(path);\n        path = removeUrlParams(this.toPosix(path));\n\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        for (let i = path.length - 1; i >= 0; --i)\n        {\n            const code = path.charCodeAt(i);\n\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            return '';\n        }\n\n        return path.slice(startDot, end);\n    },\n\n    /**\n     * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.\n     * @param path - The path to parse\n     * @example\n     * ```ts\n     * // Parse a URL\n     * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');\n     * // -> {\n     * //   root: 'http://www.example.com/',\n     * //   dir: 'http://www.example.com/foo/bar',\n     * //   base: 'baz.png',\n     * //   ext: '.png',\n     * //   name: 'baz'\n     * // }\n     * // Parse a file path\n     * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');\n     * // -> {\n     * //   root: 'C:/',\n     * //   dir: 'C:/Users/User/Documents',\n     * //   base: 'file.txt',\n     * //   ext: '.txt',\n     * //   name: 'file'\n     * // }\n     * ```\n     */\n    parse(path: string)\n    {\n        assertPath(path);\n\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n        if (path.length === 0) return ret;\n        path = removeUrlParams(this.toPosix(path));\n\n        let code = path.charCodeAt(0);\n        const isAbsolute = this.isAbsolute(path);\n        let start: number;\n        const protocol = '';\n\n        ret.root = this.rootname(path);\n\n        if (isAbsolute || this.hasProtocol(path))\n        {\n            start = 1;\n        }\n        else\n        {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n\n        // Get non-dir info\n        for (; i >= start; --i)\n        {\n            code = path.charCodeAt(i);\n            if (code === 47)\n            {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash)\n                {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1)\n            {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === 46)\n            {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) startDot = i;\n                else if (preDotState !== 1) preDotState = 1;\n            }\n            else if (startDot !== -1)\n            {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n\n        if (\n            startDot === -1 || end === -1\n            // We saw a non-dot character immediately before the dot\n            || preDotState === 0\n            // The (right-most) trimmed path component is exactly '..'\n            // eslint-disable-next-line no-mixed-operators/no-mixed-operators\n            || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n        )\n        {\n            if (end !== -1)\n            {\n                if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);\n                else ret.base = ret.name = path.slice(startPart, end);\n            }\n        }\n        else\n        {\n            if (startPart === 0 && isAbsolute)\n            {\n                ret.name = path.slice(1, startDot);\n                ret.base = path.slice(1, end);\n            }\n            else\n            {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n            }\n            ret.ext = path.slice(startDot, end);\n        }\n\n        ret.dir = this.dirname(path);\n        if (protocol) ret.dir = protocol + ret.dir;\n\n        return ret;\n    },\n\n    sep: '/',\n    delimiter: ':',\n    joinExtensions: ['.html'],\n} as Path;\n", "/**\n * @param input\n * @param transform\n * @param forceTransform\n * @internal\n */\nexport const convertToList = <T>(\n    input: string | T | (string | T)[],\n    transform?: (input: string) => T,\n    forceTransform = false\n): T[] =>\n{\n    if (!Array.isArray(input))\n    {\n        input = [input as T];\n    }\n\n    if (!transform)\n    {\n        return input as T[];\n    }\n\n    return (input as (string | T)[]).map((item): T =>\n    {\n        if (typeof item === 'string' || forceTransform)\n        {\n            return transform(item as string);\n        }\n\n        return item as T;\n    });\n};\n", "function processX(base: string, ids: string[][], depth: number, result: string[], tags: string[])\n{\n    const id = ids[depth];\n\n    for (let i = 0; i < id.length; i++)\n    {\n        const value = id[i];\n\n        if (depth < ids.length - 1)\n        {\n            processX(base.replace(result[depth], value), ids, depth + 1, result, tags);\n        }\n        else\n        {\n            tags.push(base.replace(result[depth], value));\n        }\n    }\n}\n\n/**\n * Creates a list of all possible combinations of the given strings.\n * @example\n * const out2 = createStringVariations('name is {chicken,wolf,sheep}');\n * console.log(out2); // [ 'name is chicken', 'name is wolf', 'name is sheep' ]\n * @param string - The string to process\n * @internal\n */\nexport function createStringVariations(string: string): string[]\n{\n    const regex = /\\{(.*?)\\}/g;\n\n    const result = string.match(regex);\n\n    const tags: string[] = [];\n\n    if (result)\n    {\n        const ids: string[][] = [];\n\n        result.forEach((vars) =>\n        {\n            // first remove the brackets...\n            const split = vars.substring(1, vars.length - 1).split(',');\n\n            ids.push(split);\n        });\n\n        processX(string, ids, 0, result, tags);\n    }\n    else\n    {\n        tags.push(string);\n    }\n\n    return tags;\n}\n", "/**\n * Checks if the given value is an array.\n * @param item - The item to test\n * @internal\n */\nexport const isSingleItem = (item: unknown): boolean => (!Array.isArray(item));\n", "import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @category assets\n * @advanced\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let {\n                data,\n                format,\n                loadParser: userDefinedLoadParser,\n                parser: userDefinedParser,\n            } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        if (src.loadParser || src.parser)\n                        {\n                            userDefinedLoadParser = src.loadParser ?? userDefinedLoadParser;\n                            userDefinedParser = src.parser ?? userDefinedParser;\n                        }\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser: userDefinedLoadParser,\n                        parser: userDefinedParser,\n                        progressSize: asset.progressSize,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[i];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        parser?: string,\n        format?: string,\n        progressSize?: number,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.parser = parser ?? formattedAsset.parser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n        if (progressSize !== undefined)\n        {\n            formattedAsset.progressSize = progressSize;\n        }\n\n        return formattedAsset;\n    }\n}\n\n/**\n * @param url\n * @internal\n */\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n", "/**\n * Copies the search params from one url to another\n * @param targetUrl - the url to copy the search params to\n * @param sourceUrl - the url container the search params we want to copy\n * @returns the url with the search params copied\n * @internal\n */\nexport const copySearchParams = (targetUrl: string, sourceUrl: string) =>\n{\n    const searchParams = sourceUrl.split('?')[1];\n\n    if (searchParams)\n    {\n        targetUrl += `?${searchParams}`;\n    }\n\n    return targetUrl;\n};\n", "import { Rectangle } from '../maths/shapes/Rectangle';\nimport { TextureSource } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { BindableTexture, TextureBorders } from '../rendering/renderers/shared/texture/Texture';\nimport type { Dict } from '../utils/types';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetFrameData\n{\n    /** The frame rectangle of the texture. */\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    /** Whether the texture is trimmed. */\n    trimmed?: boolean;\n    /** Whether the texture is rotated. */\n    rotated?: boolean;\n    /** The source size of the texture. */\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    /** The sprite source size. */\n    spriteSourceSize?: {\n        h?: number;\n        w?: number;\n        x: number;\n        y: number;\n    };\n    /** The anchor point of the texture. */\n    anchor?: PointData;\n    /** The 9-slice borders of the texture. */\n    borders?: TextureBorders\n}\n\n/**\n * Atlas format.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetData\n{\n    /** The frames of the atlas. */\n    frames: Dict<SpritesheetFrameData>;\n    /** The animations of the atlas. */\n    animations?: Dict<string[]>;\n    /** The meta data of the atlas. */\n    meta: {\n        app?: string;\n        format?: string;\n        frameTags?: {\n            from: number;\n            name: string;\n            to: number;\n            direction: string;\n        }[];\n        image?: string;\n        layers?: {\n            blendMode: string;\n            name: string;\n            opacity: number;\n        }[];\n        scale: number | string;\n        size?: {\n            h: number;\n            w: number;\n        };\n        slices?: {\n            color: string;\n            name: string;\n            keys: {\n                frame: number,\n                bounds: {\n                    x: number;\n                    y: number;\n                    w: number;\n                    h: number;\n                };\n            }[];\n        }[];\n        related_multi_packs?: string[];\n        version?: string;\n    };\n}\n\n/**\n * Options for loading a spritesheet from an atlas.\n * @category assets\n * @advanced\n */\nexport interface SpritesheetOptions<S extends SpritesheetData = SpritesheetData>\n{\n    /** Reference to Texture */\n    texture: BindableTexture;\n    /** JSON data for the atlas. */\n    data: S;\n    /** The filename to consider when determining the resolution of the spritesheet. */\n    resolutionFilename?: string;\n    /**\n     * Prefix to add to texture names when adding to global TextureCache,\n     * using this option can be helpful if you have multiple texture atlases\n     * that share texture names and you need to disambiguate them.\n     */\n    cachePrefix?: string;\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code you may pass its JSON data file to Pixi's loader:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('images/spritesheet.json');\n * ```\n *\n * Alternately, you may circumvent the loader by instantiating the Spritesheet directly:\n *\n * ```js\n * import { Spritesheet } from 'pixi.js';\n *\n * const sheet = new Spritesheet(texture, spritesheetData);\n * await sheet.parse();\n * console.log('Spritesheet ready to use!');\n * ```\n *\n * With the `sheet.textures` you can create Sprite objects, and `sheet.animations` can be used to create an AnimatedSprite.\n *\n * Here's an example of a sprite sheet JSON data file:\n * ```json\n * {\n *     \"frames\": {\n *         \"enemy1.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":1,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"enemy2.png\":\n *         {\n *             \"frame\": {\"x\":103,\"y\":35,\"w\":32,\"h\":32},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":32,\"h\":32},\n *             \"sourceSize\": {\"w\":32,\"h\":32},\n *             \"anchor\": {\"x\":0.5,\"y\":0.5}\n *         },\n *         \"button.png\":\n *         {\n *             \"frame\": {\"x\":1,\"y\":1,\"w\":100,\"h\":100},\n *             \"spriteSourceSize\": {\"x\":0,\"y\":0,\"w\":100,\"h\":100},\n *             \"sourceSize\": {\"w\":100,\"h\":100},\n *             \"anchor\": {\"x\":0,\"y\":0},\n *             \"borders\": {\"left\":35,\"top\":35,\"right\":35,\"bottom\":35}\n *         }\n *     },\n *\n *     \"animations\": {\n *         \"enemy\": [\"enemy1.png\",\"enemy2.png\"]\n *     },\n *\n *     \"meta\": {\n *         \"image\": \"sheet.png\",\n *         \"format\": \"RGBA8888\",\n *         \"size\": {\"w\":136,\"h\":102},\n *         \"scale\": \"1\"\n *     }\n * }\n * ```\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link Texture#defaultAnchor}), default 9-slice borders\n * (see {@link Texture#defaultBorders}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * Alternative ways for loading spritesheet image if you need more control:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * const sheetTexture = await Assets.load('images/spritesheet.png');\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {texture: sheetTexture} // using of preloaded texture\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n *\n * or:\n *\n * ```js\n * import { Assets } from 'pixi.js';\n *\n * Assets.add({\n *     alias: 'atlas',\n *     src: 'images/spritesheet.json',\n *     data: {imageFilename: 'my-spritesheet.2x.avif'} // using of custom filename located in \"images/my-spritesheet.2x.avif\"\n * });\n * const sheet = await Assets.load('atlas')\n * ```\n * @category assets\n * @standard\n */\nexport class Spritesheet<S extends SpritesheetData = SpritesheetData>\n{\n    /**\n     * The maximum number of Textures to build per process.\n     * @advanced\n     */\n    public static readonly BATCH_SIZE = 1000;\n\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    public linkedSheets: Spritesheet<S>[] = [];\n\n    /** Reference to the source texture. */\n    public textureSource: TextureSource;\n\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link Sprite}:\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * new Sprite(sheet.textures['image.png']);\n     */\n    public textures: Record<keyof S['frames'], Texture>;\n\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link AnimatedSprite}:\n     * @example\n     * import { AnimatedSprite } from 'pixi.js';\n     *\n     * new AnimatedSprite(sheet.animations['anim_name']);\n     */\n    public animations: Record<keyof NonNullable<S['animations']>, Texture[]>;\n\n    /**\n     * Reference to the original JSON data.\n     * @type {object}\n     */\n    public data: S;\n\n    /** The resolution of the spritesheet. */\n    public resolution: number;\n\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     */\n    private _texture: Texture;\n\n    /**\n     * Map of spritesheet frames.\n     * @type {object}\n     */\n    private _frames: S['frames'];\n\n    /** Collection of frame names. */\n    private _frameKeys: (keyof S['frames'])[];\n\n    /** Current batch index being processed. */\n    private _batchIndex: number;\n\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     */\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /** Prefix string to add to global cache */\n    public readonly cachePrefix: string;\n\n    /**\n     * @class\n     * @param options - Options to use when constructing a new Spritesheet.\n     */\n    constructor(options: SpritesheetOptions<S>);\n\n    /**\n     * @param texture - Reference to the source BaseTexture object.\n     * @param {object} data - Spritesheet image data.\n     */\n    constructor(texture: BindableTexture, data: S);\n\n    constructor(optionsOrTexture: SpritesheetOptions<S> | BindableTexture, arg1?: S)\n    {\n        let options = optionsOrTexture as SpritesheetOptions<S>;\n\n        if ((optionsOrTexture as BindableTexture)?.source instanceof TextureSource)\n        {\n            options = {\n                texture: optionsOrTexture as BindableTexture,\n                data: arg1,\n            };\n        }\n        const { texture, data, cachePrefix = '' } = options;\n\n        this.cachePrefix = cachePrefix;\n        this._texture = texture instanceof Texture ? texture : null;\n        this.textureSource = texture.source;\n        this.textures = {} as Record<keyof S['frames'], Texture>;\n        this.animations = {} as Record<keyof NonNullable<S['animations']>, Texture[]>;\n        this.data = data;\n\n        const metaResolution = parseFloat(data.meta.scale as string);\n\n        if (metaResolution)\n        {\n            this.resolution = metaResolution;\n            texture.source.resolution = this.resolution;\n        }\n        else\n        {\n            this.resolution = texture.source._resolution;\n        }\n\n        this._frames = this.data.frames;\n        this._frameKeys = Object.keys(this._frames);\n        this._batchIndex = 0;\n        this._callback = null;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     */\n    public parse(): Promise<Record<string, Texture>>\n    {\n        return new Promise((resolve) =>\n        {\n            this._callback = resolve;\n            this._batchIndex = 0;\n\n            if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n            {\n                this._processFrames(0);\n                this._processAnimations();\n                this._parseComplete();\n            }\n            else\n            {\n                this._nextBatch();\n            }\n        });\n    }\n\n    /**\n     * Process a batch of frames\n     * @param initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture({\n                    source: this.textureSource,\n\n                    frame,\n                    orig,\n                    trim,\n                    rotate: data.rotated ? 2 : 0,\n                    defaultAnchor: data.anchor,\n                    defaultBorders: data.borders,\n\n                    label: i.toString(),\n                });\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /** Parse animations config. */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName as keyof S['animations']] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /** The parse has completed. */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /** Begin the next batch of textures. */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.textureSource.destroy();\n        }\n        this._texture = null;\n        this.textureSource = null;\n        this.linkedSheets = [];\n    }\n}\n", "import { LoaderParserPriority } from '../assets/loader/parsers/LoaderParser';\nimport { Resolver } from '../assets/resolver/Resolver';\nimport { copySearchParams } from '../assets/utils/copySearchParams';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { path } from '../utils/path';\nimport { Spritesheet } from './Spritesheet';\n\nimport type { AssetExtensionAdvanced } from '../assets/AssetExtension';\nimport type { Loader } from '../assets/loader/Loader';\nimport type { ResolvedAsset } from '../assets/types';\nimport type { TextureSourceOptions } from '../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { SpritesheetData } from './Spritesheet';\n\n/**\n * Interface for the JSON data structure of a spritesheet.\n * This is used to define the structure of the JSON file that describes a spritesheet.\n * It includes metadata about the spritesheet and the frames it contains.\n * @see {@link Spritesheet}\n * @see {@link SpritesheetData}\n * @category assets\n * @advanced\n */\nexport interface SpriteSheetJson extends SpritesheetData\n{\n    meta: {\n        image: string;\n        scale: string;\n        related_multi_packs?: string[];\n    };\n}\n\nconst validImages = ['jpg', 'png', 'jpeg', 'avif', 'webp',\n    'basis', 'etc2', 'bc7', 'bc6h', 'bc5', 'bc4', 'bc3', 'bc2', 'bc1', 'eac', 'astc'];\n\nfunction getCacheableAssets(keys: string[], asset: Spritesheet, ignoreMultiPack: boolean)\n{\n    const out: Record<string, any> = {};\n\n    keys.forEach((key: string) =>\n    {\n        out[key] = asset;\n    });\n\n    Object.keys(asset.textures).forEach((key) =>\n    {\n        out[`${asset.cachePrefix}${key}`] = asset.textures[key];\n    });\n\n    if (!ignoreMultiPack)\n    {\n        const basePath = path.dirname(keys[0]);\n\n        asset.linkedSheets.forEach((item: Spritesheet, i) =>\n        {\n            const out2 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, true);\n\n            Object.assign(out, out2);\n        });\n    }\n\n    return out;\n}\n\n/**\n * Asset extension for loading spritesheets\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *     alias: 'spritesheet',\n *     src: 'path/to/spritesheet.json',\n *     data: {\n *         ignoreMultiPack: true,\n *         textureOptions: {\n *             scaleMode: \"nearest\"\n *         }\n *     }\n * })\n * @type {AssetExtension}\n * @category assets\n * @advanced\n */\nexport const spritesheetAsset = {\n    extension: ExtensionType.Asset,\n    /** Handle the caching of the related Spritesheet Textures */\n    cache: {\n        test: (asset: Spritesheet) => asset instanceof Spritesheet,\n        getCacheableAssets: (keys: string[], asset: Spritesheet) => getCacheableAssets(keys, asset, false),\n    },\n    /** Resolve the resolution of the asset. */\n    resolver: {\n        extension: {\n            type: ExtensionType.ResolveParser,\n            name: 'resolveSpritesheet',\n        },\n        test: (value: string): boolean =>\n        {\n            const tempURL = value.split('?')[0];\n            const split = tempURL.split('.');\n            const extension = split.pop();\n            const format = split.pop();\n\n            return extension === 'json' && validImages.includes(format);\n        },\n        parse: (value: string) =>\n        {\n            const split = value.split('.');\n\n            return {\n                resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n                format: split[split.length - 2],\n                src: value,\n            };\n        },\n    },\n    /**\n     * Loader plugin that parses sprite sheets!\n     * once the JSON has been loaded this checks to see if the JSON is spritesheet data.\n     * If it is, we load the spritesheets image and parse the data into Spritesheet\n     * All textures in the sprite sheet are then added to the cache\n     */\n    loader: {\n        /** used for deprecation purposes */\n        name: 'spritesheetLoader',\n        id: 'spritesheet',\n\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spritesheetLoader',\n        },\n\n        async testParse(asset: SpriteSheetJson, options: ResolvedAsset): Promise<boolean>\n        {\n            return (path.extname(options.src).toLowerCase() === '.json' && !!asset.frames);\n        },\n\n        async parse(\n            asset: SpriteSheetJson,\n            options: ResolvedAsset<{\n                texture?: Texture,\n                imageFilename?: string,\n                ignoreMultiPack?: boolean,\n                textureOptions?: TextureSourceOptions,\n                cachePrefix?: string,\n            }>,\n            loader?: Loader\n        ): Promise<Spritesheet>\n        {\n            const {\n                texture: imageTexture, // if user need to use preloaded texture\n                imageFilename, // if user need to use custom filename (not from jsonFile.meta.image)\n                textureOptions, // if user need to set texture options on texture\n                cachePrefix, // if user need to use custom cache prefix\n            } = options?.data ?? {};\n\n            let basePath = path.dirname(options.src);\n\n            if (basePath && basePath.lastIndexOf('/') !== (basePath.length - 1))\n            {\n                basePath += '/';\n            }\n\n            let texture: Texture;\n\n            if (imageTexture instanceof Texture)\n            {\n                texture = imageTexture;\n            }\n            else\n            {\n                const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);\n\n                const assets = await loader.load<Texture>([{ src: imagePath, data: textureOptions }]);\n\n                texture = assets[imagePath];\n            }\n\n            const spritesheet = new Spritesheet({\n                texture: texture.source,\n                data: asset,\n                cachePrefix\n            });\n\n            await spritesheet.parse();\n\n            // Check and add the multi atlas\n            // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n            const multiPacks = asset?.meta?.related_multi_packs;\n\n            if (Array.isArray(multiPacks))\n            {\n                const promises: Promise<Spritesheet<SpriteSheetJson>>[] = [];\n\n                for (const item of multiPacks)\n                {\n                    if (typeof item !== 'string')\n                    {\n                        continue;\n                    }\n\n                    let itemUrl = basePath + item;\n\n                    // Check if the file wasn't already added as multipack\n                    if (options.data?.ignoreMultiPack)\n                    {\n                        continue;\n                    }\n\n                    itemUrl = copySearchParams(itemUrl, options.src);\n\n                    promises.push(loader.load<Spritesheet<SpriteSheetJson>>({\n                        src: itemUrl,\n                        data: {\n                            textureOptions,\n                            ignoreMultiPack: true,\n                        }\n                    }));\n                }\n\n                const res = await Promise.all(promises);\n\n                spritesheet.linkedSheets = res;\n                res.forEach((item) =>\n                {\n                    item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => (sp !== item)));\n                });\n            }\n\n            return spritesheet;\n        },\n\n        async unload(spritesheet: Spritesheet, _resolvedAsset, loader)\n        {\n            await loader.unload(spritesheet.textureSource._sourceOrigin);\n\n            spritesheet.destroy(false);\n        },\n    }\n} satisfies AssetExtensionAdvanced<SpriteSheetJson, Spritesheet, Spritesheet, Spritesheet>;\n", "import { extensions } from '../extensions/Extensions';\nimport { spritesheetAsset } from './spritesheetAsset';\n\nextensions.add(spritesheetAsset);\n", "import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\n/**\n * Updates the bounds of a quad (a rectangular area) based on the provided texture and anchor point.\n *\n * This function calculates the minimum and maximum x and y coordinates of the bounds, taking into\n * account the texture's original dimensions and any trimming that may have been applied to it.\n * @param {BoundsData} bounds - The bounds object to be updated. It contains minX, maxX, minY, and maxY properties.\n * @param {ObservablePoint} anchor - The anchor point of the texture, which affects the positioning of the bounds.\n * @param {Texture} texture - The texture whose dimensions and trimming information are used to update the bounds.\n * @internal\n */\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture\n): void\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    // If the texture has trimming information, adjust the bounds accordingly\n    if (trim)\n    {\n        // Calculate the source width and height from the trim\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        // Update the bounds using the trim's x and y offsets and the anchor point\n        bounds.minX = trim.x - (anchor._x * width);\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = trim.y - (anchor._y * height);\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n    // If there is no trimming, calculate the bounds based solely on the texture's original dimensions\n    else\n    {\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { deprecation } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\nimport { type BatchableSprite } from './BatchableSprite';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for configuring a Sprite instance. Defines the texture, anchor point, and rendering behavior.\n * @example\n * ```ts\n * // Create a basic sprite with texture\n * const sprite = new Sprite({\n *     texture: Texture.from('sprite.png')\n * });\n *\n * // Create a centered sprite with rounded position\n * const centeredSprite = new Sprite({\n *     texture: Texture.from('centered.png'),\n *     anchor: 0.5,        // Center point\n *     roundPixels: true,  // Crisp rendering\n *     x: 100,            // Position from ViewContainerOptions\n *     y: 100\n * });\n *\n * // Create a sprite with specific anchor points\n * const anchoredSprite = new Sprite({\n *     texture: Texture.from('corner.png'),\n *     anchor: {\n *         x: 1,  // Right-aligned\n *         y: 0   // Top-aligned\n *     }\n * });\n * ```\n * @extends ViewContainerOptions\n * @category scene\n * @standard\n * @noInheritDoc\n */\nexport interface SpriteOptions extends PixiMixins.SpriteOptions, ViewContainerOptions\n{\n    /**\n     * The texture to use for the sprite. If not provided, uses Texture.EMPTY\n     * @default Texture.EMPTY\n     * @example\n     * ```ts\n     * // Create a sprite with a texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('path/to/image.png')\n     * });\n     * // Update the texture later\n     * sprite.texture = Texture.from('path/to/another-image.png');\n     * ```\n     */\n    texture?: Texture;\n\n    /**\n     * The anchor point of the sprite (0-1 range).\n     * Controls the origin point for rotation, scaling, and positioning.\n     * Can be a number for uniform anchor or a PointData for separate x/y values.\n     * @default 0\n     * @example\n     * ```ts\n     * // Centered anchor\n     * anchor: 0.5\n     * // Separate x/y anchor\n     * anchor: { x: 0.5, y: 0.5 }\n     * // Right-aligned anchor\n     * anchor: { x: 1, y: 0 }\n     * ```\n     */\n    anchor?: PointData | number;\n\n    /**\n     * Whether or not to round the x/y position to whole pixels.\n     * Useful for crisp pixel art style rendering.\n     * @default false\n     * @example\n     * ```ts\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png'),\n     *     roundPixels: true // Ensures crisp rendering\n     * });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Sprite extends PixiMixins.Sprite, ViewContainer<BatchableSprite> {}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n * Sprites can display images, handle input events, and be transformed in various ways.\n * @example\n * ```ts\n * // Create a sprite directly from an image path\n * const sprite = Sprite.from('assets/image.png');\n * sprite.position.set(100, 100);\n * app.stage.addChild(sprite);\n *\n * // Create from a spritesheet (more efficient)\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n *\n * // Create with specific options\n * const configuredSprite = new Sprite({\n *     texture: Texture.from('sprite.png'),\n *     anchor: 0.5,           // Center anchor point\n *     position: { x: 100, y: 100 },\n *     scale: { x: 2, y: 2 }, // Double size\n *     rotation: Math.PI / 4   // 45 degrees\n * });\n *\n * // Animate sprite properties\n * app.ticker.add(() => {\n *     sprite.rotation += 0.1;      // Rotate\n *     sprite.scale.x = Math.sin(performance.now() / 1000) + 1; // Pulse scale\n * });\n * ```\n * @category scene\n * @standard\n * @see {@link SpriteOptions} For configuration options\n * @see {@link Texture} For texture management\n * @see {@link Assets} For asset loading\n */\nexport class Sprite extends ViewContainer<BatchableSprite>\n{\n    /**\n     * Creates a new sprite based on a source texture, image, video, or canvas element.\n     * This is a convenience method that automatically creates and manages textures.\n     * @example\n     * ```ts\n     * // Create from path or URL\n     * const sprite = Sprite.from('assets/image.png');\n     *\n     * // Create from existing texture\n     * const sprite = Sprite.from(texture);\n     *\n     * // Create from canvas\n     * const canvas = document.createElement('canvas');\n     * const sprite = Sprite.from(canvas, true); // Skip caching new texture\n     * ```\n     * @param source - The source to create the sprite from. Can be a path to an image, a texture,\n     * or any valid texture source (canvas, video, etc.)\n     * @param skipCache - Whether to skip adding to the texture cache when creating a new texture\n     * @returns A new sprite based on the source\n     * @see {@link Texture.from} For texture creation details\n     * @see {@link Assets} For asset loading and management\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    /** @internal */\n    public override readonly renderPipeId: string = 'sprite';\n\n    /** @internal */\n    public batched = true;\n    /** @internal */\n    public readonly _anchor: ObservablePoint;\n\n    /** @internal */\n    public _texture: Texture;\n\n    private readonly _visualBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        if (this._width)\n        {\n            this._setWidth(this._width, this._texture.orig.width);\n        }\n\n        if (this._height)\n        {\n            this._setHeight(this._height, this._texture.orig.height);\n        }\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The texture that is displayed by the sprite. When changed, automatically updates\n     * the sprite dimensions and manages texture event listeners.\n     * @example\n     * ```ts\n     * // Create sprite with texture\n     * const sprite = new Sprite({\n     *     texture: Texture.from('sprite.png')\n     * });\n     *\n     * // Update texture\n     * sprite.texture = Texture.from('newSprite.png');\n     *\n     * // Use texture from spritesheet\n     * const sheet = await Assets.load('spritesheet.json');\n     * sprite.texture = sheet.textures['frame1.png'];\n     *\n     * // Reset to empty texture\n     * sprite.texture = Texture.EMPTY;\n     * ```\n     * @see {@link Texture} For texture creation and management\n     * @see {@link Assets} For asset loading\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The bounds of the sprite, taking into account the texture's trim area.\n     * @example\n     * ```ts\n     * const texture = new Texture({\n     *     source: new TextureSource({ width: 300, height: 300 }),\n     *     frame: new Rectangle(196, 66, 58, 56),\n     *     trim: new Rectangle(4, 4, 58, 56),\n     *     orig: new Rectangle(0, 0, 64, 64),\n     *     rotate: 2,\n     * });\n     * const sprite = new Sprite(texture);\n     * const visualBounds = sprite.visualBounds;\n     * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }\n     */\n    get visualBounds()\n    {\n        updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n\n        return this._visualBounds;\n    }\n\n    /**\n     * @deprecated\n     * @ignore\n     */\n    get sourceBounds()\n    {\n        // #if _DEBUG\n        deprecation('8.6.1', 'Sprite.sourceBounds is deprecated, use visualBounds instead.');\n        // #endif\n\n        return this.visualBounds;\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const bounds = this._bounds;\n\n        const { width, height } = texture.orig;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * sprite.destroy();\n     * sprite.destroy(true);\n     * sprite.destroy({ texture: true, textureSource: true });\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._visualBounds as null) = null;\n        (this._bounds as null) = null;\n        (this._anchor as null) = null;\n        this._gpuData = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * - The default is `(0,0)`, this means the sprite's origin is the top left.\n     * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * ```ts\n     * // Center the anchor point\n     * sprite.anchor = 0.5; // Sets both x and y to 0.5\n     * sprite.position.set(400, 300); // Sprite will be centered at this position\n     *\n     * // Set specific x/y anchor points\n     * sprite.anchor = {\n     *     x: 1, // Right edge\n     *     y: 0  // Top edge\n     * };\n     *\n     * // Using individual coordinates\n     * sprite.anchor.set(0.5, 1); // Center-bottom\n     *\n     * // For rotation around center\n     * sprite.anchor.set(0.5);\n     * sprite.rotation = Math.PI / 4; // 45 degrees around center\n     *\n     * // For scaling from center\n     * sprite.anchor.set(0.5);\n     * sprite.scale.set(2); // Scales from center point\n     * ```\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set width directly\n     * sprite.width = 200;\n     * console.log(sprite.scale.x); // Scale adjusted to match width\n     *\n     * // Set width while preserving aspect ratio\n     * const ratio = sprite.height / sprite.width;\n     * sprite.width = 300;\n     * sprite.height = 300 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.width = sprite.texture.orig.width;\n     * ```\n     */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set height directly\n     * sprite.height = 150;\n     * console.log(sprite.scale.y); // Scale adjusted to match height\n     *\n     * // Set height while preserving aspect ratio\n     * const ratio = sprite.width / sprite.height;\n     * sprite.height = 200;\n     * sprite.width = 200 * ratio;\n     *\n     * // For better performance when setting both width and height\n     * sprite.setSize(300, 400); // Avoids recalculating bounds twice\n     *\n     * // Reset to original texture size\n     * sprite.height = sprite.texture.orig.height;\n     * ```\n     */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.\n     * This is faster than getting width and height separately as it only calculates the bounds once.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * const size = sprite.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * sprite.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the Sprite\n     * @see {@link Sprite#width} For getting just the width\n     * @see {@link Sprite#height} For getting just the height\n     * @see {@link Sprite#setSize} For setting both width and height\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * const sprite = new Sprite(Texture.from('sprite.png'));\n     * sprite.setSize(100, 200); // Width: 100, Height: 200\n     *\n     * // Set uniform size\n     * sprite.setSize(100); // Sets both width and height to 100\n     *\n     * // Set size with object\n     * sprite.setSize({\n     *     width: 200,\n     *     height: 300\n     * });\n     *\n     * // Reset to texture size\n     * sprite.setSize(\n     *     sprite.texture.orig.width,\n     *     sprite.texture.orig.height\n     * );\n     * ```\n     * @param value - This can be either a number or a {@link Size} object\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link Sprite#width} For setting width only\n     * @see {@link Sprite#height} For setting height only\n     * @see {@link Sprite#texture} For the source dimensions\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this._texture.orig.width);\n        height !== undefined && this._setHeight(height, this._texture.orig.height);\n    }\n}\n", "import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\n/**\n * @param mask\n * @param bounds\n * @param skipUpdateTransform\n * @internal\n */\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n", "import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\n/**\n * @param mask\n * @param bounds\n * @param localRoot\n * @internal\n */\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nfunction getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * AlphaMask is an effect that applies a mask to a container using the alpha channel of a sprite.\n * It can be used to create complex masking effects by using a sprite as the mask.\n * The mask can be inverted, and it can render the mask to a texture if the mask is not a sprite.\n * @category rendering\n * @advanced\n */\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public inverse: boolean = false;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        if (!this.inverse)\n        {\n            addMaskBounds(this.mask, bounds, skipUpdateTransform);\n        }\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * The ColorMask effect allows you to apply a color mask to the rendering process.\n * This can be useful for selectively rendering certain colors or for creating\n * effects based on color values.\n * @category rendering\n * @advanced\n */\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * A mask that uses the stencil buffer to clip the rendering of a container.\n * This is useful for complex masks that cannot be achieved with simple shapes.\n * It is more performant than using a `Graphics` mask, but requires WebGL support.\n * It is also useful for masking with `Container` objects that have complex shapes.\n * @category rendering\n * @advanced\n */\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a CanvasSource.\n * @category rendering\n * @advanced\n */\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /**\n     * Should the canvas be resized to preserve its screen width and height regardless\n     * of the resolution of the renderer, this is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\n/**\n * A texture source that uses a canvas as its resource.\n * It automatically resizes the canvas based on the width, height, and resolution.\n * It also provides a 2D rendering context for drawing.\n * @category rendering\n * @advanced\n */\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    private _context2D: CanvasRenderingContext2D;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        this.resizeCanvas();\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity && 'style' in this.resource)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n\n    /**\n     * Returns the 2D rendering context for the canvas.\n     * Caches the context after creating it.\n     * @returns The 2D rendering context of the canvas.\n     */\n    get context2D(): CanvasRenderingContext2D\n    {\n        return this._context2D || (this._context2D = this.resource.getContext('2d') as CanvasRenderingContext2D);\n    }\n}\n", "import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of image-like resource that can be used as a texture source.\n *\n * - `ImageBitmap` is used for bitmap images.\n * - `HTMLCanvasElement` and `OffscreenCanvas` are used for canvas elements.\n * - `ICanvas` is an interface for canvas-like objects.\n * - `VideoFrame` is used for video frames.\n * - `HTMLImageElement` is used for HTML image elements.\n * - `HTMLVideoElement` is used for HTML video elements.\n * @category rendering\n * @advanced\n */\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\n/**\n * A texture source that uses an image-like resource as its resource.\n * It can handle HTMLImageElement, ImageBitmap, VideoFrame, and HTMLVideoElement.\n * It is used for textures that can be uploaded to the GPU.\n * @category rendering\n * @advanced\n */\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap)\n        || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n", "/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\n\nimport type { ALPHA_MODES } from '../../rendering/renderers/shared/texture/const';\n\nlet promise: Promise<ALPHA_MODES> | undefined;\n\n/**\n * Helper for detecting the correct alpha mode for video textures.\n * For some reason, some browsers/devices/WebGL implementations premultiply the alpha\n * of a video before and then a second time if `UNPACK_PREMULTIPLY_ALPHA_WEBGL`\n * is true. So the video is premultiplied twice if the alpha mode is `UNPACK`.\n * In this case we need the alpha mode to be `PMA`. This function detects\n * the upload behavior by uploading a white 2x2 webm with 50% alpha\n * without `UNPACK_PREMULTIPLY_ALPHA_WEBGL` and then checking whether\n * the uploaded pixels are premultiplied.\n * @category utils\n * @internal\n * @returns {Promise<ALPHA_MODES>} The correct alpha mode for video textures.\n */\nexport async function detectVideoAlphaMode(): Promise<ALPHA_MODES>\n{\n    promise ??= (async () =>\n    {\n        const canvas = DOMAdapter.get().createCanvas(1, 1);\n        const gl = canvas.getContext('webgl');\n\n        if (!gl)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const video = await new Promise<HTMLVideoElement | null>((resolve) =>\n        {\n            const video = document.createElement('video');\n\n            video.onloadeddata = () => resolve(video);\n            video.onerror = () => resolve(null);\n            video.autoplay = false;\n            video.crossOrigin = 'anonymous';\n            video.preload = 'auto';\n            // eslint-disable-next-line max-len\n            video.src = 'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=';\n            video.load();\n        });\n\n        if (!video)\n        {\n            return 'premultiply-alpha-on-upload';\n        }\n\n        const texture = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        const framebuffer = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.framebufferTexture2D(\n            gl.FRAMEBUFFER,\n            gl.COLOR_ATTACHMENT0,\n            gl.TEXTURE_2D,\n            texture,\n            0\n        );\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);\n\n        const pixel = new Uint8Array(4);\n\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n\n        gl.deleteFramebuffer(framebuffer);\n        gl.deleteTexture(texture);\n        gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n        return pixel[0] <= pixel[3] ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload';\n    })();\n\n    return promise;\n}\n", "// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of resource used for video textures.\n * This is typically an HTMLVideoElement.\n * @category rendering\n * @advanced\n */\nexport type VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @category rendering\n * @advanced\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * A texture source that uses a video as its resource.\n * It automatically resizes the texture based on the video dimensions.\n * It also provides methods to control playback and handle video events.\n * This class supports automatic loading, playback, and frame updates.\n * It can also handle cross-origin videos and provides options for looping, muting, and inline playback.\n * @category rendering\n * @advanced\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement);\n    }\n}\n", "import { warn } from '../../utils/logging/warn';\nimport { convertToList } from '../utils/convertToList';\n\nimport type { CacheParser } from './CacheParser';\n\n/** @internal */\nclass CacheClass\n{\n    private readonly _parsers: CacheParser[] = [];\n\n    private readonly _cache: Map<any, any> = new Map();\n    private readonly _cacheMap: Map<string, {\n        keys: string[],\n        cacheKeys: string[],\n    }> = new Map();\n\n    /** Clear all entries. */\n    public reset(): void\n    {\n        this._cacheMap.clear();\n        this._cache.clear();\n    }\n\n    /**\n     * Check if the key exists\n     * @param key - The key to check\n     */\n    public has(key: any): boolean\n    {\n        return this._cache.has(key);\n    }\n\n    /**\n     * Fetch entry by key\n     * @param key - The key of the entry to get\n     */\n    public get<T = any>(key: any): T\n    {\n        const result = this._cache.get(key);\n\n        if (!result)\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n        }\n\n        return result as T;\n    }\n\n    /**\n     * Set a value by key or keys name\n     * @param key - The key or keys to set\n     * @param value - The value to store in the cache or from which cacheable assets will be derived.\n     */\n    public set<T = any>(key: any | any[], value: T): void\n    {\n        const keys = convertToList<string>(key);\n\n        let cacheableAssets: Record<string, any>;\n\n        for (let i = 0; i < this.parsers.length; i++)\n        {\n            const parser = this.parsers[i];\n\n            if (parser.test(value))\n            {\n                cacheableAssets = parser.getCacheableAssets(keys, value);\n\n                break;\n            }\n        }\n\n        // convert cacheable assets to a map of key-value pairs\n        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));\n\n        if (!cacheableAssets)\n        {\n            keys.forEach((key) =>\n            {\n                cacheableMap.set(key, value);\n            });\n        }\n\n        const cacheKeys = [...cacheableMap.keys()];\n\n        const cachedAssets = {\n            cacheKeys,\n            keys\n        };\n\n        // this is so we can remove them later..\n        keys.forEach((key) =>\n        {\n            this._cacheMap.set(key, cachedAssets as any);\n        });\n\n        cacheKeys.forEach((key) =>\n        {\n            const val = cacheableAssets ? cacheableAssets[key] : value;\n\n            if (this._cache.has(key) && this._cache.get(key) !== val)\n            {\n                // #if _DEBUG\n                warn('[Cache] already has key:', key);\n                // #endif\n            }\n\n            this._cache.set(key, cacheableMap.get(key));\n        });\n    }\n\n    /**\n     * Remove entry by key\n     *\n     * This function will also remove any associated alias from the cache also.\n     * @param key - The key of the entry to remove\n     */\n    public remove(key: any): void\n    {\n        if (!this._cacheMap.has(key))\n        {\n            // #if _DEBUG\n            warn(`[Assets] Asset id ${key} was not found in the Cache`);\n            // #endif\n\n            return;\n        }\n\n        const cacheMap = this._cacheMap.get(key);\n\n        const cacheKeys = cacheMap.cacheKeys;\n\n        cacheKeys.forEach((key) =>\n        {\n            this._cache.delete(key);\n        });\n\n        cacheMap.keys.forEach((key: string) =>\n        {\n            this._cacheMap.delete(key);\n        });\n    }\n\n    /**\n     * All loader parsers registered\n     * @advanced\n     */\n    public get parsers(): CacheParser[]\n    {\n        return this._parsers;\n    }\n}\n\n/**\n * A global cache for all assets in your PixiJS application. The cache system provides fast\n * access to loaded assets and prevents duplicate loading.\n *\n * Key Features:\n * - Automatic caching of loaded assets\n * - Support for custom cache parsers\n * - Automatic parsing of complex assets (e.g., spritesheets)\n * - Memory management utilities\n * > [!IMPORTANT] You typically do not need to use this class directly.\n * > Use the main {@link Assets} class for high-level asset management.\n * > `Assets.get(key)` will automatically use the cache.\n * @example\n * ```ts\n * import { Cache } from 'pixi.js';\n *\n * // Store an asset in the cache\n * Cache.set('myTexture', texture);\n *\n * // Retrieve an asset\n * const texture = Cache.get('myTexture');\n *\n * // Check if an asset exists\n * if (Cache.has('myTexture')) {\n *     // Use the cached asset\n *     const sprite = new Sprite(Cache.get('myTexture'));\n * }\n *\n * // Remove an asset from cache\n * Cache.remove('myTexture');\n *\n * // Clear all cached assets\n * Cache.reset();\n * ```\n * @remarks\n * The Cache is a core component of PixiJS' asset management system:\n * - Used internally by the {@link Assets} class\n * - Supports automatic parsing via {@link CacheParser}\n * - Handles complex asset types like spritesheets\n * - Manages memory through asset removal\n *\n * > [!IMPORTANT]\n * > This is a singleton class and should not be instantiated directly.\n * > Use the exported `Cache` instance instead.\n * @see {@link Assets} For high-level asset management\n * @see {@link CacheParser} For custom cache parsing\n * @category assets\n * @class\n * @advanced\n */\nexport const Cache = new CacheClass();\n", "import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\n/**\n * The type of resource or options that can be used to create a texture source.\n * This includes ImageResource, TextureSourceOptions, BufferSourceOptions, and CanvasSourceOptions.\n * @category rendering\n * @advanced\n */\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n * @category rendering\n * @internal\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\n/**\n * @param options\n * @param skipCache\n * @internal\n */\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n * @category utils\n * @internal\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n", "import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n", "import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @category rendering\n * @advanced\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource?.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n", "import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\n/**\n * @param textures\n * @param size\n * @param maxTextures\n * @internal\n */\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number, maxTextures: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid, maxTextures);\n}\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number, maxTextures: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n", "import { type TypedArray } from '../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @category utils\n * @advanced\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    /** View on the raw binary data as a `Uint16Array`. */\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n", "/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n", "/**\n * Various blend modes supported by Pixi\n * @category filters\n * @standard\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @category rendering\n * @advanced\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @category rendering\n * @advanced\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @category rendering\n * @advanced\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n", "import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n * @internal\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n", "import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\n/**\n * @param maxIfs\n * @param gl\n * @internal\n */\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n", "import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @deprecated Use `Renderer.limits.maxBatchableTextures` instead.\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n", "import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @category rendering\n * @advanced\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n", "import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../utils/pool/GlobalResourceRegistry';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Topology } from '../../renderers/shared/geometry/const';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\n/**\n * The action types for a batch.\n * @category rendering\n * @advanced\n */\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @category rendering\n * @advanced\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n    public topology: Topology = 'triangle-strip';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nGlobalResourceRegistry.register({\n    clear: () =>\n    {\n        // check if the first element has a destroy method\n        if (batchPool.length > 0)\n        {\n            for (const item of batchPool)\n            {\n                if (item) item.destroy();\n            }\n        }\n        batchPool.length = 0; // clear the array\n        batchPoolIndex = 0;\n    },\n});\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @category rendering\n * @advanced\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * The topology to be used for rendering.\n     * @type {Topology}\n     */\n    topology: Topology\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @category rendering\n * @advanced\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures: number;\n    /** The initial size of the attribute buffer. */\n    attributesInitialSize?: number;\n    /** The initial size of the index buffer. */\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @category rendering\n * @advanced\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions)\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        if (!options.maxTextures)\n        {\n            deprecation('v8.8.0', 'maxTextures is a required option for Batcher now, please pass it in the options');\n            options.maxTextures = getMaxTexturesPerBatch();\n        }\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    topology,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                topology,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        topology: Topology,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        if (this.batches === null) return;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            if (this._elements[i]) this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n", "/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @category rendering\n * @advanced\n */\nexport enum BufferUsage\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/**\n * All the various typed arrays that exist in js\n * @category rendering\n * @advanced\n */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/**\n * Options for creating a buffer\n *\n * This interface defines the options that can be passed to the Buffer constructor.\n * It includes the data to initialize the buffer with, the size of the buffer,\n * the usage of the buffer, a label for debugging, and whether the buffer should shrink to fit\n * when the data becomes smaller.\n * @category rendering\n * @advanced\n */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\n/** @internal */\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @category rendering\n * @advanced\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /** @internal */\n    public _updateID = 1;\n\n    /** @internal */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    private _dataInt32: Int32Array = null;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size ??= (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    get dataInt32()\n    {\n        if (!this._dataInt32)\n        {\n            this._dataInt32 = new Int32Array((this.data as any).buffer);\n        }\n\n        return this._dataInt32;\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n        this._dataInt32 = null;\n\n        // Event handling\n        if (!oldData || oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n", "import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @category rendering\n * @internal\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n", "import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n * @internal\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\n/**\n * The index buffer array type used in geometries.\n * @category rendering\n * @advanced\n */\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @category rendering\n * @advanced\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute option used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @category rendering\n * @advanced\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @category rendering\n * @advanced\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount ?? 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n", "import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\n/**\n * This class represents a geometry used for batching in the rendering system.\n * It defines the structure of vertex attributes and index buffers for batched rendering.\n * @category rendering\n * @advanced\n */\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n", "const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * @param value\n * @param groupId\n * @internal\n */\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n", "import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\n/** @internal */\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n", "/**\n * @param src\n * @param isES300\n * @param isFragment\n * @internal\n */\nexport function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n", "import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n", "/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n", "const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\n/**\n * @param src\n * @param root0\n * @param root0.name\n * @param isFragment\n * @internal\n */\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n", "/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\n/** @internal */\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\n/** @internal */\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @category rendering\n * @advanced\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     */\n    public readonly _key: number;\n    /**\n     * A cache key used to identify the program instance.\n     * @internal\n     */\n    public _cacheKey: string;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n\n        programCache[this._cacheKey] = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n            programCache[key]._cacheKey = key;\n        }\n\n        return programCache[key];\n    }\n}\n", "import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\n/**\n * @param format\n * @internal\n */\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n", "import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\n/**\n * @param root0\n * @param root0.source\n * @param root0.entryPoint\n * @internal\n */\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n", "/**\n * Defines the structure of the extracted WGSL structs and groups.\n * @category rendering\n * @advanced\n */\nexport interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\n/**\n * @param wgsl\n * @internal\n */\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n", "/** @internal */\nexport enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n", "import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n", "import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n", "import type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param vertexStructsAndGroups\n * @param fragmentStructsAndGroups\n * @internal\n */\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @category rendering\n * @advanced\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @category rendering\n * @advanced\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @category rendering\n * @advanced\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @category rendering\n * @advanced\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @category rendering\n * @advanced\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /** @internal */\n    public _layoutKey = 0;\n    /** @internal */\n    public _cacheKey: string;\n\n    /** @internal */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n        programCache[this._cacheKey] = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n            programCache[key]._cacheKey = key;\n        }\n\n        return programCache[key];\n    }\n}\n\n", "import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n * @internal\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n", "const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n * @internal\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n", "function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\n/**\n * @param fragments\n * @param template\n * @param sort\n * @internal\n */\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n", "function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\n/**\n * @param fragments\n * @param template\n * @internal\n */\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n", "/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n * @internal\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n", "import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/**\n * A high template consists of vertex and fragment source\n * @internal\n */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\n/** @internal */\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n * @internal\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * It is specifically for WebGL and does not compile inputs and outputs.\n * @param options\n * @param options.template - The HighShader template containing vertex and fragment source.\n * @param options.bits - An array of HighShaderBit objects to be compiled into the shader.\n * @returns A HighShaderSource object containing the compiled vertex and fragment shaders.\n * @internal\n */\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n", "/** @ignore */\nconst vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\n/** @ignore */\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\n/** @ignore */\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\n/** @ignore */\nconst fragmentGlTemplate = /* glsl */`\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n", "/** @internal */\nexport const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\n/** @internal */\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\n/** @internal */\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n", "import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n", "/** @internal */\nexport const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\n/** @internal */\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n", "import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n", "/** @internal */\nexport const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n/** @internal */\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n", "// TODO add more types as required\n/** @internal */\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/**\n * useful for checking if a type is supported - a map of supported types with a true value.\n * @internal\n */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\n/** @internal */\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\n/** @internal */\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\n/** @internal */\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\n/**\n * This is the type of the uniform structures that are used in the UniformGroup.\n * @category rendering\n * @advanced\n */\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\n/** @internal */\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\n/** @internal */\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\n/** @internal */\nexport type UniformsSyncCallback = (...args: any[]) => void;\n", "/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n", "import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n/**\n * Extracts the value type from a uniform data object.\n * @internal\n */\nexport type ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @category rendering\n * @advanced\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```ts\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n * ```\n * @category rendering\n * @advanced\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public _resourceType = 'uniformGroup';\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                const arrayMatch = uniformData.type.match(/^array<(\\w+(?:<\\w+>)?),\\s*(\\d+)>$/);\n\n                if (arrayMatch)\n                {\n                    const [, innerType, size] = arrayMatch;\n\n                    throw new Error(\n                        `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`\n                    );\n                }\n\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n", "import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n * @internal\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n", "import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/**\n * A generic renderer that can be either a WebGL or WebGPU renderer.\n * @category rendering\n * @extends WebGLRenderer\n * @extends WebGPURenderer\n * @standard\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\n/**\n * Generic pipes for the renderer.\n * @category rendering\n * @advanced\n */\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * Options for the renderer.\n * @extends WebGLOptions\n * @extends WebGPUOptions\n * @category rendering\n * @standard\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n * @category rendering\n * @internal\n */\nexport enum RendererType\n{\n    /** The WebGL renderer */\n    WEBGL = 0b01,\n    /** The WebGPU renderer */\n    WEBGPU = 0b10,\n    /** Either WebGL or WebGPU renderer */\n    BOTH = 0b11\n}\n\n/**\n * The GPU power preference for the WebGPU context.\n * This is an optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n *\n * - `'high-performance'` will prioritize rendering performance over power consumption,\n * - `'low-power'` will prioritize power saving over rendering performance.\n * @category rendering\n * @advanced\n */\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @category rendering\n * @advanced\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\n/**\n * A descriptor for a shader with groups.\n * This is used to define a shader that uses {@link BindGroup}'s.\n * @category rendering\n * @advanced\n */\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @category rendering\n * @advanced\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @category rendering\n * @advanced\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @category rendering\n * @advanced\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\n/**\n * A shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\n/**\n * A descriptor for a shader with resources and groups.\n * @category rendering\n */\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\n/**\n * A descriptor for a shader with groups and resources.\n * @category rendering\n */\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @category rendering\n * @advanced\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** A unique identifier for the shader */\n    public readonly uid: number = uid('shader');\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param options - The options for the shader\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n", "import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @category rendering\n * @advanced\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement, BatcherOptions } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @category rendering\n * @advanced\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader: DefaultShader;\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    constructor(options: BatcherOptions)\n    {\n        super(options);\n\n        defaultShader ??= new DefaultShader(options.maxTextures);\n\n        this.shader = defaultShader;\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @internal\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n/**\n * @param uvs\n * @param uvsOffset\n * @param uvsStride\n * @param size\n * @internal\n */\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n", "import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @category rendering\n * @internal\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset ||= 0;\n    stride ||= 2;\n    size ||= (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { multiplyHexColors } from '../../container/utils/multiplyHexColors';\n\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Graphics } from './Graphics';\n\nconst identityMatrix = new Matrix();\n\n/**\n * A batchable graphics object.\n * @ignore\n */\nexport class BatchableGraphics implements DefaultBatchableMeshElement\n{\n    public readonly packAsQuad = false;\n    public batcherName = 'default';\n\n    public texture: Texture;\n\n    public topology: Topology = 'triangle-list';\n    public renderable: Graphics;\n    public indexOffset: number;\n    public indexSize: number;\n    public attributeOffset: number;\n    public attributeSize: number;\n    public baseColor: number;\n    public alpha: number;\n    public applyTransform = true;\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    public geometryData: { vertices: number[]; uvs: number[]; indices: number[]; };\n\n    get uvs()\n    {\n        return this.geometryData.uvs;\n    }\n\n    get positions()\n    {\n        return this.geometryData.vertices;\n    }\n\n    get indices()\n    {\n        return this.geometryData.indices;\n    }\n\n    get blendMode()\n    {\n        if (this.renderable && this.applyTransform)\n        {\n            return this.renderable.groupBlendMode;\n        }\n\n        return 'normal';\n    }\n\n    get color()\n    {\n        const rgb = this.baseColor;\n        const bgr = (rgb >> 16) | (rgb & 0xff00) | ((rgb & 0xff) << 16);\n        const renderable = this.renderable;\n\n        if (renderable)\n        {\n            return multiplyHexColors(bgr, renderable.groupColor)\n            + ((this.alpha * renderable.groupAlpha * 255) << 24);\n        }\n\n        return bgr + ((this.alpha * 255) << 24);\n    }\n\n    get transform()\n    {\n        return this.renderable?.groupTransform || identityMatrix;\n    }\n\n    public copyTo(gpuBuffer: BatchableGraphics)\n    {\n        gpuBuffer.indexOffset = this.indexOffset;\n        gpuBuffer.indexSize = this.indexSize;\n\n        gpuBuffer.attributeOffset = this.attributeOffset;\n        gpuBuffer.attributeSize = this.attributeSize;\n\n        gpuBuffer.baseColor = this.baseColor;\n        gpuBuffer.alpha = this.alpha;\n\n        gpuBuffer.texture = this.texture;\n        gpuBuffer.geometryData = this.geometryData;\n\n        gpuBuffer.topology = this.topology;\n    }\n\n    public reset()\n    {\n        this.applyTransform = true;\n        this.renderable = null;\n        this.topology = 'triangle-list';\n    }\n\n    public destroy()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this.geometryData = null;\n        this._batcher = null;\n        this._batch = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/** @internal */\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @internal\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[]): boolean\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            rx = ry = circle.radius;\n            if (rx <= 0)\n            {\n                return false;\n            }\n            x = circle.x;\n            y = circle.y;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            if (rx <= 0 || ry <= 0)\n            { // skip zero ellipse\n                return false;\n            }\n            x = ellipse.x;\n            y = ellipse.y;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (dx < 0 || dy < 0)\n        {\n            return false;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return false;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return true;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return true;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\n/** @internal */\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\n/** @internal */\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n", "/**\n * @param points\n * @internal\n */\nexport function getOrientationOfPoints(points: number[]): number\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return 1;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if (area < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { closePointEps, curveEps } from '../const';\nimport { getOrientationOfPoints } from '../utils/getOrientationOfPoints';\n\nimport type { StrokeAttributes } from '../FillTypes';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {number} innerWeight - Weight of inner points\n * @param {number} outerWeight - Weight of outer points\n * @param {boolean} clockwise - Whether the cap is drawn clockwise\n * @param {Array<number>} verts - vertex buffer\n * @returns {number} - no. of vertices pushed\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array[]} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: number[],\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param lineStyle\n * @param flipAlignment\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildLine(\n    points: number[],\n    lineStyle: StrokeAttributes,\n    flipAlignment: boolean,\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    // const shape = graphicsData.shape as Polygon;\n    //   let points = graphicsData.points || shape.points.slice();\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const style = lineStyle;\n\n    let alignment = style.alignment;\n\n    if (lineStyle.alignment !== 0.5)\n    {\n        // rotate the points!\n        let orientation = getOrientationOfPoints(points);\n\n        if (flipAlignment)orientation *= -1;\n\n        alignment = ((alignment - 0.5) * orientation) + 0.5;\n    }\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = closed;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpX = -(y0 - y1);\n    let perpY = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    const ratio = alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x0 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpX * innerWeight),\n                y0 - (perpY * innerWeight),\n                x0 + (perpX * outerWeight),\n                y0 + (perpY * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpX * innerWeight),\n        y0 - (perpY * innerWeight));\n    verts.push(\n        x0 + (perpX * outerWeight),\n        y0 + (perpY * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpX = -(y0 - y1);\n        perpY = x0 - x1;\n\n        dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n        perpX /= dist;\n        perpY /= dist;\n        perpX *= width;\n        perpY *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle < 90 degree, -ve if internal angle > 90 degree. */\n        const dot = (dx0 * dx1) + (dy0 * dy1);\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly parallel? */\n        /* atan(0.001) ~= 0.001 rad ~= 0.057 degree */\n        if (Math.abs(cross) < 0.001 * Math.abs(dot))\n        {\n            verts.push(\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight));\n            verts.push(\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight));\n\n            /* 180 degree corner? */\n            if (dot >= 0)\n            {\n                if (style.join === 'round')\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false) + 4;\n                }\n                else\n                {\n                    indexCount += 2;\n                }\n\n                verts.push(\n                    x1 - (perp1x * outerWeight),\n                    y1 - (perp1y * outerWeight));\n                verts.push(\n                    x1 + (perp1x * innerWeight),\n                    y1 + (perp1y * innerWeight));\n            }\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pDist is the distance between miter point and p1. */\n        const c1 = ((-perpX + x0) * (-perpY + y1)) - ((-perpX + x1) * (-perpY + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pDist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pDist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === 'bevel' || pDist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n                    verts.push(imx, imy); // inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n                    verts.push(omx, omy); // outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's outer vertex\n                    verts.push(omx, omy); // outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight)); // first segment's outer vertex\n            if (style.join === 'round')\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpX * outerWeight), y1 + (perpY * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpX * innerWeight), y1 - (perpY * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else if (style.join === 'miter' && pDist / widthSquared <= miterLimitSquared)\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpX = -(y0 - y1);\n    perpY = x0 - x1;\n\n    dist = Math.sqrt((perpX * perpX) + (perpY * perpY));\n    perpX /= dist;\n    perpY /= dist;\n    perpX *= width;\n    perpY *= width;\n\n    verts.push(x1 - (perpX * innerWeight), y1 - (perpY * innerWeight));\n    verts.push(x1 + (perpX * outerWeight), y1 + (perpY * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === 'round')\n        {\n            indexCount += round(\n                x1 - (perpX * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpY * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpX * innerWeight),\n                y1 - (perpY * innerWeight),\n                x1 + (perpX * outerWeight),\n                y1 + (perpY * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === 'square')\n        {\n            indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    // const indices = graphicsGeometry.indices;\n    const eps2 = curveEps * curveEps;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n", "import { closePointEps } from '../const';\n\n/**\n * Builds a line to draw using the polygon method.\n * @param points\n * @param closed\n * @param vertices\n * @param indices\n * @internal\n */\nexport function buildPixelLine(\n    points: number[],\n    closed: boolean,\n    vertices: number[],\n    indices: number[],\n): void\n{\n    const eps = closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    // get first and last point.. figure out the middle!\n\n    const fx = points[0];\n    const fy = points[1];\n\n    const lx = points[points.length - 2];\n\n    const ly = points[points.length - 1];\n\n    const closePath = closed || (Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps);\n\n    const verts = vertices;\n\n    const length = points.length / 2;\n    const indexStart = verts.length / 2;\n\n    for (let i = 0; i < length; i++)\n    {\n        verts.push(points[(i * 2)]);\n        verts.push(points[(i * 2) + 1]);\n    }\n\n    for (let i = 0; i < length - 1; i++)\n    {\n        indices.push(indexStart + i, indexStart + i + 1);\n    }\n\n    if (closePath)\n    {\n        indices.push(indexStart + length - 1, indexStart);\n    }\n}\n\n", "\nexport default function earcut(data, holeIndices, dim = 2) {\n\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = data[0];\n        minY = data[1];\n        let maxX = minX;\n        let maxY = minY;\n\n        for (let i = dim; i < outerLen; i += dim) {\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    let stop = ear;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        const prev = ear.prev;\n        const next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    let p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    let p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i, p.i, b.i);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareXYSlope);\n\n    // process holes from left to right\n    for (let i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    const bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for (let i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y),\n        b2 = createNode(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction createNode(i, x, y) {\n    return {\n        i, // vertex index in coordinates array\n        x, y, // vertex coordinates\n        prev: null, // previous and next vertex nodes in a polygon ring\n        next: null,\n        z: 0, // z-order curve value\n        prevZ: null, // previous and next nodes in z-order\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nexport function deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\n\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for (let i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nexport function flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n\n    for (const ring of data) {\n        for (const p of ring) {\n            for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {vertices, holes, dimensions};\n}\n", "import earcutModule from 'earcut';\n\n/**\n * A high performance event emitter\n * @see {@link https://github.com/primus/eventemitter3}\n * @class EventEmitter\n * @category utils\n */\nexport { default as EventEmitter } from 'eventemitter3';\n\n/**\n * A polygon triangulation library\n * @see {@link https://github.com/mapbox/earcut}\n * @param {number[]} vertices - A flat array of vertex coordinates\n * @param {number[]} [holes] - An array of hole indices\n * @param {number} [dimensions=2] - The number of coordinates per vertex in the input array\n * @returns {number[]} Triangulated polygon\n * @category utils\n * @advanced\n */\nexport const earcut = ((earcutModule as any).default || earcutModule) as typeof earcutModule;\n", "import { earcut } from '../../../../utils/utils';\n\n/**\n * @param points\n * @param holes\n * @param vertices\n * @param verticesStride\n * @param verticesOffset\n * @param indices\n * @param indicesOffset\n * @internal\n */\nexport function triangulateWithHoles(\n    points: number[],\n    holes: number[],\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    indices: number[],\n    indicesOffset: number\n)\n{\n    const triangles = earcut(points, holes, 2);\n\n    if (!triangles)\n    {\n        return;\n    }\n\n    for (let i = 0; i < triangles.length; i += 3)\n    {\n        indices[indicesOffset++] = (triangles[i] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 1] + verticesOffset);\n        indices[indicesOffset++] = (triangles[i + 2] + verticesOffset);\n    }\n\n    let index = verticesOffset * verticesStride;\n\n    for (let i = 0; i < points.length; i += 2)\n    {\n        vertices[index] = points[i];\n        vertices[index + 1] = points[i + 1];\n\n        index += verticesStride;\n    }\n}\n\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { triangulateWithHoles } from '../utils/triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\nconst emptyArray: number[] = [];\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildPolygon: ShapeBuildCommand<Polygon> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'polygon',\n    },\n\n    build(shape: Polygon, points: number[]): boolean\n    {\n        for (let i = 0; i < shape.points.length; i++)\n        {\n            points[i] = shape.points[i];\n        }\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n        //  holes: number[],\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);\n    },\n\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildRectangle: ShapeBuildCommand<Rectangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'rectangle',\n    },\n\n    build(shape: Rectangle, points: number[]): boolean\n    {\n        const rectData = shape;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        if (!(width > 0 && height > 0))\n        {\n            return false;\n        }\n\n        points[0] = x;\n        points[1] = y;\n        points[2] = x + width;\n        points[3] = y;\n        points[4] = x + width;\n        points[5] = y + height;\n        points[6] = x;\n        points[7] = y + height;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[6];\n        vertices[verticesOffset + count + 1] = points[7];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        count += verticesStride;\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n\n        // triangle 2\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 3;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Triangle } from '../../../../maths/shapes/Triangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\n/**\n * Builds a triangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildTriangle: ShapeBuildCommand<Triangle> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'triangle',\n    },\n\n    build(shape: Triangle, points: number[]): boolean\n    {\n        points[0] = shape.x;\n        points[1] = shape.y;\n        points[2] = shape.x2;\n        points[3] = shape.y2;\n        points[4] = shape.x3;\n        points[5] = shape.y3;\n\n        return true;\n    },\n\n    triangulate(\n        points: number[],\n\n        vertices: number[],\n        verticesStride: number,\n        verticesOffset: number,\n\n        indices: number[],\n        indicesOffset: number\n    )\n    {\n        let count = 0;\n\n        verticesOffset *= verticesStride;\n\n        vertices[verticesOffset + count] = points[0];\n        vertices[verticesOffset + count + 1] = points[1];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[2];\n        vertices[verticesOffset + count + 1] = points[3];\n\n        count += verticesStride;\n\n        vertices[verticesOffset + count] = points[4];\n        vertices[verticesOffset + count + 1] = points[5];\n\n        const verticesIndex = verticesOffset / verticesStride;\n\n        // triangle 1\n        indices[indicesOffset++] = verticesIndex;\n        indices[indicesOffset++] = verticesIndex + 1;\n        indices[indicesOffset++] = verticesIndex + 2;\n    },\n};\n", "import { Color } from '../../../../color/Color';\nimport { DOMAdapter } from '../../../../environment/adapter';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { type WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { definedProps } from '../../../container/utils/definedProps';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { CanvasAndContext } from '../../../../rendering/renderers/shared/texture/CanvasPool';\nimport type { TextureSpace } from '../FillTypes';\n\n/**\n * Defines the type of gradient to create.\n *\n * It can be:\n * - 'linear': A linear gradient that transitions colors along a straight line.\n * - 'radial': A radial gradient that transitions colors in a circular pattern from an inner circle to an outer circle.\n * @category scene\n * @standard\n */\nexport type GradientType = 'linear' | 'radial';\n\n/**\n * Represents the style options for a linear gradient fill.\n * @category scene\n * @standard\n */\nexport interface BaseGradientOptions\n{\n    /** The type of gradient */\n    type?: GradientType;\n    /** Array of colors stops to use in the gradient */\n    colorStops?: { offset: number, color: ColorSource }[];\n    /** Whether coordinates are 'global' or 'local' */\n    textureSpace?: TextureSpace;\n    /**\n     * The size of the texture to use for the gradient - this is for advanced usage.\n     * The texture size does not need to match the size of the object being drawn.\n     * Due to GPU interpolation, gradient textures can be relatively small!\n     * Consider using a larger texture size if your gradient has a lot of very tight color steps\n     */\n    textureSize?: number;\n    /**\n     * The wrap mode of the gradient.\n     * This can be 'clamp-to-edge' or 'repeat'.\n     * @default 'clamp-to-edge'\n     */\n    wrapMode?: WRAP_MODE\n}\n\n/**\n * Options specific to linear gradients.\n * A linear gradient creates a smooth transition between colors along a straight line defined by start and end points.\n * @category scene\n * @standard\n */\nexport interface LinearGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'linear' for linear gradients. */\n    type?: 'linear';\n\n    /**\n     * The start point of the gradient.\n     * This point defines where the gradient begins.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    start?: PointData;\n\n    /**\n     * The end point of the gradient.\n     * This point defines where the gradient ends.\n     * It is represented as a PointData object containing x and y coordinates.\n     * The coordinates are in local space by default (0-1), but can be in global space if specified.\n     */\n    end?: PointData;\n}\n\n/**\n * Options specific to radial gradients.\n * A radial gradient creates a smooth transition between colors that radiates outward in a circular pattern.\n * The gradient is defined by inner and outer circles, each with their own radius.\n * @category scene\n * @standard\n */\nexport interface RadialGradientOptions extends BaseGradientOptions\n{\n    /** The type of gradient. Must be 'radial' for radial gradients. */\n    type?: 'radial';\n    /** The center point of the inner circle where the gradient begins. In local coordinates by default (0-1). */\n    center?: PointData;\n    /** The radius of the inner circle where the gradient begins. */\n    innerRadius?: number;\n    /** The center point of the outer circle where the gradient ends. In local coordinates by default (0-1). */\n    outerCenter?: PointData;\n    /** The radius of the outer circle where the gradient ends. */\n    outerRadius?: number;\n    /**\n     * The y scale of the gradient, use this to make the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    scale?: number;\n    /**\n     * The rotation of the gradient in radians, useful for making the gradient elliptical.\n     * NOTE: Only applied to radial gradients used with Graphics.\n     */\n    rotation?: number;\n}\n\n/**\n * Options for creating a gradient fill.\n * @category scene\n * @standard\n */\nexport type GradientOptions = LinearGradientOptions | RadialGradientOptions;\n\n/**\n * If no color stops are provided, we use a default gradient of white to black - this is to avoid a blank gradient if a dev\n * forgets to set them.\n */\nconst emptyColorStops: { offset: number, color: string }[] = [{ offset: 0, color: 'white' }, { offset: 1, color: 'black' }];\n\n/**\n * Class representing a gradient fill that can be used to fill shapes and text.\n * Supports both linear and radial gradients with multiple color stops.\n *\n * For linear gradients, color stops define colors and positions (0 to 1) along a line from start point (x0,y0)\n * to end point (x1,y1).\n *\n * For radial gradients, color stops define colors between two circles - an inner circle centered at (x0,y0) with radius r0,\n * and an outer circle centered at (x1,y1) with radius r1.\n * @example\n * ```ts\n * // Create a vertical linear gradient from red to blue\n * const linearGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },  // Start at top\n *     end: { x: 0, y: 1 },    // End at bottom\n *     colorStops: [\n *         { offset: 0, color: 'red' },   // Red at start\n *         { offset: 1, color: 'blue' }   // Blue at end\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a radial gradient from yellow center to green edge\n * const radialGradient = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.5, y: 0.5 },\n *     innerRadius: 0,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'yellow' }, // Center color\n *         { offset: 1, color: 'green' }   // Edge color\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n *\n * // Create a rainbow linear gradient in global coordinates\n * const globalGradient = new FillGradient({\n *     type: 'linear',\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 0 },\n *     colorStops: [\n *         { offset: 0, color: 0xff0000 },    // Red\n *         { offset: 0.33, color: 0x00ff00 }, // Green\n *         { offset: 0.66, color: 0x0000ff }, // Blue\n *         { offset: 1, color: 0xff00ff }     // Purple\n *     ],\n *     textureSpace: 'global'  // Use world coordinates\n * });\n *\n * // Create an offset radial gradient\n * const offsetRadial = new FillGradient({\n *     type: 'radial',\n *     center: { x: 0.3, y: 0.3 },\n *     innerRadius: 0.1,\n *     outerCenter: { x: 0.5, y: 0.5 },\n *     outerRadius: 0.5,\n *     colorStops: [\n *         { offset: 0, color: 'white' },\n *         { offset: 1, color: 'black' }\n *     ],\n *     // Use normalized coordinate system where (0,0) is the top-left and (1,1) is the bottom-right of the shape\n *     textureSpace: 'local'\n * });\n * ```\n *\n * Internally this creates a  texture of the gradient then applies a\n * transform to it to give it the correct size and angle.\n *\n * This means that it's important to destroy a gradient when it is no longer needed\n * to avoid memory leaks.\n *\n * If you want to animate a gradient then it's best to modify and update an existing one\n * rather than creating a whole new one each time. That or use a custom shader.\n * @category scene\n * @standard\n */\nexport class FillGradient implements CanvasGradient\n{\n    /** Default options for creating a gradient fill */\n    public static readonly defaultLinearOptions: LinearGradientOptions = {\n        start: { x: 0, y: 0 },\n        end: { x: 0, y: 1 },\n        colorStops: [],\n        textureSpace: 'local',\n        type: 'linear',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /** Default options for creating a radial gradient fill */\n    public static readonly defaultRadialOptions: RadialGradientOptions = {\n        center: { x: 0.5, y: 0.5 },\n        innerRadius: 0,\n        outerRadius: 0.5,\n        colorStops: [],\n        scale: 1,\n        textureSpace: 'local',\n        type: 'radial',\n        textureSize: 256,\n        wrapMode: 'clamp-to-edge'\n    };\n\n    /**\n     * Unique identifier for this gradient instance\n     * @internal\n     */\n    public readonly uid: number = uid('fillGradient');\n    /**\n     * Internal tick counter to track changes in the gradient.\n     * This is used to invalidate the gradient when the texture changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** Type of gradient - currently only supports 'linear' */\n    public readonly type: GradientType = 'linear';\n\n    /** Internal texture used to render the gradient */\n    public texture: Texture;\n    /** Transform matrix for positioning the gradient */\n    public transform: Matrix;\n    /** Array of color stops defining the gradient */\n    public colorStops: Array<{ offset: number, color: string }> = [];\n\n    /** Whether gradient coordinates are in local or global space */\n    public textureSpace: TextureSpace;\n    private readonly _textureSize: number;\n\n    /** The start point of the linear gradient */\n    public start: PointData;\n    /** The end point of the linear gradient */\n    public end: PointData;\n    /** The wrap mode of the gradient texture */\n    private readonly _wrapMode: WRAP_MODE;\n\n    /** The center point of the inner circle of the radial gradient */\n    public center: PointData;\n    /** The center point of the outer circle of the radial gradient */\n    public outerCenter: PointData;\n    /** The radius of the inner circle of the radial gradient */\n    public innerRadius: number;\n    /** The radius of the outer circle of the radial gradient */\n    public outerRadius: number;\n    /** The scale of the radial gradient */\n    public scale: number;\n    /** The rotation of the radial gradient */\n    public rotation: number;\n\n    /**\n     * Creates a new gradient fill. The constructor behavior changes based on the gradient type.\n     * @param {GradientOptions} options - The options for the gradient\n     * @see {@link LinearGradientOptions}\n     * @see {@link RadialGradientOptions}\n     */\n    constructor(options: GradientOptions);\n    /**\n     * Deprecated: Use the options object instead.\n     * @deprecated since 8.5.2\n     * @ignore\n     */\n    constructor(\n        x0?: number,\n        y0?: number,\n        x1?: number,\n        y1?: number,\n        textureSpace?: TextureSpace,\n        textureSize?: number\n    );\n    constructor(...args: [GradientOptions] | [number?, number?, number?, number?, TextureSpace?, number?])\n    {\n        let options = ensureGradientOptions(args);\n\n        const defaults = options.type === 'radial' ? FillGradient.defaultRadialOptions : FillGradient.defaultLinearOptions;\n\n        options = { ...defaults, ...definedProps(options) };\n\n        this._textureSize = options.textureSize;\n        this._wrapMode = options.wrapMode;\n\n        if (options.type === 'radial')\n        {\n            this.center = options.center;\n            this.outerCenter = options.outerCenter ?? this.center;\n            this.innerRadius = options.innerRadius;\n            this.outerRadius = options.outerRadius;\n            this.scale = options.scale;\n            this.rotation = options.rotation;\n        }\n        else\n        {\n            this.start = options.start;\n            this.end = options.end;\n        }\n\n        this.textureSpace = options.textureSpace;\n\n        this.type = options.type;\n        options.colorStops.forEach((stop) =>\n        {\n            this.addColorStop(stop.offset, stop.color);\n        });\n    }\n\n    /**\n     * Adds a color stop to the gradient\n     * @param offset - Position of the stop (0-1)\n     * @param color - Color of the stop\n     * @returns This gradient instance for chaining\n     */\n    public addColorStop(offset: number, color: ColorSource): this\n    {\n        this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });\n\n        return this;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildLinearGradient(): void\n    {\n        if (this.texture) return;\n\n        let { x: x0, y: y0 } = this.start;\n        let { x: x1, y: y1 } = this.end;\n\n        let dx = x1 - x0;\n        let dy = y1 - y0;\n\n        // Determine flip based on original dx/dy and swap coordinates if necessary\n        const flip = dx < 0 || dy < 0;\n\n        if (this._wrapMode === 'clamp-to-edge')\n        {\n            if (dx < 0)\n            {\n                const temp = x0;\n\n                x0 = x1;\n                x1 = temp;\n                dx *= -1;\n            }\n            if (dy < 0)\n            {\n                const temp = y0;\n\n                y0 = y1;\n                y1 = temp;\n                dy *= -1;\n            }\n        }\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n\n        const { canvas, context } = getCanvas(defaultSize, 1);\n\n        const gradient = !flip\n            ? context.createLinearGradient(0, 0, this._textureSize, 0)\n            : context.createLinearGradient(this._textureSize, 0, 0, 0);\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, defaultSize, 1);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        // generate some UVS based on the gradient direction sent\n\n        const dist = Math.sqrt((dx * dx) + (dy * dy));\n        const angle = Math.atan2(dy, dx);\n\n        // little offset to stop the uvs from flowing over the edge..\n        // this matrix is inverted when used in the graphics\n        // add a tiny off set to prevent uv bleeding..\n        const m = new Matrix();\n\n        m.scale((dist / defaultSize), 1);\n        m.rotate(angle);\n        m.translate(x0, y0);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n        this.transform = m;\n    }\n\n    /**\n     * Builds the internal texture and transform for the gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildGradient(): void\n    {\n        if (!this.texture) this._tick++;\n        if (this.type === 'linear')\n        {\n            this.buildLinearGradient();\n        }\n        else\n        {\n            this.buildRadialGradient();\n        }\n    }\n\n    /**\n     * Builds the internal texture and transform for the radial gradient.\n     * Called automatically when the gradient is first used.\n     * @internal\n     */\n    public buildRadialGradient(): void\n    {\n        if (this.texture) return;\n\n        const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;\n\n        const defaultSize = this._textureSize;\n        const { canvas, context } = getCanvas(defaultSize, defaultSize);\n\n        const { x: x0, y: y0 } = this.center;\n        const { x: x1, y: y1 } = this.outerCenter;\n\n        const r0 = this.innerRadius;\n        const r1 = this.outerRadius;\n\n        const ox = x1 - r1;\n        const oy = y1 - r1;\n\n        const scale = defaultSize / (r1 * 2);\n\n        const cx = (x0 - ox) * scale;\n        const cy = (y0 - oy) * scale;\n\n        const gradient = context.createRadialGradient(\n            cx,\n            cy,\n            r0 * scale,\n            (x1 - ox) * scale,\n            (y1 - oy) * scale,\n            r1 * scale\n        );\n\n        addColorStops(gradient, colorStops);\n\n        context.fillStyle = colorStops[colorStops.length - 1].color;\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        context.fillStyle = gradient;\n\n        // First translate to center\n        context.translate(cx, cy);\n\n        // Then apply rotation\n        context.rotate(this.rotation);\n\n        // Then scale2\n        context.scale(1, this.scale);\n\n        // Finally translate back, taking scale into account\n        context.translate(-cx, -cy);\n\n        context.fillRect(0, 0, defaultSize, defaultSize);\n\n        this.texture = new Texture({\n            source: new ImageSource({\n                resource: canvas,\n                addressMode: this._wrapMode,\n            }),\n        });\n\n        const m = new Matrix();\n\n        // this matrix is inverted when used in the graphics\n        m.scale(1 / scale, 1 / scale);\n        m.translate(ox, oy);\n\n        if (this.textureSpace === 'local')\n        {\n            m.scale(defaultSize, defaultSize);\n        }\n\n        this.transform = m;\n    }\n\n    /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture?.destroy(true);\n        this.texture = null;\n        this.transform = null;\n        this.colorStops = [];\n        this.start = null;\n        this.end = null;\n        this.center = null;\n        this.outerCenter = null;\n    }\n\n    /**\n     * Returns a unique key for this gradient instance.\n     * This key is used for caching and texture management.\n     * @returns {string} Unique key for the gradient\n     */\n    public get styleKey(): string\n    {\n        return `fill-gradient-${this.uid}-${this._tick}`;\n    }\n}\n\nfunction addColorStops(gradient: CanvasGradient, colorStops: { offset: number, color: string }[]): void\n{\n    for (let i = 0; i < colorStops.length; i++)\n    {\n        const stop = colorStops[i];\n\n        gradient.addColorStop(stop.offset, stop.color);\n    }\n}\n\nfunction getCanvas(width: number, height: number): CanvasAndContext\n{\n    const canvas = DOMAdapter.get().createCanvas(width, height);\n    const context = canvas.getContext('2d');\n\n    return { canvas, context };\n}\n\n/**\n * Helper function to ensure consistent handling of gradient options.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureGradientOptions({\n *     start: { x: 0, y: 0 },\n *     end: { x: 100, y: 100 },\n *     textureSpace: 'local'\n * });\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureGradientOptions([0, 0, 100, 100, 'local']);\n * @param args - Arguments passed to gradient constructor\n * @returns Normalized gradient options object\n * @internal\n */\nfunction ensureGradientOptions(\n    args: any[],\n): GradientOptions\n{\n    let options = (args[0] ?? {}) as GradientOptions;\n\n    // @deprecated\n    if (typeof options === 'number' || args[1])\n    {\n        // #if _DEBUG\n        deprecation('8.5.2', `use options object instead`);\n        // #endif\n\n        options = {\n            type: 'linear',\n            start: { x: args[0], y: args[1] },\n            end: { x: args[2], y: args[3] },\n            textureSpace: args[4] as 'global' | 'local',\n            textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize\n        };\n    }\n\n    return options;\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { FillGradient } from '../fill/FillGradient';\n\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\n\n/**\n * Temporary matrix used for matrix calculations\n * @internal\n */\nconst tempTextureMatrix = new Matrix();\n\n/**\n * Temporary rectangle used for bounds calculations\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Generates a texture matrix for mapping textures onto shapes.\n * This function handles both local and global texture space mapping.\n *\n * In local space, the texture is mapped to fit exactly within the bounds of the shape.\n * In global space, the texture is mapped using its own dimensions and position.\n * @param out - The matrix to store the result in\n * @param style - The fill style containing texture and mapping properties\n * @param shape - The shape to map the texture onto\n * @param matrix - Optional transform matrix to apply\n * @returns The generated texture matrix for UV mapping\n * @example\n * ```ts\n * const matrix = new Matrix();\n * const textureMatrix = generateTextureMatrix(matrix, fillStyle, shape);\n * // textureMatrix now contains the proper UV mapping for the texture\n * ```\n * @internal\n */\nexport function generateTextureMatrix(out: Matrix, style: FillStyle | StrokeStyle, shape: ShapePrimitive, matrix?: Matrix)\n{\n    // Start with either the style's matrix inverted, or identity matrix\n    const textureMatrix = style.matrix\n        ? out.copyFrom(style.matrix).invert()\n        : out.identity();\n\n    if (style.textureSpace === 'local')\n    {\n        // For local space, map texture to shape's bounds\n        const bounds = shape.getBounds(tempRect);\n\n        if ((style as StrokeStyle).width)\n        {\n            bounds.pad((style as StrokeStyle).width);\n        }\n\n        const { x: tx, y: ty } = bounds;\n        const sx = 1 / bounds.width;\n        const sy = 1 / bounds.height;\n\n        const mTx = -tx * sx;\n        const mTy = -ty * sy;\n\n        const a1 = textureMatrix.a;\n        const b1 = textureMatrix.b;\n        const c1 = textureMatrix.c;\n        const d1 = textureMatrix.d;\n\n        textureMatrix.a *= sx;\n        textureMatrix.b *= sx;\n        textureMatrix.c *= sy;\n        textureMatrix.d *= sy;\n\n        textureMatrix.tx = (mTx * a1) + (mTy * c1) + textureMatrix.tx;\n        textureMatrix.ty = (mTx * b1) + (mTy * d1) + textureMatrix.ty;\n    }\n    else\n    {\n        // For global space, use texture's own dimensions\n        textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);\n        textureMatrix.scale(1 / (style.texture.source.width), 1 / (style.texture.source.height));\n    }\n\n    const sourceStyle = style.texture.source.style;\n\n    // we don't want to set the address mode if the fill is a gradient as this handles its own address mode\n    if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === 'clamp-to-edge')\n    {\n        sourceStyle.addressMode = 'repeat';\n        sourceStyle.update();\n    }\n\n    // Apply any additional transform matrix\n    if (matrix)\n    {\n        textureMatrix.append(tempTextureMatrix.copyFrom(matrix).invert());\n    }\n\n    return textureMatrix;\n}\n", "import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPixelLine } from '../buildCommands/buildPixelLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { generateTextureMatrix as generateTextureFillMatrix } from './generateTextureFillMatrix';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { Topology } from '../../../../rendering/renderers/shared/geometry/const';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { ShapePath, ShapePrimitiveWithHoles } from '../path/ShapePath';\n\n/**\n * A record of shape builders, keyed by shape type.\n * @category scene\n * @advanced\n */\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\nconst tempTextureMatrix = new Matrix();\n\n/**\n * @param context\n * @param gpuContext\n * @internal\n */\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);\n            }\n\n            if (hole)\n            {\n                // add the holes to the last shape primitive\n                shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;\n            }\n\n            addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    if (!build.build(rect, points))\n    {\n        return;\n    }\n\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const texture = data.image;\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) =>\n    {\n        const points: number[] = [];\n        const build = shapeBuilders[shape.type];\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n\n        if (!build.build(shape, points))\n        {\n            return;\n        }\n\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n        let topology: Topology = 'triangle-list';\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (holes)\n            {\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(holes);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            if (!lineStyle.pixelLine)\n            {\n                buildLine(points, lineStyle, false, close, vertices, indices);\n            }\n            else\n            {\n                buildPixelLine(points, close, vertices, indices);\n                topology = 'line-list';\n            }\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = generateTextureFillMatrix(tempTextureMatrix, style, shape, matrix);\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n        graphicsBatch.topology = topology;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(holePrimitives: ShapePrimitiveWithHoles[])\n{\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        if (holeBuilder.build(holePrimitive, holePoints))\n        {\n            holeArrays.push(holePoints);\n        }\n    }\n\n    return holeArrays;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @category rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: DefaultBatcher;\n    public instructions = new InstructionSet();\n\n    public init(maxTextures: number)\n    {\n        this.batcher = new DefaultBatcher({\n            maxTextures,\n        });\n\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // #if _DEBUG\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n        // #endif\n\n        return this.batcher.geometry;\n    }\n\n    public destroy()\n    {\n        this.batcher.destroy();\n        this.instructions.destroy();\n\n        this.batcher = null;\n        this.instructions = null;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @category rendering\n * @advanced\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @category rendering\n * @advanced\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuContextHash');\n        renderer.renderableGC.addManagedHash(this, '_graphicsDataContextHash');\n    }\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    /**\n     * Returns the render data for a given GraphicsContext.\n     * @param context - The GraphicsContext to get the render data for.\n     * @internal\n     */\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    /**\n     * Updates the GPU context for a given GraphicsContext.\n     * If the context is dirty, it will rebuild the batches and geometry data.\n     * @param context - The GraphicsContext to update.\n     * @returns The updated GpuGraphicsContext.\n     * @internal\n     */\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n            else\n            {\n                gpuContext.isBatchable = true;\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    /**\n     * Returns the GpuGraphicsContext for a given GraphicsContext.\n     * If it does not exist, it will initialize a new one.\n     * @param context - The GraphicsContext to get the GpuGraphicsContext for.\n     * @returns The GpuGraphicsContext for the given GraphicsContext.\n     * @internal\n     */\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData, {\n            maxTextures: this._renderer.limits.maxBatchableTextures,\n        });\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                batch.textures.textures,\n                batch.textures.count,\n                this._renderer.limits.maxBatchableTextures\n            );\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n", "import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    /** @internal */\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n", "/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n\n        this.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData\n{\n    public meshData?: MeshData;\n    public batchableMesh?: BatchableMesh;\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n\n/**\n * The data for the mesh\n * @internal\n */\ninterface MeshData\n{\n    /** if the mesh is batched or not */\n    batched: boolean;\n    /** the size of the index buffer */\n    indexSize: number;\n    /** the size of the vertex buffer */\n    vertexSize: number;\n}\n\n/** @internal */\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const meshData = this._getMeshData(mesh);\n\n        if (mesh.didViewUpdate)\n        {\n            meshData.indexSize = mesh._geometry.indices?.length;\n            meshData.vertexSize = mesh._geometry.positions?.length;\n        }\n\n        if (meshData.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: 0,\n            vertexSize: 0,\n        };\n\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = new BatchableMesh();\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n", "import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n", "/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n", "import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n", "import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions\n{\n    /** The size of the particle buffer, defaults to 1000. */\n    size: number;\n    /** A record of attributes that the particle container uses. */\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n", "var fragment = \"varying vec2 vUV;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uTexture;\\n\\nvoid main(void){\\n    vec4 color = texture2D(uTexture, vUV) * vColor;\\n    gl_FragColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=particles.frag.mjs.map\n", "var vertex = \"attribute vec2 aVertex;\\nattribute vec2 aUV;\\nattribute vec4 aColor;\\n\\nattribute vec2 aPosition;\\nattribute float aRotation;\\n\\nuniform mat3 uTranslationMatrix;\\nuniform float uRound;\\nuniform vec2 uResolution;\\nuniform vec4 uColor;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n\\nvec2 roundPixels(vec2 position, vec2 targetSize)\\n{       \\n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\nvoid main(void){\\n    float cosRotation = cos(aRotation);\\n    float sinRotation = sin(aRotation);\\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\\n\\n    vec2 v = vec2(x, y);\\n    v = v + aPosition;\\n\\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n    if(uRound == 1.0)\\n    {\\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\\n    }\\n\\n    vUV = aUV;\\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=particles.vert.mjs.map\n", "var wgsl = \"\\nstruct ParticleUniforms {\\n  uTranslationMatrix:mat3x3<f32>,\\n  uColor:vec4<f32>,\\n  uRound:f32,\\n  uResolution:vec2<f32>,\\n};\\n\\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\\n{\\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\\n}\\n\\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\\n\\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\\n@group(1) @binding(1) var uSampler : sampler;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) color : vec4<f32>,\\n  };\\n@vertex\\nfn mainVertex(\\n  @location(0) aVertex: vec2<f32>,\\n  @location(1) aPosition: vec2<f32>,\\n  @location(2) aUV: vec2<f32>,\\n  @location(3) aColor: vec4<f32>,\\n  @location(4) aRotation: f32,\\n) -> VSOutput {\\n  \\n   let v = vec2(\\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\\n   ) + aPosition;\\n\\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\\n\\n   if(uniforms.uRound == 1.0) {\\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\\n   }\\n\\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\\n\\n  return VSOutput(\\n   position,\\n   aUV,\\n   vColor,\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) color: vec4<f32>,\\n  @builtin(position) position: vec4<f32>,\\n) -> @location(0) vec4<f32> {\\n\\n    var sample = textureSample(uTexture, uSampler, uv) * color;\\n   \\n    return sample;\\n}\";\n\nexport { wgsl as default };\n//# sourceMappingURL=particles.wgsl.mjs.map\n", "import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\n/** @internal */\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ParticleContainer } from './ParticleContainer';\n\n/** @internal */\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    /** @internal */\n    public adaptor: ParticleContainerAdaptor;\n    /** @internal */\n    public readonly state = State.for2d();\n    /** @internal */\n    public readonly renderer: Renderer;\n\n    /** Local uniforms that are used for rendering particles. */\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        return renderable._gpuData[this.renderer.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        (this.renderer as null) = null;\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n", "import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n", "import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\nimport { type TextStyle, type TextStyleOptions } from '../TextStyle';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>)\n{\n    const { texture, bounds } = batchableSprite;\n    const padding = text._style._getFinalPadding();\n\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n\n    // First, calculate bounds using the full padded texture\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    // Then adjust by the padding amount to compensate for the buffer zone\n    // This shifts the render position back by the padding amount, ensuring the text\n    // appears exactly where intended while maintaining the buffer zone around it.\n    const paddingOffset = text._anchor._x * padding * 2;\n    const paddingOffsetY = text._anchor._y * padding * 2;\n\n    bounds.minX -= padding - paddingOffset;\n    bounds.minY -= padding - paddingOffsetY;\n    bounds.maxX -= padding - paddingOffset;\n    bounds.maxY -= padding - paddingOffsetY;\n}\n", "import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n", "import { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class BatchableText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public currentKey: string;\n\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    public resolutionChange()\n    {\n        const text = this.renderable as Text;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    public destroy()\n    {\n        const { canvasText } = this._renderer;\n        const refCount = canvasText.getReferenceCount(this.currentKey);\n\n        if (refCount > 0)\n        {\n            canvasText.decreaseReferenceCount(this.currentKey);\n        }\n        else if (this.texture)\n        {\n            canvasText.returnTexture(this.texture);\n        }\n\n        this._renderer.runners.resolutionChange.remove(this);\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateTextBounds } from '../utils/updateTextBounds';\nimport { BatchableText } from './BatchableText';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text.styleKey;\n\n        if (gpuText.currentKey !== newKey) return true;\n\n        return text._didTextUpdate;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (text._didTextUpdate)\n        {\n            const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n            if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(text);\n            }\n\n            text._didTextUpdate = false;\n\n            updateTextBounds(batchableText, text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        batchableText._batcher.updateElement(batchableText);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (batchableText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n        }\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n        batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n        batchableText.currentKey = text.styleKey;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const batchableText = new BatchableText(this._renderer);\n\n        batchableText.currentKey = '--';\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableText.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        text._gpuData[this._renderer.uid] = batchableText;\n\n        return batchableText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { WRAP_MODE } from '../../../../rendering/renderers/shared/texture/const';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\n\n/**\n * Defines the repetition modes for fill patterns.\n *\n * - `repeat`: The pattern repeats in both directions.\n * - `repeat-x`: The pattern repeats horizontally only.\n * - `repeat-y`: The pattern repeats vertically only.\n * - `no-repeat`: The pattern does not repeat.\n * @category scene\n * @standard\n */\nexport type PatternRepetition = 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n\nconst repetitionMap = {\n    repeat: {\n        addressModeU: 'repeat',\n        addressModeV: 'repeat',\n    },\n    'repeat-x': {\n        addressModeU: 'repeat',\n        addressModeV: 'clamp-to-edge',\n    },\n    'repeat-y': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'repeat',\n    },\n    'no-repeat': {\n        addressModeU: 'clamp-to-edge',\n        addressModeV: 'clamp-to-edge',\n    },\n};\n\n/**\n * A class that represents a fill pattern for use in Text and Graphics fills.\n * It allows for textures to be used as patterns, with optional repetition modes.\n * @category scene\n * @standard\n * @example\n * const txt = await Assets.load('https://pixijs.com/assets/bg_scene_rotate.jpg');\n * const pat = new FillPattern(txt, 'repeat');\n *\n * const textPattern = new Text({\n *     text: 'PixiJS',\n *     style: {\n *         fontSize: 36,\n *         fill: 0xffffff,\n *         stroke: { fill: pat, width: 10 },\n *     },\n * });\n *\n * textPattern.y = (textGradient.height);\n */\nexport class FillPattern implements CanvasPattern\n{\n    /**\n     * unique id for this fill pattern\n     * @internal\n     */\n    public readonly uid: number = uid('fillPattern');\n    /**\n     * Internal tick counter to track changes in the pattern.\n     * This is used to invalidate the pattern when the texture or transform changes.\n     * @internal\n     */\n    public _tick: number = 0;\n    /** @internal */\n    public _texture: Texture;\n    /** The transform matrix applied to the pattern */\n    public transform = new Matrix();\n\n    constructor(texture: Texture, repetition?: PatternRepetition)\n    {\n        this.texture = texture;\n\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        if (repetition)\n        {\n            texture.source.style.addressModeU = repetitionMap[repetition].addressModeU as WRAP_MODE;\n            texture.source.style.addressModeV = repetitionMap[repetition].addressModeV as WRAP_MODE;\n        }\n    }\n\n    /**\n     * Sets the transform for the pattern\n     * @param transform - The transform matrix to apply to the pattern.\n     * If not provided, the pattern will use the default transform.\n     */\n    public setTransform(transform?: Matrix): void\n    {\n        const texture = this.texture;\n\n        this.transform.copyFrom(transform);\n        this.transform.invert();\n        //  transform.scale\n        this.transform.scale(\n            1 / texture.frame.width,\n            1 / texture.frame.height\n        );\n\n        this._tick++;\n    }\n\n    /** Internal texture used to render the gradient */\n    public get texture()\n    {\n        return this._texture;\n    }\n    public set texture(value: Texture)\n    {\n        if (this._texture === value) return;\n\n        this._texture = value;\n        this._tick++;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `fill-pattern-${this.uid}-${this._tick}`;\n    }\n\n    /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */\n    public destroy(): void\n    {\n        this.texture.destroy(true);\n        this.texture = null;\n    }\n}\n", "\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n", "import parse from 'parse-svg-path';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { GraphicsPath } from '../path/GraphicsPath';\n\ninterface SubPath\n{\n    startX: number;\n    startY: number;\n}\n\n/**\n * Parses an SVG path data string and builds a GraphicsPath object from the commands.\n * This function handles all standard SVG path commands including moves, lines, curves and arcs.\n * It maintains state for the current position and subpaths to properly handle relative commands\n * and path closures.\n *\n * Supported SVG commands:\n * - M/m: Move to absolute/relative\n * - L/l: Line to absolute/relative\n * - H/h: Horizontal line absolute/relative\n * - V/v: Vertical line absolute/relative\n * - C/c: Cubic bezier curve absolute/relative\n * - S/s: Smooth cubic bezier curve absolute/relative\n * - Q/q: Quadratic bezier curve absolute/relative\n * - T/t: Smooth quadratic bezier curve absolute/relative\n * - A/a: Arc absolute/relative\n * - Z/z: Close path\n * @param svgPath - The SVG path data string to parse (e.g. \"M0,0 L100,100\")\n * @param path - The GraphicsPath object to build the path into\n * @returns The input path object with the SVG commands applied\n * @internal\n */\nexport function parseSVGPath(svgPath: string, path: GraphicsPath): GraphicsPath\n{\n    // Parse the SVG path string into an array of commands\n    const commands = parse(svgPath);\n\n    // Track subpaths for proper path closure handling\n    const subpaths: SubPath[] = [];\n    let currentSubPath: SubPath | null = null;\n\n    // Track current position for relative commands\n    let lastX = 0;\n    let lastY = 0;\n\n    // Process each command in sequence\n    for (let i = 0; i < commands.length; i++)\n    {\n        const command = commands[i];\n        const type = command[0]; // The command letter\n        const data = command; // The command parameters, 1-based indexed\n\n        switch (type)\n        {\n            case 'M': // Move To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'm': // Move To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.moveTo(lastX, lastY);\n                break;\n            case 'H': // Horizontal Line To (absolute)\n                lastX = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'h': // Horizontal Line To (relative)\n                lastX += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'V': // Vertical Line To (absolute)\n                lastY = data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'v': // Vertical Line To (relative)\n                lastY += data[1];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'L': // Line To (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'l': // Line To (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.lineTo(lastX, lastY);\n                break;\n            case 'C': // Cubic Bezier Curve (absolute)\n                lastX = data[5];\n                lastY = data[6];\n\n                path.bezierCurveTo(\n                    data[1], data[2], // First control point\n                    data[3], data[4], // Second control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'c': // Cubic Bezier Curve (relative)\n                path.bezierCurveTo(\n                    lastX + data[1], lastY + data[2], // First control point\n                    lastX + data[3], lastY + data[4], // Second control point\n                    lastX + data[5], lastY + data[6] // End point\n                );\n\n                lastX += data[5];\n                lastY += data[6];\n                break;\n            case 'S': // Smooth Cubic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.bezierCurveToShort(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 's': // Smooth Cubic Bezier Curve (relative)\n                path.bezierCurveToShort(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4], // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'Q': // Quadratic Bezier Curve (absolute)\n                lastX = data[3];\n                lastY = data[4];\n\n                path.quadraticCurveTo(\n                    data[1], data[2], // Control point\n                    lastX, lastY // End point\n                );\n                break;\n            case 'q': // Quadratic Bezier Curve (relative)\n                path.quadraticCurveTo(\n                    lastX + data[1], lastY + data[2], // Control point\n                    lastX + data[3], lastY + data[4] // End point\n                );\n\n                lastX += data[3];\n                lastY += data[4];\n                break;\n            case 'T': // Smooth Quadratic Bezier Curve (absolute)\n                lastX = data[1];\n                lastY = data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 't': // Smooth Quadratic Bezier Curve (relative)\n                lastX += data[1];\n                lastY += data[2];\n\n                path.quadraticCurveToShort(\n                    lastX, lastY // End point\n                );\n                break;\n            case 'A': // Arc (absolute)\n                lastX = data[6];\n                lastY = data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'a': // Arc (relative)\n                lastX += data[6];\n                lastY += data[7];\n\n                path.arcToSvg(\n                    data[1], // rx\n                    data[2], // ry\n                    data[3], // x-axis-rotation\n                    data[4], // large-arc-flag\n                    data[5], // sweep-flag\n                    lastX, lastY // End point\n                );\n                break;\n            case 'Z': // Close Path\n            case 'z':\n                path.closePath();\n                if (subpaths.length > 0)\n                {\n                    // Return to the start of the current subpath\n                    currentSubPath = subpaths.pop();\n                    if (currentSubPath)\n                    {\n                        lastX = currentSubPath.startX;\n                        lastY = currentSubPath.startY;\n                    }\n                    else\n                    {\n                        lastX = 0;\n                        lastY = 0;\n                    }\n                }\n                currentSubPath = null;\n                break;\n            default:\n                // #if _DEBUG\n                warn(`Unknown SVG path command: ${type}`);\n                // #endif\n        }\n\n        // Track subpath starts for path closure\n        if (type !== 'Z' && type !== 'z')\n        {\n            if (currentSubPath === null)\n            {\n                currentSubPath = { startX: lastX, startY: lastY };\n                subpaths.push(currentSubPath);\n            }\n        }\n    }\n\n    return path;\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Circle object represents a circle shape in a two-dimensional coordinate system.\n * Used for drawing graphics and specifying hit areas for containers.\n * @example\n * ```ts\n * // Basic circle creation\n * const circle = new Circle(100, 100, 50);\n *\n * // Use as hit area\n * container.hitArea = new Circle(0, 0, 100);\n *\n * // Check point containment\n * const isInside = circle.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = circle.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and radius\n * - Supports point containment tests\n * - Can check stroke intersections\n * @see {@link Rectangle} For rectangular shapes\n * @category maths\n * @standard\n */\nexport class Circle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const circle = new Circle();\n     * circle.x = 100;\n     *\n     * // Center circle on point\n     * circle.x = point.x;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this circle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const circle = new Circle();\n     * circle.y = 200;\n     *\n     * // Center circle on point\n     * circle.y = point.y;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The radius of the circle\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const circle = new Circle(100, 100);\n     * circle.radius = 50;\n     *\n     * // Calculate area\n     * const area = Math.PI * circle.radius * circle.radius;\n     * ```\n     * @default 0\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks.\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Circle(0, 0, 50);\n     * console.log(shape.type); // 'circle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'circle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @remarks\n     * - Used for shape type checking\n     * - More efficient than instanceof\n     * - Read-only property\n     * @readonly\n     * @default 'circle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     * @see {@link ShapePrimitive} For shape interface\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'circle';\n\n    /**\n     * @param x - The X coordinate of the center of this circle\n     * @param y - The Y coordinate of the center of this circle\n     * @param radius - The radius of the circle\n     */\n    constructor(x = 0, y = 0, radius = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.radius = radius;\n    }\n\n    /**\n     * Creates a clone of this Circle instance.\n     * @example\n     * ```ts\n     * // Basic circle cloning\n     * const original = new Circle(100, 100, 50);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 75;\n     *\n     * // Verify independence\n     * console.log(original.radius); // 50\n     * console.log(modified.radius); // 75\n     * ```\n     * @returns A copy of the Circle\n     * @see {@link Circle.copyFrom} For copying into existing circle\n     * @see {@link Circle.copyTo} For copying to another circle\n     */\n    public clone(): Circle\n    {\n        return new Circle(this.x, this.y, this.radius);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle.\n     *\n     * Uses the distance formula to determine if a point is inside the circle's radius.\n     *\n     * Commonly used for hit testing in PixiJS events and graphics.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const circle = new Circle(100, 100, 50);\n     * const isInside = circle.contains(120, 120);\n     *\n     * // Check mouse position\n     * const circle = new Circle(0, 0, 100);\n     * container.hitArea = circle;\n     * container.on('pointermove', (e) => {\n     *     // only called if pointer is within circle\n     * });\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Circle\n     * @see {@link Circle.strokeContains} For checking stroke intersection\n     * @see {@link Circle.getBounds} For getting bounding box\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.radius <= 0) return false;\n\n        const r2 = this.radius * this.radius;\n        let dx = (this.x - x);\n        let dy = (this.y - y);\n\n        dx *= dx;\n        dy *= dy;\n\n        return (dx + dy <= r2);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this circle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const circle = new Circle(100, 100, 50);\n     * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param width - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this Circle's stroke\n     * @see {@link Circle.contains} For checking fill containment\n     * @see {@link Circle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, width: number, alignment: number = 0.5): boolean\n    {\n        if (this.radius === 0) return false;\n\n        const dx = (this.x - x);\n        const dy = (this.y - y);\n        const radius = this.radius;\n        const outerWidth = (1 - alignment) * width;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n        return (distance <= radius + outerWidth && distance > radius - (width - outerWidth));\n    }\n\n    /**\n     * Returns the framing rectangle of the circle as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const circle = new Circle(100, 100, 50);\n     * const bounds = circle.getBounds();\n     * // bounds: x=50, y=50, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * circle.getBounds(rect);\n     * ```\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Circle.contains} For point containment\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.radius;\n        out.y = this.y - this.radius;\n        out.width = this.radius * 2;\n        out.height = this.radius * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another circle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * target.copyFrom(source);\n     * ```\n     * @param circle - The circle to copy from\n     * @returns Returns itself\n     * @see {@link Circle.copyTo} For copying to another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyFrom(circle: Circle): this\n    {\n        this.x = circle.x;\n        this.y = circle.y;\n        this.radius = circle.radius;\n\n        return this;\n    }\n\n    /**\n     * Copies this circle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Circle(100, 100, 50);\n     * const target = new Circle();\n     * source.copyTo(target);\n     * ```\n     * @param circle - The circle to copy to\n     * @returns Returns given parameter\n     * @see {@link Circle.copyFrom} For copying from another circle\n     * @see {@link Circle.clone} For creating new circle copy\n     */\n    public copyTo(circle: Circle): Circle\n    {\n        circle.copyFrom(this);\n\n        return circle;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;\n    }\n    // #endif\n}\n", "import { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\n/**\n * The Ellipse object is used to help draw graphics and can also be used to specify a hit area for containers.\n * @example\n * ```ts\n * // Basic ellipse creation\n * const ellipse = new Ellipse(100, 100, 20, 10);\n *\n * // Use as a hit area\n * container.hitArea = new Ellipse(0, 0, 50, 25);\n *\n * // Check point containment\n * const isInside = ellipse.contains(mouseX, mouseY);\n *\n * // Get bounding box\n * const bounds = ellipse.getBounds();\n * ```\n * @remarks\n * - Defined by center (x,y) and half dimensions\n * - Total width = halfWidth * 2\n * - Total height = halfHeight * 2\n * @see {@link Rectangle} For rectangular shapes\n * @see {@link Circle} For circular shapes\n * @category maths\n * @standard\n */\nexport class Ellipse implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic x position\n     * const ellipse = new Ellipse();\n     * ellipse.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the center of this ellipse\n     * @example\n     * ```ts\n     * // Basic y position\n     * const ellipse = new Ellipse();\n     * ellipse.y = 200;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The half width of this ellipse\n     * @example\n     * ```ts\n     * // Set half width\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfWidth = 50; // Total width will be 100\n     * ```\n     * @default 0\n     */\n    public halfWidth: number;\n\n    /**\n     * The half height of this ellipse\n     * @example\n     * ```ts\n     * // Set half height\n     * const ellipse = new Ellipse(100, 100);\n     * ellipse.halfHeight = 25; // Total height will be 50\n     * ```\n     * @default 0\n     */\n    public halfHeight: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Ellipse(0, 0, 50, 25);\n     * console.log(shape.type); // 'ellipse'\n     *\n     * // Use in type guards\n     * if (shape.type === 'ellipse') {\n     *     console.log(shape.halfWidth, shape.halfHeight);\n     * }\n     * ```\n     * @readonly\n     * @default 'ellipse'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type = 'ellipse';\n\n    /**\n     * @param x - The X coordinate of the center of this ellipse\n     * @param y - The Y coordinate of the center of this ellipse\n     * @param halfWidth - The half width of this ellipse\n     * @param halfHeight - The half height of this ellipse\n     */\n    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0)\n    {\n        this.x = x;\n        this.y = y;\n        this.halfWidth = halfWidth;\n        this.halfHeight = halfHeight;\n    }\n\n    /**\n     * Creates a clone of this Ellipse instance.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Ellipse(100, 100, 50, 25);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.halfWidth *= 2;\n     * modified.halfHeight *= 2;\n     *\n     * // Verify independence\n     * console.log(original.halfWidth);  // 50\n     * console.log(modified.halfWidth);  // 100\n     * ```\n     * @returns A copy of the ellipse\n     * @see {@link Ellipse.copyFrom} For copying into existing ellipse\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     */\n    public clone(): Ellipse\n    {\n        return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse.\n     * Uses normalized coordinates and the ellipse equation to determine containment.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isInside = ellipse.contains(120, 110);\n     * ```\n     * @remarks\n     * - Uses ellipse equation (x²/a² + y²/b² ≤ 1)\n     * - Returns false if dimensions are 0 or negative\n     * - Normalized to center (0,0) for calculation\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coords are within this ellipse\n     * @see {@link Ellipse.strokeContains} For checking stroke intersection\n     * @see {@link Ellipse.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.halfWidth <= 0 || this.halfHeight <= 0)\n        {\n            return false;\n        }\n\n        // normalize the coords to an ellipse with center 0,0\n        let normx = ((x - this.x) / this.halfWidth);\n        let normy = ((y - this.y) / this.halfHeight);\n\n        normx *= normx;\n        normy *= normy;\n\n        return (normx + normy <= 1);\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this ellipse including stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @remarks\n     * - Uses normalized ellipse equations\n     * - Considers stroke alignment\n     * - Returns false if dimensions are 0\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coords are within this ellipse's stroke\n     * @see {@link Ellipse.contains} For checking fill containment\n     * @see {@link Ellipse.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { halfWidth, halfHeight } = this;\n\n        if (halfWidth <= 0 || halfHeight <= 0)\n        {\n            return false;\n        }\n\n        const strokeOuterWidth = strokeWidth * (1 - alignment);\n        const strokeInnerWidth = strokeWidth - strokeOuterWidth;\n\n        const innerHorizontal = halfWidth - strokeInnerWidth;\n        const innerVertical = halfHeight - strokeInnerWidth;\n\n        const outerHorizontal = halfWidth + strokeOuterWidth;\n        const outerVertical = halfHeight + strokeOuterWidth;\n\n        const normalizedX = x - this.x;\n        const normalizedY = y - this.y;\n\n        const innerEllipse = ((normalizedX * normalizedX) / (innerHorizontal * innerHorizontal))\n            + ((normalizedY * normalizedY) / (innerVertical * innerVertical));\n\n        const outerEllipse = ((normalizedX * normalizedX) / (outerHorizontal * outerHorizontal))\n            + ((normalizedY * normalizedY) / (outerVertical * outerVertical));\n\n        return innerEllipse > 1 && outerEllipse <= 1;\n    }\n\n    /**\n     * Returns the framing rectangle of the ellipse as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const ellipse = new Ellipse(100, 100, 50, 25);\n     * const bounds = ellipse.getBounds();\n     * // bounds: x=50, y=75, width=100, height=50\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * ellipse.getBounds(rect);\n     * ```\n     * @remarks\n     * - Creates Rectangle if none provided\n     * - Top-left is (x-halfWidth, y-halfHeight)\n     * - Width is halfWidth * 2\n     * - Height is halfHeight * 2\n     * @param out - Optional Rectangle object to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Ellipse.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x - this.halfWidth;\n        out.y = this.y - this.halfHeight;\n        out.width = this.halfWidth * 2;\n        out.height = this.halfHeight * 2;\n\n        return out;\n    }\n\n    /**\n     * Copies another ellipse to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * target.copyFrom(source);\n     * ```\n     * @param ellipse - The ellipse to copy from\n     * @returns Returns itself\n     * @see {@link Ellipse.copyTo} For copying to another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyFrom(ellipse: Ellipse): this\n    {\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        this.halfWidth = ellipse.halfWidth;\n        this.halfHeight = ellipse.halfHeight;\n\n        return this;\n    }\n\n    /**\n     * Copies this ellipse to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Ellipse(100, 100, 50, 25);\n     * const target = new Ellipse();\n     * source.copyTo(target);\n     * ```\n     * @param ellipse - The ellipse to copy to\n     * @returns Returns given parameter\n     * @see {@link Ellipse.copyFrom} For copying from another ellipse\n     * @see {@link Ellipse.clone} For creating new ellipse copy\n     */\n    public copyTo(ellipse: Ellipse): Ellipse\n    {\n        ellipse.copyFrom(this);\n\n        return ellipse;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;\n    }\n    // #endif\n}\n", "/**\n * Calculates the squared distance from a point to a line segment defined by two endpoints.\n * @param x - x coordinate of the point\n * @param y - y coordinate of the point\n * @param x1 - x coordinate of the first endpoint of the line segment\n * @param y1 - y coordinate of the first endpoint of the line segment\n * @param x2 - x coordinate of the second endpoint of the line segment\n * @param y2 - y coordinate of the second endpoint of the line segment\n * @returns The squared distance from the point to the line segment\n * @category maths\n * @internal\n */\nexport function squaredDistanceToLineSegment(\n    x: number, y: number,\n    x1: number, y1: number,\n    x2: number, y2: number\n): number\n{\n    const a = x - x1;\n    const b = y - y1;\n    const c = x2 - x1;\n    const d = y2 - y1;\n\n    const dot = (a * c) + (b * d);\n    const lenSq = (c * c) + (d * d);\n    let param = -1;\n\n    if (lenSq !== 0)\n    {\n        param = dot / lenSq;\n    }\n\n    let xx; let\n        yy;\n\n    if (param < 0)\n    {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1)\n    {\n        xx = x2;\n        yy = y2;\n    }\n\n    else\n    {\n        xx = x1 + (param * c);\n        yy = y1 + (param * d);\n    }\n\n    const dx = x - xx;\n    const dy = y - yy;\n\n    return (dx * dx) + (dy * dy);\n}\n", "import { deprecation } from '../../utils/logging/deprecation';\nimport { squaredDistanceToLineSegment } from '../misc/squaredDistanceToLineSegment';\nimport { Rectangle } from './Rectangle';\n\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { PointData } from '../point/PointData';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nlet tempRect: Rectangle;\nlet tempRect2: Rectangle;\n\n/**\n * A class to define a shape via user defined coordinates.\n * Used for creating complex shapes and hit areas with custom points.\n * @example\n * ```ts\n * // Create polygon from array of points\n * const polygon1 = new Polygon([\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * ]);\n *\n * // Create from array of coordinates\n * const polygon2 = new Polygon([0, 0, 0, 100, 100, 100]);\n *\n * // Create from sequence of points\n * const polygon3 = new Polygon(\n *     new Point(0, 0),\n *     new Point(0, 100),\n *     new Point(100, 100)\n * );\n *\n * // Create from sequence of coordinates\n * const polygon4 = new Polygon(0, 0, 0, 100, 100, 100);\n *\n * // Use as container hit area\n * container.hitArea = new Polygon([0, 0, 100, 0, 50, 100]);\n * ```\n * @see {@link Point} For point objects used in construction\n * @category maths\n * @standard\n */\nexport class Polygon implements ShapePrimitive\n{\n    /**\n     * An array of the points of this polygon stored as a flat array of numbers.\n     * @example\n     * ```ts\n     * // Access points directly\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.points); // [0, 0, 100, 0, 50, 100]\n     *\n     * // Modify points\n     * polygon.points[0] = 10; // Move first x coordinate\n     * polygon.points[1] = 10; // Move first y coordinate\n     * ```\n     * @remarks\n     * - Stored as [x1, y1, x2, y2, ...]\n     * - Each pair represents a vertex\n     * - Length is always even\n     * - Can be modified directly\n     */\n    public points: number[];\n\n    /**\n     * Indicates if the polygon path is closed.\n     * @example\n     * ```ts\n     * // Create open polygon\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * polygon.closePath = false;\n     *\n     * // Check path state\n     * if (polygon.closePath) {\n     *     // Last point connects to first\n     * }\n     * ```\n     * @remarks\n     * - True by default\n     * - False after moveTo\n     * - True after closePath\n     * @default true\n     */\n    public closePath: boolean;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(shape.type); // 'polygon'\n     *\n     * // Use in type guards\n     * if (shape.type === 'polygon') {\n     *     // TypeScript knows this is a Polygon\n     *     console.log(shape.points.length);\n     * }\n     * ```\n     * @readonly\n     * @default 'polygon'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'polygon';\n\n    constructor(points: PointData[] | number[]);\n    constructor(...points: PointData[] | number[]);\n    /**\n     * @param points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points: (PointData[] | number[])[] | PointData[] | number[])\n    {\n        let flat = Array.isArray(points[0]) ? points[0] : points;\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (typeof flat[0] !== 'number')\n        {\n            const p: number[] = [];\n\n            for (let i = 0, il = flat.length; i < il; i++)\n            {\n                p.push((flat[i] as PointData).x, (flat[i] as PointData).y);\n            }\n\n            flat = p;\n        }\n\n        this.points = flat as number[];\n\n        this.closePath = true;\n    }\n\n    /**\n     * Determines whether the polygon's points are arranged in a clockwise direction.\n     * Uses the shoelace formula (surveyor's formula) to calculate the signed area.\n     *\n     * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n     *\n     * The formula sums up the cross products of adjacent vertices:\n     * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n     * The final sum divided by 2 gives the signed area - positive for clockwise.\n     * @example\n     * ```ts\n     * // Check polygon winding\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * console.log(polygon.isClockwise()); // Check direction\n     *\n     * // Use in path construction\n     * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);\n     * if (hole.isClockwise() === shape.isClockwise()) {\n     *     hole.points.reverse(); // Reverse for proper hole winding\n     * }\n     * ```\n     * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n     */\n    public isClockwise(): boolean\n    {\n        let area = 0;\n        const points = this.points;\n        const length = points.length;\n\n        for (let i = 0; i < length; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % length];\n            const y2 = points[(i + 3) % length];\n\n            area += (x2 - x1) * (y2 + y1);\n        }\n\n        return area < 0;\n    }\n\n    /**\n     * Checks if this polygon completely contains another polygon.\n     * Used for detecting holes in shapes, like when parsing SVG paths.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n     * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n     *\n     * outerSquare.containsPolygon(innerSquare); // Returns true\n     * innerSquare.containsPolygon(outerSquare); // Returns false\n     * ```\n     * @remarks\n     * - Uses bounds check for quick rejection\n     * - Tests all points for containment\n     * @param polygon - The polygon to test for containment\n     * @returns True if this polygon completely contains the other polygon\n     * @see {@link Polygon.contains} For single point testing\n     * @see {@link Polygon.getBounds} For bounds calculation\n     */\n    public containsPolygon(polygon: Polygon): boolean\n    {\n    // Quick early-out: bounds check\n        const thisBounds = this.getBounds(tempRect);\n        const otherBounds = polygon.getBounds(tempRect2);\n\n        if (!thisBounds.containsRect(otherBounds))\n        {\n            return false; // If bounds aren't contained, the polygon cannot be a hole\n        }\n\n        // Full point containment check\n        const points = polygon.points;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            // Combine bounds and polygon checks for efficiency\n            if (!this.contains(x, y))\n            {\n                return false;\n            }\n        }\n\n        return true; // All points are contained within bounds and polygon\n    }\n\n    /**\n     * Creates a clone of this polygon.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.points[0] = 10; // Modify first x coordinate\n     * ```\n     * @returns A copy of the polygon\n     * @see {@link Polygon.copyFrom} For copying into existing polygon\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     */\n    public clone(): Polygon\n    {\n        const points = this.points.slice();\n        const polygon = new Polygon(points);\n\n        polygon.closePath = this.closePath;\n\n        return polygon;\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n     * Uses raycasting algorithm for point-in-polygon testing.\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isInside = polygon.contains(25, 25); // true\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this polygon\n     * @see {@link Polygon.strokeContains} For checking stroke intersection\n     * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing\n     */\n    public contains(x: number, y: number): boolean\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside\n     * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered\n     * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside\n     * ```\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this polygon's stroke\n     * @see {@link Polygon.contains} For checking fill containment\n     * @see {@link Polygon.getBounds} For getting stroke bounds\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment = 0.5): boolean\n    {\n        const strokeWidthSquared = strokeWidth * strokeWidth;\n        const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n        const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n\n        const { points } = this;\n        const iterationLength = points.length - (this.closePath ? 0 : 2);\n\n        for (let i = 0; i < iterationLength; i += 2)\n        {\n            const x1 = points[i];\n            const y1 = points[i + 1];\n            const x2 = points[(i + 2) % points.length];\n            const y2 = points[(i + 3) % points.length];\n\n            const distanceSquared = squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n\n            const sign = Math.sign(((x2 - x1) * (y - y1)) - ((y2 - y1) * (x - x1)));\n\n            if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the framing rectangle of the polygon as a Rectangle object.\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const bounds = polygon.getBounds();\n     * // bounds: x=0, y=0, width=100, height=100\n     *\n     * // Reuse existing rectangle\n     * const rect = new Rectangle();\n     * polygon.getBounds(rect);\n     * ```\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link Polygon.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        const points = this.points;\n\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        for (let i = 0, n = points.length; i < n; i += 2)\n        {\n            const x = points[i];\n            const y = points[i + 1];\n\n            minX = x < minX ? x : minX;\n            maxX = x > maxX ? x : maxX;\n\n            minY = y < minY ? y : minY;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        out.x = minX;\n        out.width = maxX - minX;\n\n        out.y = minY;\n        out.height = maxY - minY;\n\n        return out;\n    }\n\n    /**\n     * Copies another polygon to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * target.copyFrom(source);\n     * ```\n     * @param polygon - The polygon to copy from\n     * @returns Returns itself\n     * @see {@link Polygon.copyTo} For copying to another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyFrom(polygon: Polygon): this\n    {\n        this.points = polygon.points.slice();\n        this.closePath = polygon.closePath;\n\n        return this;\n    }\n\n    /**\n     * Copies this polygon to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new Polygon([0, 0, 100, 0, 50, 100]);\n     * const target = new Polygon();\n     * source.copyTo(target);\n     * ```\n     * @param polygon - The polygon to copy to\n     * @returns Returns given parameter\n     * @see {@link Polygon.copyFrom} For copying from another polygon\n     * @see {@link Polygon.clone} For creating new polygon copy\n     */\n    public copyTo(polygon: Polygon): Polygon\n    {\n        polygon.copyFrom(this);\n\n        return polygon;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Polygon`\n            + `closeStroke=${this.closePath}`\n            + `points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, '')}]`;\n    }\n    // #endif\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastX); // 300\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the last vertex\n     * @see {@link Polygon.lastY} For last Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastX(): number\n    {\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.lastY); // 400\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the last vertex\n     * @see {@link Polygon.lastX} For last X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get lastY(): number\n    {\n        return this.points[this.points.length - 1];\n    }\n\n    /**\n     * Get the last X coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.\n     */\n    get x(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.lastX is deprecated, please use Polygon.lastX instead.');\n        // #endif\n\n        return this.points[this.points.length - 2];\n    }\n\n    /**\n     * Get the last Y coordinate of the polygon.\n     * @readonly\n     * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.\n     */\n    get y(): number\n    {\n        // #if _DEBUG\n        deprecation('8.11.0', 'Polygon.y is deprecated, please use Polygon.lastY instead.');\n        // #endif\n\n        return this.points[this.points.length - 1];\n    }\n    /**\n     * Get the first X coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.x); // 0\n     * ```\n     * @readonly\n     * @returns The x-coordinate of the first vertex\n     * @see {@link Polygon.startY} For first Y coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startX(): number\n    {\n        return this.points[0];\n    }\n\n    /**\n     * Get the first Y coordinate of the polygon.\n     * @example\n     * ```ts\n     * // Basic coordinate access\n     * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);\n     * console.log(polygon.y); // 0\n     * ```\n     * @readonly\n     * @returns The y-coordinate of the first vertex\n     * @see {@link Polygon.startX} For first X coordinate\n     * @see {@link Polygon.points} For raw points array\n     */\n    get startY(): number\n    {\n        return this.points[1];\n    }\n}\n\n", "import { type SHAPE_PRIMITIVE } from '../misc/const';\nimport { Rectangle } from './Rectangle';\n\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst isCornerWithinStroke = (\n    pX: number,\n    pY: number,\n    cornerX: number,\n    cornerY: number,\n    radius: number,\n    strokeWidthInner: number,\n    strokeWidthOuter: number\n) =>\n{\n    const dx = pX - cornerX;\n    const dy = pY - cornerY;\n    const distance = Math.sqrt((dx * dx) + (dy * dy));\n\n    return distance >= radius - strokeWidthInner && distance <= radius + strokeWidthOuter;\n};\n\n/**\n * The `RoundedRectangle` object represents a rectangle with rounded corners.\n * Defined by position, dimensions and corner radius.\n * @example\n * ```ts\n * // Basic rectangle creation\n * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n * // Use as container hit area\n * container.hitArea = new RoundedRectangle(0, 0, 100, 100, 10);\n * // Check point containment\n * const isInside = rect.contains(mouseX, mouseY);\n * // Get bounds\n * const bounds = rect.getBounds();\n * ```\n * @remarks\n * - Position defined by top-left corner\n * - Radius clamped to half smallest dimension\n * - Common in UI elements\n * @see {@link Rectangle} For non-rounded rectangles\n * @category maths\n * @standard\n */\nexport class RoundedRectangle implements ShapePrimitive\n{\n    /**\n     * The X coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic x position\n     * const rect = new RoundedRectangle();\n     * rect.x = 100;\n     * ```\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rounded rectangle\n     * @example\n     * ```ts\n     * // Basic y position\n     * const rect = new RoundedRectangle();\n     * rect.y = 100;\n     * ```\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic width setting\n     * const rect = new RoundedRectangle();\n     * rect.width = 200; // Total width will be 200\n     * ```\n     * @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rounded rectangle\n     * @example\n     * ```ts\n     * // Basic height setting\n     * const rect = new RoundedRectangle();\n     * rect.height = 150; // Total height will be 150\n     * ```\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * Controls the radius of the rounded corners\n     * @example\n     * ```ts\n     * // Basic radius setting\n     * const rect = new RoundedRectangle(0, 0, 200, 150);\n     * rect.radius = 20;\n     *\n     * // Clamp to maximum safe radius\n     * rect.radius = Math.min(rect.width, rect.height) / 2;\n     *\n     * // Create pill shape\n     * rect.radius = rect.height / 2;\n     * ```\n     * @remarks\n     * - Automatically clamped to half of smallest dimension\n     * - Common values: 0-20 for UI elements\n     * - Higher values create more rounded corners\n     * @default 20\n     */\n    public radius: number;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @example\n     * ```ts\n     * // Check shape type\n     * const shape = new RoundedRectangle(0, 0, 100, 100, 20);\n     * console.log(shape.type); // 'roundedRectangle'\n     *\n     * // Use in type guards\n     * if (shape.type === 'roundedRectangle') {\n     *     console.log(shape.radius);\n     * }\n     * ```\n     * @readonly\n     * @default 'roundedRectangle'\n     * @see {@link SHAPE_PRIMITIVE} For all shape types\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'roundedRectangle';\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rounded rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rounded rectangle\n     * @param width - The overall width of this rounded rectangle\n     * @param height - The overall height of this rounded rectangle\n     * @param radius - Controls the radius of the rounded corners\n     */\n    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.radius = radius;\n    }\n\n    /**\n     * Returns the framing rectangle of the rounded rectangle as a Rectangle object\n     * @example\n     * ```ts\n     * // Basic bounds calculation\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const bounds = rect.getBounds();\n     * // bounds: x=100, y=100, width=200, height=150\n     *\n     * // Reuse existing rectangle\n     * const out = new Rectangle();\n     * rect.getBounds(out);\n     * ```\n     * @remarks\n     * - Rectangle matches outer dimensions\n     * - Ignores corner radius\n     * @param out - Optional rectangle to store the result\n     * @returns The framing rectangle\n     * @see {@link Rectangle} For rectangle properties\n     * @see {@link RoundedRectangle.contains} For checking if a point is inside\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n\n        out.x = this.x;\n        out.y = this.y;\n        out.width = this.width;\n        out.height = this.height;\n\n        return out;\n    }\n\n    /**\n     * Creates a clone of this Rounded Rectangle.\n     * @example\n     * ```ts\n     * // Basic cloning\n     * const original = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const copy = original.clone();\n     *\n     * // Clone and modify\n     * const modified = original.clone();\n     * modified.radius = 30;\n     * modified.width *= 2;\n     *\n     * // Verify independence\n     * console.log(original.radius);  // 20\n     * console.log(modified.radius);  // 30\n     * ```\n     * @returns A copy of the rounded rectangle\n     * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     */\n    public clone(): RoundedRectangle\n    {\n        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * target.copyFrom(source);\n     *\n     * // Chain with other operations\n     * const rect = new RoundedRectangle()\n     *     .copyFrom(source)\n     *     .getBounds(rect);\n     * ```\n     * @param rectangle - The rectangle to copy from\n     * @returns Returns itself\n     * @see {@link RoundedRectangle.copyTo} For copying to another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyFrom(rectangle: RoundedRectangle): this\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @example\n     * ```ts\n     * // Basic copying\n     * const source = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const target = new RoundedRectangle();\n     * source.copyTo(target);\n     *\n     * // Chain with other operations\n     * const result = source\n     *     .copyTo(new RoundedRectangle())\n     *     .getBounds();\n     * ```\n     * @param rectangle - The rectangle to copy to\n     * @returns Returns given parameter\n     * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle\n     * @see {@link RoundedRectangle.clone} For creating new rectangle copy\n     */\n    public copyTo(rectangle: RoundedRectangle): RoundedRectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle\n     * @example\n     * ```ts\n     * // Basic containment check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isInside = rect.contains(150, 125); // true\n     * // Check corner radius\n     * const corner = rect.contains(100, 100); // false if within corner curve\n     * ```\n     * @remarks\n     * - Returns false if width/height is 0 or negative\n     * - Handles rounded corners with radius check\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rounded Rectangle\n     * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection\n     * @see {@link RoundedRectangle.getBounds} For getting containing rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n        if (x >= this.x && x <= this.x + this.width)\n        {\n            if (y >= this.y && y <= this.y + this.height)\n            {\n                const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n\n                if ((y >= this.y + radius && y <= this.y + this.height - radius)\n                    || (x >= this.x + radius && x <= this.x + this.width - radius))\n                {\n                    return true;\n                }\n                let dx = x - (this.x + radius);\n                let dy = y - (this.y + radius);\n                const radius2 = radius * radius;\n\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + this.width - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dy = y - (this.y + this.height - radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n                dx = x - (this.x + radius);\n                if ((dx * dx) + (dy * dy) <= radius2)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @example\n     * ```ts\n     * // Basic stroke check\n     * const rect = new RoundedRectangle(100, 100, 200, 150, 20);\n     * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width\n     *\n     * // Check with different alignments\n     * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside\n     * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered\n     * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside\n     * ```\n     * @param pX - The X coordinate of the point to test\n     * @param pY - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)\n     * @returns Whether the x/y coordinates are within this rectangle's stroke\n     * @see {@link RoundedRectangle.contains} For checking fill containment\n     * @see {@link RoundedRectangle.getBounds} For getting stroke bounds\n     */\n    public strokeContains(pX: number, pY: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { x, y, width, height, radius } = this;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const innerX = x + radius;\n        const innerY = y + radius;\n        const innerWidth = width - (radius * 2);\n        const innerHeight = height - (radius * 2);\n        const rightBound = x + width;\n        const bottomBound = y + height;\n\n        // Check if point is within the vertical edges (excluding corners)\n        if (((pX >= x - strokeWidthOuter && pX <= x + strokeWidthInner)\n            || (pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter))\n            && pY >= innerY && pY <= innerY + innerHeight)\n        {\n            return true;\n        }\n\n        // Check if point is within the horizontal edges (excluding corners)\n        if (((pY >= y - strokeWidthOuter && pY <= y + strokeWidthInner)\n            || (pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter))\n            && pX >= innerX && pX <= innerX + innerWidth)\n        {\n            return true;\n        }\n\n        // Top-left, top-right, bottom-right, bottom-left corners\n        return (\n            // Top-left\n            (pX < innerX && pY < innerY\n                && isCornerWithinStroke(pX, pY, innerX, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            //  top-right\n            || (pX > rightBound - radius && pY < innerY\n                && isCornerWithinStroke(pX, pY, rightBound - radius, innerY,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-right\n            || (pX > rightBound - radius && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter))\n            // bottom-left\n            || (pX < innerX && pY > bottomBound - radius\n                && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius,\n                    radius, strokeWidthInner, strokeWidthOuter)));\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}`\n            + `width=${this.width} height=${this.height} radius=${this.radius}]`;\n    }\n    // #endif\n}\n", "// thanks to https://github.com/mattdesl/adaptive-bezier-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\nconst mCuspLimit = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param cp2x\n * @param cp2y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveBezier(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    // TODO expose as a parameter\n    const scale = 1;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    cp2x: number, cp2y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    // dont need to actually ad this!\n    // points.push(sX, sY);\n    recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);\n    points.push(eX, eY);\n}\n\n// eslint-disable-next-line max-params\nfunction recursive(\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    x4: number, y4: number,\n    points: number[],\n    distanceTolerance: number,\n    level: number)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x34 = (x3 + x4) / 2;\n    const y34 = (y3 + y4) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n    const x234 = (x23 + x34) / 2;\n    const y234 = (y23 + y34) / 2;\n    const x1234 = (x123 + x234) / 2;\n    const y1234 = (y123 + y234) / 2;\n\n    if (level > 0)\n    { // Enforce subdivision first time\n        // Try to approximate the full cubic curve by a single straight line\n        // ------------------\n        let dx = x4 - x1;\n        let dy = y4 - y1;\n\n        const d2 = Math.abs(((x2 - x4) * dy) - ((y2 - y4) * dx));\n        const d3 = Math.abs(((x3 - x4) * dy) - ((y3 - y4) * dx));\n\n        let da1; let da2;\n\n        if (d2 > FLT_EPSILON && d3 > FLT_EPSILON)\n        {\n            // Regular care\n            // -----------------\n            if ((d2 + d3) * (d2 + d3) <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                // If the curvature doesn't exceed the distanceTolerance value\n                // we tend to finish subdivisions.\n                // ----------------------\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle & Cusp Condition\n                // ----------------------\n                const a23 = Math.atan2(y3 - y2, x3 - x2);\n\n                da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1));\n                da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23);\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n                if (da2 >= pi) da2 = (2 * pi) - da2;\n\n                if (da1 + da2 < mAngleTolerance)\n                {\n                    // Finally we can stop the recursion\n                    // ----------------------\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n\n                    if (da2 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d2 > FLT_EPSILON)\n        {\n            // p1,p3,p4 are collinear, p2 is considerable\n            // ----------------------\n            if (d2 * d2 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x2, y2);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else if (d3 > FLT_EPSILON)\n        {\n            // p1,p2,p4 are collinear, p3 is considerable\n            // ----------------------\n            if (d3 * d3 <= distanceTolerance * ((dx * dx) + (dy * dy)))\n            {\n                if (mAngleTolerance < curveAngleToleranceEpsilon)\n                {\n                    points.push(x1234, y1234);\n\n                    return;\n                }\n\n                // Angle Condition\n                // ----------------------\n                da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2));\n                if (da1 >= pi) da1 = (2 * pi) - da1;\n\n                if (da1 < mAngleTolerance)\n                {\n                    points.push(x2, y2);\n                    points.push(x3, y3);\n\n                    return;\n                }\n\n                if (mCuspLimit !== 0.0)\n                {\n                    if (da1 > mCuspLimit)\n                    {\n                        points.push(x3, y3);\n\n                        return;\n                    }\n                }\n            }\n        }\n        else\n        {\n            // Collinear case\n            // -----------------\n            dx = x1234 - ((x1 + x4) / 2);\n            dy = y1234 - ((y1 + y4) / 2);\n            if ((dx * dx) + (dy * dy) <= distanceTolerance)\n            {\n                points.push(x1234, y1234);\n\n                return;\n            }\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);\n    recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1);\n}\n\n", "// thanks to https://github.com/mattdesl/adaptive-quadratic-curve\n// for the original code!\n\nimport { GraphicsContextSystem } from '../GraphicsContextSystem';\n\nconst RECURSION_LIMIT = 8;\nconst FLT_EPSILON = 1.19209290e-7;\nconst PATH_DISTANCE_EPSILON = 1.0;\n\nconst curveAngleToleranceEpsilon = 0.01;\nconst mAngleTolerance = 0;\n\n/**\n * @param points\n * @param sX\n * @param sY\n * @param cp1x\n * @param cp1y\n * @param eX\n * @param eY\n * @param smoothness\n * @internal\n */\nexport function buildAdaptiveQuadratic(\n    points: number[],\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    smoothness?: number,\n)\n{\n    const scale = 1.0;\n    const smoothing = Math.min(\n        0.99, // a value of 1.0 actually inverts smoothing, so we cap it at 0.99\n        Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)\n    );\n    let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;\n\n    distanceTolerance *= distanceTolerance;\n    begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);\n\n    return points;\n}\n\n// //// Based on:\n// //// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp\n\nfunction begin(\n    sX: number, sY: number,\n    cp1x: number, cp1y: number,\n    eX: number, eY: number,\n    points: number[],\n    distanceTolerance: number\n)\n{\n    recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);\n\n    points.push(eX, eY);\n}\n\nfunction recursive(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    x3: number, y3: number,\n    distanceTolerance: number,\n    level: number\n)\n{\n    if (level > RECURSION_LIMIT)\n    { return; }\n\n    const pi = Math.PI;\n\n    // Calculate all the mid-points of the line segments\n    // ----------------------\n    const x12 = (x1 + x2) / 2;\n    const y12 = (y1 + y2) / 2;\n    const x23 = (x2 + x3) / 2;\n    const y23 = (y2 + y3) / 2;\n    const x123 = (x12 + x23) / 2;\n    const y123 = (y12 + y23) / 2;\n\n    let dx = x3 - x1;\n    let dy = y3 - y1;\n    const d = Math.abs((((x2 - x3) * dy) - ((y2 - y3) * dx)));\n\n    if (d > FLT_EPSILON)\n    {\n        // Regular care\n        // -----------------\n        if (d * d <= distanceTolerance * ((dx * dx) + (dy * dy)))\n        {\n            // If the curvature doesn't exceed the distance_tolerance value\n            // we tend to finish subdivisions.\n            // ----------------------\n            if (mAngleTolerance < curveAngleToleranceEpsilon)\n            {\n                points.push(x123, y123);\n\n                return;\n            }\n\n            // Angle & Cusp Condition\n            // ----------------------\n            let da = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1));\n\n            if (da >= pi) da = (2 * pi) - da;\n\n            if (da < mAngleTolerance)\n            {\n                // Finally we can stop the recursion\n                // ----------------------\n                points.push(x123, y123);\n\n                return;\n            }\n        }\n    }\n    else\n    {\n        // Collinear case\n        // -----------------\n        dx = x123 - ((x1 + x3) / 2);\n        dy = y123 - ((y1 + y3) / 2);\n        if ((dx * dx) + (dy * dy) <= distanceTolerance)\n        {\n            points.push(x123, y123);\n\n            return;\n        }\n    }\n\n    // Continue subdivision\n    // ----------------------\n    recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);\n    recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);\n}\n\n", "/**\n * @param points\n * @param x\n * @param y\n * @param radius\n * @param start\n * @param end\n * @param clockwise\n * @param steps\n * @internal\n */\nexport function buildArc(\n    points: number[],\n    x: number, y: number,\n    radius: number,\n    start: number,\n    end: number,\n    clockwise: boolean,\n    steps?: number\n)\n{\n    // determine distance between the two angles\n    // ...probably a nicer way of writing this\n    let dist = Math.abs(start - end);\n\n    if (!clockwise && start > end)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n    else if (clockwise && end > start)\n    {\n        dist = (2 * Math.PI) - dist;\n    }\n\n    // approximate the # of steps using the cube root of the radius\n\n    steps ||= Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / (Math.PI))));\n\n    // ensure we have at least 3 steps..\n    steps = Math.max(steps, 3);\n\n    let f = dist / (steps);\n    let t = start;\n\n    // modify direction\n    f *= clockwise ? -1 : 1;\n\n    for (let i = 0; i < steps + 1; i++)\n    {\n        const cs = Math.cos(t);\n        const sn = Math.sin(t);\n\n        const nx = x + (cs * radius);\n        const ny = y + (sn * radius);\n\n        points.push(nx, ny);\n\n        t += f;\n    }\n}\n", "import { buildArc } from './buildArc';\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n * @param points\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @param radius\n * @internal\n */\nexport function buildArcTo(\n    points: number[],\n    x1: number, y1: number,\n    x2: number, y2: number,\n    radius: number,\n): void\n{\n    const fromX = points[points.length - 2];\n    const fromY = points[points.length - 1];\n\n    const a1 = fromY - y1;\n    const b1 = fromX - x1;\n    const a2 = y2 - y1;\n    const b2 = x2 - x1;\n    const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n\n        return;\n    }\n\n    const dd = (a1 * a1) + (b1 * b1);\n    const cc = (a2 * a2) + (b2 * b2);\n    const tt = (a1 * a2) + (b1 * b2);\n    const k1 = radius * Math.sqrt(dd) / mm;\n    const k2 = radius * Math.sqrt(cc) / mm;\n    const j1 = k1 * tt / dd;\n    const j2 = k2 * tt / cc;\n    const cx = (k1 * b2) + (k2 * b1);\n    const cy = (k1 * a2) + (k2 * a1);\n    const px = b1 * (k2 + j1);\n    const py = a1 * (k2 + j1);\n    const qx = b2 * (k1 + j2);\n    const qy = a2 * (k1 + j2);\n    const startAngle = Math.atan2(py - cy, px - cx);\n    const endAngle = Math.atan2(qy - cy, qx - cx);\n\n    buildArc(points,\n        (cx + x1),\n        (cy + y1),\n        radius,\n        startAngle,\n        endAngle,\n        b1 * a2 > b2 * a1\n    );\n}\n", "import { buildAdaptiveBezier } from './buildAdaptiveBezier';\n\nconst TAU = Math.PI * 2;\n\nconst out = {\n    centerX: 0,\n    centerY: 0,\n    ang1: 0,\n    ang2: 0\n};\n\nconst mapToEllipse = (\n    { x, y }: {x: number, y: number},\n    rx: number, ry: number,\n    cosPhi: number, sinPhi: number,\n    centerX: number, centerY: number,\n    out: {x: number, y: number}\n): {x: number, y: number} =>\n{\n    x *= rx;\n    y *= ry;\n\n    const xp = (cosPhi * x) - (sinPhi * y);\n    const yp = (sinPhi * x) + (cosPhi * y);\n\n    out.x = xp + centerX;\n    out.y = yp + centerY;\n\n    return out;\n};\n\nfunction approxUnitArc(ang1: number, ang2: number): {x: number, y: number}[]\n{\n    // If 90 degree circular arc, use a constant\n    // as derived from http://spencermortensen.com/articles/bezier-circle\n\n    const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n    const a = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;\n\n    const x1 = Math.cos(ang1);\n    const y1 = Math.sin(ang1);\n    const x2 = Math.cos(ang1 + ang2);\n    const y2 = Math.sin(ang1 + ang2);\n\n    return [\n        {\n            x: x1 - (y1 * a),\n            y: y1 + (x1 * a)\n        },\n        {\n            x: x2 + (y2 * a),\n            y: y2 - (x2 * a)\n        },\n        {\n            x: x2,\n            y: y2\n        }\n    ];\n}\n\nconst vectorAngle = (ux: number, uy: number, vx: number, vy: number) =>\n{\n    const sign = ((ux * vy) - (uy * vx) < 0) ? -1 : 1;\n\n    let dot = (ux * vx) + (uy * vy);\n\n    if (dot > 1)\n    {\n        dot = 1;\n    }\n\n    if (dot < -1)\n    {\n        dot = -1;\n    }\n\n    return sign * Math.acos(dot);\n};\n\nconst getArcCenter = (\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    sinPhi: number,\n    cosPhi: number,\n    pxp: number,\n    pyp: number,\n    out: {\n        centerX: number,\n        centerY: number,\n        ang1: number,\n        ang2: number\n    }\n// eslint-disable-next-line max-params\n) =>\n{\n    const rxSq = Math.pow(rx, 2);\n    const rySq = Math.pow(ry, 2);\n    const pxpSq = Math.pow(pxp, 2);\n    const pypSq = Math.pow(pyp, 2);\n\n    let radicant = (rxSq * rySq) - (rxSq * pypSq) - (rySq * pxpSq);\n\n    if (radicant < 0)\n    {\n        radicant = 0;\n    }\n\n    radicant /= (rxSq * pypSq) + (rySq * pxpSq);\n    radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n    const centerXp = radicant * rx / ry * pyp;\n    const centerYp = radicant * -ry / rx * pxp;\n\n    const centerX = (cosPhi * centerXp) - (sinPhi * centerYp) + ((px + cx) / 2);\n    const centerY = (sinPhi * centerXp) + (cosPhi * centerYp) + ((py + cy) / 2);\n\n    const vx1 = (pxp - centerXp) / rx;\n    const vy1 = (pyp - centerYp) / ry;\n    const vx2 = (-pxp - centerXp) / rx;\n    const vy2 = (-pyp - centerYp) / ry;\n\n    const ang1 = vectorAngle(1, 0, vx1, vy1);\n    let ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n    if (sweepFlag === 0 && ang2 > 0)\n    {\n        ang2 -= TAU;\n    }\n\n    if (sweepFlag === 1 && ang2 < 0)\n    {\n        ang2 += TAU;\n    }\n\n    out.centerX = centerX;\n    out.centerY = centerY;\n    out.ang1 = ang1;\n    out.ang2 = ang2;\n};\n\n/**\n * @param points\n * @param px\n * @param py\n * @param cx\n * @param cy\n * @param rx\n * @param ry\n * @param xAxisRotation\n * @param largeArcFlag\n * @param sweepFlag\n * @internal\n */\nexport function buildArcToSvg(\n    points: number[],\n    px: number,\n    py: number,\n    cx: number,\n    cy: number,\n    rx: number,\n    ry: number,\n    xAxisRotation = 0,\n    largeArcFlag = 0,\n    sweepFlag = 0\n): void\n{\n    if (rx === 0 || ry === 0)\n    {\n        return;\n    }\n\n    const sinPhi = Math.sin(xAxisRotation * TAU / 360);\n    const cosPhi = Math.cos(xAxisRotation * TAU / 360);\n\n    const pxp = (cosPhi * (px - cx) / 2) + (sinPhi * (py - cy) / 2);\n    const pyp = (-sinPhi * (px - cx) / 2) + (cosPhi * (py - cy) / 2);\n\n    if (pxp === 0 && pyp === 0)\n    {\n        return;\n    }\n\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n\n    const lambda = (Math.pow(pxp, 2) / Math.pow(rx, 2)) + (Math.pow(pyp, 2) / Math.pow(ry, 2));\n\n    if (lambda > 1)\n    {\n        rx *= Math.sqrt(lambda);\n        ry *= Math.sqrt(lambda);\n    }\n\n    getArcCenter(\n        px,\n        py,\n        cx,\n        cy,\n        rx,\n        ry,\n        largeArcFlag,\n        sweepFlag,\n        sinPhi,\n        cosPhi,\n        pxp,\n        pyp,\n        out\n    );\n\n    let { ang1, ang2 } = out;\n    const { centerX, centerY } = out;\n\n    // If 'ang2' == 90.0000000001, then `ratio` will devalue to\n    // 1.0000000001. This causes `segments` to be greater than one, which is an\n    // unnecessary split, and adds extra points to the bezier curve. To alleviate\n    // this issue, we round to 1.0 when the ratio is close to 1.0.\n    let ratio = Math.abs(ang2) / (TAU / 4);\n\n    if (Math.abs(1.0 - ratio) < 0.0000001)\n    {\n        ratio = 1.0;\n    }\n\n    const segments = Math.max(Math.ceil(ratio), 1);\n\n    ang2 /= segments;\n\n    let lastX = points[points.length - 2];\n    let lastY = points[points.length - 1];\n\n    const outCurvePoint = { x: 0, y: 0 };\n\n    for (let i = 0; i < segments; i++)\n    {\n        const curve = approxUnitArc(ang1, ang2);\n\n        const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n        const { x, y } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);\n\n        buildAdaptiveBezier(\n            points,\n            lastX, lastY,\n            x1, y1, x2, y2, x, y\n        );\n\n        lastX = x;\n        lastY = y;\n\n        ang1 += ang2;\n    }\n}\n", "import type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePath } from './ShapePath';\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/44856925#44856925\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeArc(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number\n): void\n{\n    const vecFrom = (p: PointData, pp: PointData) =>\n    {\n        const x = pp.x - p.x;\n        const y = pp.y - p.y;\n        const len = Math.sqrt((x * x) + (y * y));\n        const nx = x / len;\n        const ny = y / len;\n\n        return { len, nx, ny };\n    };\n\n    const sharpCorner = (i: number, p: PointData) =>\n    {\n        if (i === 0)\n        {\n            g.moveTo(p.x, p.y);\n        }\n        else\n        {\n            g.lineTo(p.x, p.y);\n        }\n    };\n\n    let p1 = points[points.length - 1];\n\n    for (let i = 0; i < points.length; i++)\n    {\n        const p2 = points[i % points.length];\n        const pRadius = p2.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        const p3 = points[(i + 1) % points.length];\n        const v1 = vecFrom(p2, p1);\n        const v2 = vecFrom(p2, p3);\n\n        if (v1.len < 1e-4 || v2.len < 1e-4)\n        {\n            sharpCorner(i, p2);\n            p1 = p2;\n            continue;\n        }\n\n        let angle = Math.asin((v1.nx * v2.ny) - (v1.ny * v2.nx));\n        let radDirection = 1;\n        let drawDirection = false;\n\n        if ((v1.nx * v2.nx) - (v1.ny * -v2.ny) < 0)\n        {\n            if (angle < 0)\n            {\n                angle = Math.PI + angle;\n            }\n            else\n            {\n                angle = Math.PI - angle;\n                radDirection = -1;\n                drawDirection = true;\n            }\n        }\n        else if (angle > 0)\n        {\n            radDirection = -1;\n            drawDirection = true;\n        }\n\n        const halfAngle = angle / 2;\n\n        let cRadius: number;\n        let lenOut = Math.abs(\n            (Math.cos(halfAngle) * pRadius) / Math.sin(halfAngle)\n        );\n\n        if (lenOut > Math.min(v1.len / 2, v2.len / 2))\n        {\n            lenOut = Math.min(v1.len / 2, v2.len / 2);\n            cRadius = Math.abs((lenOut * Math.sin(halfAngle)) / Math.cos(halfAngle));\n        }\n        else\n        {\n            cRadius = pRadius;\n        }\n\n        const cX = p2.x + (v2.nx * lenOut) + (-v2.ny * cRadius * radDirection);\n        const cY = p2.y + (v2.ny * lenOut) + (v2.nx * cRadius * radDirection);\n        const startAngle = Math.atan2(v1.ny, v1.nx) + ((Math.PI / 2) * radDirection);\n        const endAngle = Math.atan2(v2.ny, v2.nx) - ((Math.PI / 2) * radDirection);\n\n        if (i === 0)\n        {\n            g.moveTo(\n                cX + (Math.cos(startAngle) * cRadius),\n                cY + (Math.sin(startAngle) * cRadius)\n            );\n        }\n\n        g.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);\n\n        p1 = p2;\n    }\n}\n\n/**\n * Data structure for points with optional radius.\n * @category scene\n * @standard\n */\nexport type RoundedPoint = PointData & { radius?: number };\n\n/**\n * Typed and cleaned up version of:\n * https://stackoverflow.com/questions/44855794/html5-canvas-triangle-with-rounded-corners/56214413#56214413\n * @param g - Graphics to be drawn on.\n * @param points - Corners of the shape to draw. Minimum length is 3.\n * @param radius - Corners default radius.\n * @ignore\n */\nexport function roundedShapeQuadraticCurve(\n    g: ShapePath,\n    points: RoundedPoint[],\n    radius: number,\n    smoothness?: number,\n): void\n{\n    const distance = (p1: PointData, p2: PointData) =>\n        Math.sqrt(((p1.x - p2.x) ** 2) + ((p1.y - p2.y) ** 2));\n\n    const pointLerp = (p1: PointData, p2: PointData, t: number) => ({\n        x: p1.x + ((p2.x - p1.x) * t),\n        y: p1.y + ((p2.y - p1.y) * t),\n    });\n\n    const numPoints = points.length;\n\n    for (let i = 0; i < numPoints; i++)\n    {\n        const thisPoint = points[(i + 1) % numPoints];\n        const pRadius = thisPoint.radius ?? radius;\n\n        if (pRadius <= 0)\n        {\n            if (i === 0)\n            {\n                g.moveTo(thisPoint.x, thisPoint.y);\n            }\n            else\n            {\n                g.lineTo(thisPoint.x, thisPoint.y);\n            }\n\n            continue;\n        }\n\n        const lastPoint = points[i];\n        const nextPoint = points[(i + 2) % numPoints];\n\n        const lastEdgeLength = distance(lastPoint, thisPoint);\n        let start;\n\n        if (lastEdgeLength < 1e-4)\n        {\n            start = thisPoint;\n        }\n        else\n        {\n            const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);\n\n            start = pointLerp(\n                thisPoint,\n                lastPoint,\n                lastOffsetDistance / lastEdgeLength\n            );\n        }\n\n        const nextEdgeLength = distance(nextPoint, thisPoint);\n        let end;\n\n        if (nextEdgeLength < 1e-4)\n        {\n            end = thisPoint;\n        }\n        else\n        {\n            const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);\n\n            end = pointLerp(\n                thisPoint,\n                nextPoint,\n                nextOffsetDistance / nextEdgeLength\n            );\n        }\n\n        if (i === 0)\n        {\n            g.moveTo(start.x, start.y);\n        }\n        else\n        {\n            g.lineTo(start.x, start.y);\n        }\n        g.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);\n    }\n}\n", "// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * A type representing a shape primitive with optional transformation and holes.\n * @category scene\n * @advanced\n */\nexport type ShapePrimitiveWithHoles = {\n    shape: ShapePrimitive,\n    transform?: Matrix,\n    holes?: ShapePrimitiveWithHoles[]\n};\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @category scene\n * @advanced\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: ShapePrimitiveWithHoles[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n    public readonly signed: boolean;\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n        this.signed = graphicsPath2D.checkForHoles;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        // Only clone if we need to transform\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        const shapePrimitives = this.shapePrimitives;\n        const start = shapePrimitives.length;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        // This section processes holes in polygons by checking if any polygon is contained within another.\n        // If a polygon is found to be inside another polygon (mainShape), it's treated as a hole.\n        // The hole polygon is removed from the main shapePrimitives array and added to the holes array\n        // of the containing polygon. This allows for proper rendering of shapes with holes.\n        if (path.checkForHoles && shapePrimitives.length - start > 1)\n        {\n            let mainShape = null;\n\n            // Process in place instead of creating a removal array\n            for (let i = start; i < shapePrimitives.length; i++)\n            {\n                const shapePrimitive = shapePrimitives[i];\n\n                if (shapePrimitive.shape.type === 'polygon')\n                {\n                    const polygon = shapePrimitive.shape as Polygon;\n                    const mainPolygon = mainShape?.shape as Polygon;\n\n                    if (mainPolygon && mainPolygon.containsPolygon(polygon))\n                    {\n                        // Initialize holes array only when needed\n                        mainShape.holes ||= [];\n                        mainShape.holes.push(shapePrimitive);\n\n                        // Remove the hole by moving elements left\n                        shapePrimitives.copyWithin(i, i + 1);\n                        shapePrimitives.length--;\n                        i--;\n                    }\n                    else\n                    {\n                        mainShape = shapePrimitive;\n                    }\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = startAngle - (i * delta);\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (lastShape.transform && !lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n", "import { Point } from '../../../../maths/point/Point';\nimport { uid } from '../../../../utils/data/uid';\nimport { warn } from '../../../../utils/logging/warn';\nimport { parseSVGPath } from '../svg/parseSVGPath';\nimport { ShapePath } from './ShapePath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { Bounds } from '../../../container/bounds/Bounds';\nimport type { RoundedPoint } from './roundShape';\n\n/**\n * Represents a single drawing instruction in a `GraphicsPath`.\n * Each instruction consists of an action type and associated data.\n * @category scene\n * @advanced\n */\nexport interface PathInstruction\n{\n    action: 'moveTo' | 'lineTo' | 'quadraticCurveTo' |\n    'bezierCurveTo' | 'arc' | 'closePath' |\n    'addPath' | 'arcTo' | 'ellipse' |\n    'rect' | 'roundRect' | 'arcToSvg' |\n    'poly' | 'circle' |\n    'regularPoly' | 'roundPoly' | 'roundShape' | 'filletRect' | 'chamferRect'\n    data: any[];\n}\n\n/**\n * The `GraphicsPath` class is designed to represent a graphical path consisting of multiple drawing instructions.\n * This class serves as a collection of drawing commands that can be executed to render shapes and paths on a canvas or\n * similar graphical context. It supports high-level drawing operations like lines, arcs, curves, and more, enabling\n * complex graphic constructions with relative ease.\n * @category scene\n * @advanced\n */\nexport class GraphicsPath\n{\n    public instructions: PathInstruction[] = [];\n\n    /** unique id for this graphics path */\n    public readonly uid: number = uid('graphicsPath');\n\n    private _dirty = true;\n    // needed for hit testing and bounds calculations\n    private _shapePath: ShapePath;\n\n    /**\n     * Controls whether shapes in this path should be checked for holes using the non-zero fill rule.\n     * When true, any closed shape that is fully contained within another shape will become\n     * a hole in that shape during filling operations.\n     *\n     * This follows SVG's non-zero fill rule where:\n     * 1. Shapes are analyzed to find containment relationships\n     * 2. If Shape B is fully contained within Shape A, Shape B becomes a hole in Shape A\n     * 3. Multiple nested holes are supported\n     *\n     * Mainly used internally by the SVG parser to correctly handle holes in complex paths.\n     * When false, all shapes are filled independently without checking for holes.\n     */\n    public checkForHoles: boolean;\n\n    /**\n     * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.\n     * @returns The `ShapePath` instance associated with this `GraphicsPath`.\n     */\n    get shapePath(): ShapePath\n    {\n        if (!this._shapePath)\n        {\n            this._shapePath = new ShapePath(this);\n        }\n\n        if (this._dirty)\n        {\n            this._dirty = false;\n            this._shapePath.buildPath();\n        }\n\n        return this._shapePath;\n    }\n\n    /**\n     * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.\n     * @param instructions - An SVG path string or an array of `PathInstruction` objects.\n     * @param signed\n     */\n    constructor(instructions?: string | PathInstruction[], signed = false)\n    {\n        this.checkForHoles = signed;\n\n        if (typeof instructions === 'string')\n        {\n            parseSVGPath(instructions, this);\n        }\n        else\n        {\n            this.instructions = instructions?.slice() ?? [];\n        }\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @param transform - An optional transformation to apply to the added path.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        path = path.clone();\n        this.instructions.push({ action: 'addPath', data: [path, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: [number, number, number, number, number, boolean]): this\n    {\n        this.instructions.push({ action: 'arc', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    // eslint-disable-next-line max-len\n    public arcToSvg(rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number): this;\n    public arcToSvg(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'arcToSvg', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: [number, number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'bezierCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires two points: the second control point and the end point. The first control point is assumed to be\n     * The starting point is the last point in the current path.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveToShort(cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cp1x = 0;\n        let cp1y = 0;\n\n        if (!last || last.action !== 'bezierCurveTo')\n        {\n            cp1x = lastPoint.x;\n            cp1y = lastPoint.y;\n        }\n        else\n        {\n            cp1x = last.data[2];\n            cp1y = last.data[3];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cp1x = currentX + (currentX - cp1x);\n            cp1y = currentY + (currentY - cp1y);\n        }\n\n        this.instructions.push({ action: 'bezierCurveTo', data: [cp1x, cp1y, cp2x, cp2y, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.instructions.push({ action: 'closePath', data: [] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param matrix - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, matrix?: Matrix): this;\n    public ellipse(...args: [number, number, number, number, Matrix]): this\n    {\n        this.instructions.push({ action: 'ellipse', data: args });\n\n        // TODO nail this!\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'lineTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: [number, number]): this\n    {\n        this.instructions.push({ action: 'moveTo', data: args });\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'quadraticCurveTo', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It uses the previous point as the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveToShort(x: number, y: number, smoothness?: number): this\n    {\n        // check if we have a previous quadraticCurveTo\n        const last = this.instructions[this.instructions.length - 1];\n\n        const lastPoint = this.getLastPoint(Point.shared);\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n\n        if (!last || last.action !== 'quadraticCurveTo')\n        {\n            cpx1 = lastPoint.x;\n            cpy1 = lastPoint.y;\n        }\n        else\n        {\n            cpx1 = last.data[0];\n            cpy1 = last.data[1];\n\n            const currentX = lastPoint.x;\n            const currentY = lastPoint.y;\n\n            cpx1 = currentX + (currentX - cpx1);\n            cpy1 = currentY + (currentY - cpy1);\n        }\n\n        this.instructions.push({ action: 'quadraticCurveTo', data: [cpx1, cpy1, x, y, smoothness] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'rect', data: [x, y, w, h, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.instructions.push({ action: 'circle', data: [x, y, radius, transform] });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this;\n    public roundRect(...args: [number, number, number, number, number, Matrix?]): this\n    {\n        this.instructions.push({ action: 'roundRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this;\n    public poly(...args: [number[] | PointData[], boolean, Matrix?]): this\n    {\n        this.instructions.push({ action: 'poly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'regularPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: [number, number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'roundPoly', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: [RoundedPoint[], number, boolean, number]): this\n    {\n        this.instructions.push({ action: 'roundShape', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'filletRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: [number, number, number, number, number]): this\n    {\n        this.instructions.push({ action: 'chamferRect', data: args });\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @param transform - An optional `Matrix` object to apply a transformation to the star.\n     * This can include rotations, scaling, and translations.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    // eslint-disable-next-line max-len\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number, transform?: Matrix): this\n    {\n        innerRadius ||= radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = (Math.PI * 2) / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.\n     * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and\n     * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`\n     * do not affect the original `GraphicsPath` and vice versa.\n     * @param deep - A boolean flag indicating whether the clone should be deep.\n     * @returns A new `GraphicsPath` instance that is a clone of the current instance.\n     */\n    public clone(deep = false): GraphicsPath\n    {\n        const newGraphicsPath2D = new GraphicsPath();\n\n        newGraphicsPath2D.checkForHoles = this.checkForHoles;\n\n        if (!deep)\n        {\n            newGraphicsPath2D.instructions = this.instructions.slice();\n        }\n        else\n        {\n            for (let i = 0; i < this.instructions.length; i++)\n            {\n                const instruction = this.instructions[i];\n\n                newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });\n            }\n        }\n\n        return newGraphicsPath2D;\n    }\n\n    public clear(): this\n    {\n        this.instructions.length = 0;\n        this._dirty = true;\n\n        return this;\n    }\n\n    /**\n     * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.\n     * This method enables the modification of the path's geometry according to the provided\n     * transformation matrix, which can include translations, rotations, scaling, and skewing.\n     *\n     * Each drawing instruction in the path is updated to reflect the transformation,\n     * ensuring the visual representation of the path is consistent with the applied matrix.\n     *\n     * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,\n     * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,\n     * allowing for fine-grained control over the path's appearance.\n     * @param matrix - A `Matrix` object representing the transformation to apply.\n     * @returns The instance of the current object for chaining further operations.\n     */\n    public transform(matrix: Matrix): this\n    {\n        if (matrix.isIdentity()) return this;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let x = 0;\n        let y = 0;\n\n        let cpx1 = 0;\n        let cpy1 = 0;\n        let cpx2 = 0;\n        let cpy2 = 0;\n\n        let rx = 0;\n        let ry = 0;\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const data = instruction.data as any[];\n\n            switch (instruction.action)\n            {\n                case 'moveTo':\n                case 'lineTo':\n\n                    x = data[0];\n                    y = data[1];\n\n                    data[0] = (a * x) + (c * y) + tx;\n                    data[1] = (b * x) + (d * y) + ty;\n                    break;\n                case 'bezierCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n                    cpx2 = data[2];\n                    cpy2 = data[3];\n\n                    x = data[4];\n                    y = data[5];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n                    data[2] = (a * cpx2) + (c * cpy2) + tx;\n                    data[3] = (b * cpx2) + (d * cpy2) + ty;\n                    data[4] = (a * x) + (c * y) + tx;\n                    data[5] = (b * x) + (d * y) + ty;\n                    break;\n\n                case 'quadraticCurveTo':\n\n                    cpx1 = data[0];\n                    cpy1 = data[1];\n\n                    x = data[2];\n                    y = data[3];\n\n                    data[0] = (a * cpx1) + (c * cpy1) + tx;\n                    data[1] = (b * cpx1) + (d * cpy1) + ty;\n\n                    data[2] = (a * x) + (c * y) + tx;\n                    data[3] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'arcToSvg':\n\n                    x = data[5];\n                    y = data[6];\n\n                    rx = data[0];\n                    ry = data[1];\n\n                    // multiply the radius by the transform..\n\n                    data[0] = (a * rx) + (c * ry);\n                    data[1] = (b * rx) + (d * ry);\n\n                    data[5] = (a * x) + (c * y) + tx;\n                    data[6] = (b * x) + (d * y) + ty;\n\n                    break;\n\n                case 'circle':\n                    data[4] = adjustTransform(data[3], matrix);\n                    break;\n                case 'rect':\n                    data[4] = adjustTransform(data[4], matrix);\n                    break;\n                case 'ellipse':\n                    data[8] = adjustTransform(data[8], matrix);\n                    break;\n                case 'roundRect':\n                    data[5] = adjustTransform(data[5], matrix);\n                    break;\n                case 'addPath':\n                    data[0].transform(matrix);\n                    break;\n                case 'poly':\n                    data[2] = adjustTransform(data[2], matrix);\n                    break;\n                default:\n                    // #if _DEBUG\n                    warn('unknown transform action', instruction.action);\n                    // #endif\n                    break;\n            }\n        }\n\n        this._dirty = true;\n\n        return this;\n    }\n\n    get bounds(): Bounds\n    {\n        return this.shapePath.bounds;\n    }\n\n    /**\n     * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.\n     * This method is useful for operations that depend on the path's current endpoint,\n     * such as connecting subsequent shapes or paths. It supports various drawing instructions,\n     * ensuring the last point's position is accurately determined regardless of the path's complexity.\n     *\n     * If the last instruction is a `closePath`, the method iterates backward through the instructions\n     *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,\n     * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves\n     * the last point from the nested path.\n     * @param out - A `Point` object where the last point's coordinates will be stored.\n     * This object is modified directly to contain the result.\n     * @returns The `Point` object containing the last point's coordinates.\n     */\n    public getLastPoint(out: Point): Point\n    {\n        let index = this.instructions.length - 1;\n\n        let lastInstruction = this.instructions[index];\n\n        if (!lastInstruction)\n        {\n            out.x = 0;\n            out.y = 0;\n\n            return out;\n        }\n\n        while (lastInstruction.action === 'closePath')\n        {\n            index--;\n\n            if (index < 0)\n            {\n                out.x = 0;\n                out.y = 0;\n\n                return out;\n            }\n\n            lastInstruction = this.instructions[index];\n        }\n\n        switch (lastInstruction.action)\n        {\n            case 'moveTo':\n            case 'lineTo':\n                out.x = lastInstruction.data[0];\n                out.y = lastInstruction.data[1];\n                break;\n            case 'quadraticCurveTo':\n                out.x = lastInstruction.data[2];\n                out.y = lastInstruction.data[3];\n                break;\n            case 'bezierCurveTo':\n                out.x = lastInstruction.data[4];\n                out.y = lastInstruction.data[5];\n                break;\n            case 'arc':\n            case 'arcToSvg':\n                out.x = lastInstruction.data[5];\n                out.y = lastInstruction.data[6];\n                break;\n            case 'addPath':\n                // TODO prolly should transform the last point of the path\n                lastInstruction.data[0].getLastPoint(out);\n                break;\n        }\n\n        return out;\n    }\n}\n\nfunction adjustTransform(currentMatrix?: Matrix, transform?: Matrix): Matrix\n{\n    if (currentMatrix)\n    {\n        return currentMatrix.prepend(transform);\n    }\n\n    return transform.clone();\n}\n", "/**\n * Parses a float value from an SVG element's attribute.\n * This is commonly used for parsing numeric attributes like coordinates, dimensions,\n * and other measurements from SVG elements.\n * @param svg - The SVG element to get the attribute from\n * @param id - The name of the attribute to parse (e.g. 'x', 'y', 'width', etc)\n * @param defaultValue - The value to return if the attribute doesn't exist or can't be parsed\n * @returns The parsed float value, or the default value if parsing fails\n * @example\n * // For SVG: <rect x=\"10.5\" width=\"20\"/>\n * parseSVGFloatAttribute(rectElement, 'x', 0) // Returns 10.5\n * parseSVGFloatAttribute(rectElement, 'y', 0) // Returns 0 since y is not specified\n * @internal\n */\nexport function parseSVGFloatAttribute(svg: SVGElement, id: string, defaultValue: number): number\n{\n    const value = svg.getAttribute(id) as string;\n\n    return value ? Number(value) : defaultValue;\n}\n", "import { Color } from '../../../../color/Color';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../fill/FillGradient';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\n\nimport type { Session } from './SVGParser';\n\n/**\n * Parses SVG gradient definitions and stores them in the session for later use.\n * Currently supports linear gradients and has placeholder support for radial gradients.\n * @param svg - The root SVG element to parse definitions from\n * @param session - The parsing session to store definitions in\n * @internal\n */\nexport function parseSVGDefinitions(svg: SVGElement, session: Session): void\n{\n    // Find all <defs> elements in the SVG\n    const definitions = svg.querySelectorAll('defs');\n\n    // Process each <defs> element\n    for (let i = 0; i < definitions.length; i++)\n    {\n        const definition = definitions[i];\n\n        // Process each child element in the <defs>\n        for (let j = 0; j < definition.children.length; j++)\n        {\n            const child = definition.children[j];\n\n            // Handle different types of gradient definitions\n            switch (child.nodeName.toLowerCase())\n            {\n                case 'lineargradient':\n                    // Store the parsed linear gradient in the session defs using the gradient's ID\n                    session.defs[child.id] = parseLinearGradient(child as SVGElement);\n                    break;\n                case 'radialgradient':\n                    session.defs[child.id] = parseRadialGradient(child as SVGElement);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n\n/**\n * Parses an SVG linear gradient element into a FillGradient.\n * @param child - The SVG linear gradient element to parse\n * @returns A FillGradient configured based on the SVG element\n */\nfunction parseLinearGradient(child: SVGElement): FillGradient\n{\n    // Parse the gradient vector coordinates (defaults: horizontal line from 0 to 1)\n    const x0 = parseSVGFloatAttribute(child, 'x1', 0);\n    const y0 = parseSVGFloatAttribute(child, 'y1', 0);\n    const x1 = parseSVGFloatAttribute(child, 'x2', 1);\n    const y1 = parseSVGFloatAttribute(child, 'y2', 0);\n\n    // Get the gradient coordinate system\n    const gradientUnit = child.getAttribute('gradientUnits') || 'objectBoundingBox';\n\n    // Create gradient with coordinates and space mapping\n    const gradient = new FillGradient(\n        x0,\n        y0,\n        x1,\n        y1,\n        gradientUnit === 'objectBoundingBox' ? 'local' : 'global'\n    );\n\n    // Process each gradient stop\n    for (let k = 0; k < child.children.length; k++)\n    {\n        const stop = child.children[k] as SVGElement;\n\n        // Get stop position (0-1) and color\n        const offset = parseSVGFloatAttribute(stop, 'offset', 0);\n        const color = Color.shared.setValue(stop.getAttribute('stop-color')).toNumber();\n\n        gradient.addColorStop(offset, color);\n    }\n\n    return gradient;\n}\n\n/**\n * Placeholder function for parsing SVG radial gradients.\n * Currently returns a simple horizontal linear gradient and logs a warning.\n * @param _child - The SVG radial gradient element (currently unused)\n * @returns A default linear gradient\n */\nfunction parseRadialGradient(_child: SVGElement): FillGradient\n{\n    // #if _DEBUG\n    warn('[SVG Parser] Radial gradients are not yet supported');\n    // #endif\n\n    return new FillGradient(0, 0, 1, 0);\n}\n", "/**\n * Extracts the ID from an SVG url() reference.\n *\n * This function handles all valid SVG url() formats including:\n * - url(#id)\n * - url('#id')\n * - url(\"#id\")\n * - url( #id )\n * - url( '#id' )\n * - url( \"#id\" )\n *\n * The regex pattern matches:\n * - url followed by optional whitespace\n * - opening parenthesis followed by optional whitespace\n * - optional single or double quotes with optional whitespace\n * - # followed by the ID (any chars except quotes, whitespace, or closing paren)\n * - optional single or double quotes with optional whitespace\n * - closing parenthesis\n * @param url - The SVG url() string to parse\n * @returns The extracted ID string, or empty string if no valid ID found\n * @internal\n */\nexport function extractSvgUrlId(url: string): string\n{\n    // Handle all valid SVG url() formats\n    const match = url.match(/url\\s*\\(\\s*['\"]?\\s*#([^'\"\\s)]+)\\s*['\"]?\\s*\\)/i);\n\n    return match ? match[1] : '';\n}\n", "import { Color } from '../../../../color/Color';\nimport { extractSvgUrlId } from './utils/extractSvgUrlId';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillStyle, StrokeStyle } from '../FillTypes';\nimport type { Session } from './SVGParser';\n\n/**\n * A map of SVG style attributes and their default values.\n * Each attribute has a type and default value used for SVG parsing.\n * - 'paint' type can be a color or gradient\n * - 'number' type is a numeric value\n * - 'string' type is a text value\n * @category scene\n * @advanced\n */\nexport const styleAttributes = {\n    // Fill properties\n    fill: { type: 'paint', default: 0 }, // Fill color/gradient\n    'fill-opacity': { type: 'number', default: 1 }, // Fill transparency\n\n    // Stroke properties\n    stroke: { type: 'paint', default: 0 }, // Stroke color/gradient\n    'stroke-width': { type: 'number', default: 1 }, // Width of stroke\n    'stroke-opacity': { type: 'number', default: 1 }, // Stroke transparency\n    'stroke-linecap': { type: 'string', default: 'butt' }, // End cap style: butt, round, square\n    'stroke-linejoin': { type: 'string', default: 'miter' }, // Join style: miter, round, bevel\n    'stroke-miterlimit': { type: 'number', default: 10 }, // Limit on miter join sharpness\n    'stroke-dasharray': { type: 'string', default: 'none' }, // Dash pattern\n    'stroke-dashoffset': { type: 'number', default: 0 }, // Offset for dash pattern\n\n    // Global properties\n    opacity: { type: 'number', default: 1 }, // Overall opacity\n};\n\n/**\n * Represents the result of parsing SVG style attributes\n * @internal\n */\nexport type StyleResult = {\n    /** The stroke style properties */\n    strokeStyle: StrokeStyle;\n    /** The fill style properties */\n    fillStyle: FillStyle;\n    /** Whether fill should be applied */\n    useFill: boolean;\n    /** Whether stroke should be applied */\n    useStroke: boolean;\n};\n\n/**\n * Parses SVG style attributes and inline styles to determine fill and stroke properties.\n * Handles both direct attributes and CSS-style declarations in the style attribute.\n * @param svg - The SVG element to parse styles from\n * @param session - The current SVG parsing session containing definitions\n * @returns An object containing the parsed fill and stroke styles\n * @internal\n */\nexport function parseSVGStyle(svg: SVGElement, session: Session): StyleResult\n{\n    const style = svg.getAttribute('style');\n\n    const strokeStyle: StrokeStyle = {};\n\n    const fillStyle: FillStyle = {};\n\n    const result: StyleResult = {\n        strokeStyle,\n        fillStyle,\n        useFill: false,\n        useStroke: false,\n    };\n\n    // First parse direct style attributes\n    for (const key in styleAttributes)\n    {\n        const attribute = svg.getAttribute(key);\n\n        if (attribute)\n        {\n            parseAttribute(session, result, key, attribute.trim());\n        }\n    }\n\n    // Then parse inline styles which override direct attributes\n    if (style)\n    {\n        const styleParts = style.split(';');\n\n        for (let i = 0; i < styleParts.length; i++)\n        {\n            const stylePart = styleParts[i].trim();\n\n            const [key, value] = stylePart.split(':');\n\n            if (styleAttributes[key as keyof typeof styleAttributes])\n            {\n                parseAttribute(session, result, key, value.trim());\n            }\n        }\n    }\n\n    return {\n        strokeStyle: result.useStroke ? (strokeStyle as ConvertedStrokeStyle) : null,\n        fillStyle: result.useFill ? (fillStyle as ConvertedFillStyle) : null,\n        useFill: result.useFill,\n        useStroke: result.useStroke,\n    };\n}\n\n/**\n * Parses a single SVG style attribute and updates the style result accordingly.\n * Handles color values, gradients, opacities and other style properties.\n * @param session - The current SVG parsing session containing definitions\n * @param result - The style result object to update\n * @param id - The attribute name/id to parse\n * @param value - The attribute value to parse\n */\nfunction parseAttribute(\n    session: Session,\n    result: StyleResult,\n    id: string,\n    value: string\n): void\n{\n    switch (id)\n    {\n        case 'stroke':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.strokeStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.strokeStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useStroke = true;\n            }\n\n            break;\n        case 'stroke-width':\n            result.strokeStyle.width = Number(value);\n            break;\n        case 'fill':\n            if (value !== 'none')\n            {\n                if (value.startsWith('url('))\n                {\n                    // Extract gradient/pattern id from url reference\n                    const id = extractSvgUrlId(value);\n\n                    result.fillStyle.fill = session.defs[id];\n                }\n                else\n                {\n                    // Parse as color value\n                    result.fillStyle.color = Color.shared.setValue(value).toNumber();\n                }\n\n                result.useFill = true;\n            }\n            break;\n        case 'fill-opacity':\n            result.fillStyle.alpha = Number(value);\n            break;\n        case 'stroke-opacity':\n            result.strokeStyle.alpha = Number(value);\n            break;\n        case 'opacity':\n            // Global opacity affects both fill and stroke\n            result.fillStyle.alpha = Number(value);\n            result.strokeStyle.alpha = Number(value);\n            break;\n    }\n}\n", "import type {\n    FillInstruction,\n    GraphicsContext,\n} from '../../GraphicsContext';\n\n/**\n * Determines if subpaths represent nested shapes or multiple holes pattern.\n * @param subpathsWithArea - Array of subpaths with their calculated areas\n * @returns True if nested pattern, false if multiple holes pattern\n * @internal\n */\nexport function checkForNestedPattern(subpathsWithArea: Array<{path: string, area: number}>): boolean\n{\n    if (subpathsWithArea.length <= 2)\n    {\n        return true;\n    }\n\n    const areas = subpathsWithArea.map((s) => s.area).sort((a, b) => b - a);\n\n    const [largestArea, secondArea] = areas;\n    const smallestArea = areas[areas.length - 1];\n\n    const largestToSecondRatio = largestArea / secondArea;\n    const secondToSmallestRatio = secondArea / smallestArea;\n\n    // If the largest shape is significantly bigger than the second (3x+)\n    // AND the smaller shapes are similar in size (2x or less difference),\n    // it suggests multiple holes pattern rather than nested shapes\n    if (largestToSecondRatio > 3 && secondToSmallestRatio < 2)\n    {\n        return false; // Multiple holes\n    }\n\n    return true; // Default to nested\n}\n\n/**\n * Gets fill instruction data from a graphics context.\n * @param context - The graphics context\n * @param index - Index of the fill instruction (default: 0)\n * @returns The fill instruction data\n * @throws Error if instruction at index is not a fill instruction\n * @internal\n */\nexport function getFillInstructionData(context: GraphicsContext, index: number = 0)\n{\n    const instruction = context.instructions[index];\n\n    if (!instruction || instruction.action !== 'fill')\n    {\n        throw new Error(`Expected fill instruction at index ${index}, got ${instruction?.action || 'undefined'}`);\n    }\n\n    return (instruction as FillInstruction).data;\n}\n", "import { GraphicsPath } from '../../path/GraphicsPath';\n\n/**\n * Extracts individual subpaths from SVG path data by splitting on Move commands.\n * @param pathData - The SVG path data string\n * @returns Array of subpath strings\n * @internal\n */\nexport function extractSubpaths(pathData: string): string[]\n{\n    // Split on Move commands (M or m) to get individual subpaths\n    const parts = pathData.split(/(?=[Mm])/);\n    const subpaths = parts.filter((part) => part.trim().length > 0);\n\n    return subpaths;\n}\n\n/**\n * Calculates the area of a path using bounding box estimation.\n * @param pathData - The SVG path data string\n * @returns The estimated area of the path\n * @internal\n */\nexport function calculatePathArea(pathData: string): number\n{\n    const coords = pathData.match(/[-+]?[0-9]*\\.?[0-9]+/g);\n\n    if (!coords || coords.length < 4) return 0;\n\n    const numbers = coords.map(Number);\n    const xs = [];\n    const ys = [];\n\n    for (let i = 0; i < numbers.length; i += 2)\n    {\n        if (i + 1 < numbers.length)\n        {\n            xs.push(numbers[i]);\n            ys.push(numbers[i + 1]);\n        }\n    }\n\n    if (xs.length === 0 || ys.length === 0) return 0;\n\n    const minX = Math.min(...xs);\n    const maxX = Math.max(...xs);\n    const minY = Math.min(...ys);\n    const maxY = Math.max(...ys);\n\n    const area = (maxX - minX) * (maxY - minY);\n\n    return area;\n}\n\n/**\n * Parses SVG path data and appends instructions to a GraphicsPath.\n * @param pathData - The SVG path data string\n * @param graphicsPath - The GraphicsPath to append instructions to\n * @internal\n */\nexport function appendSVGPath(pathData: string, graphicsPath: GraphicsPath): void\n{\n    const tempPath = new GraphicsPath(pathData, false);\n\n    for (const instruction of tempPath.instructions)\n    {\n        graphicsPath.instructions.push(instruction);\n    }\n}\n", "import { warn } from '../../../../utils/logging/warn';\nimport { GraphicsPath } from '../path/GraphicsPath';\nimport { parseSVGDefinitions } from './parseSVGDefinitions';\nimport { parseSVGFloatAttribute } from './parseSVGFloatAttribute';\nimport { parseSVGStyle } from './parseSVGStyle';\nimport { checkForNestedPattern } from './utils/fillOperations';\nimport { appendSVGPath, calculatePathArea, extractSubpaths } from './utils/pathOperations';\n\nimport type { FillGradient } from '../fill/FillGradient';\nimport type { FillStyle, StrokeStyle } from '../FillTypes';\nimport type {\n    GraphicsContext,\n} from '../GraphicsContext';\n\n/**\n * Represents a session for SVG parsing. Contains the current state and resources needed during parsing.\n * @internal\n */\nexport interface Session\n{\n    /** The graphics context to render to */\n    context: GraphicsContext;\n    /** The current path being constructed */\n    path: GraphicsPath;\n    /** Map of definitions by id */\n    defs: Record<string, FillGradient>;\n}\n\n/**\n * Parses an SVG element or string and renders it to a graphics context.\n * Handles both SVG strings and SVG DOM elements as input.\n * @param svg - The SVG content to parse, either as a string or element\n * @param graphicsContext - Optional graphics context to render to\n * @returns The graphics context with the SVG rendered into it\n * @internal\n */\nexport function SVGParser(\n    svg: string | SVGElement | SVGSVGElement,\n    graphicsContext?: GraphicsContext\n): GraphicsContext\n{\n    // Convert string input to SVG element\n    if (typeof svg === 'string')\n    {\n        // eslint-disable-next-line no-restricted-globals\n        const div = document.createElement('div');\n\n        div.innerHTML = svg.trim();\n        svg = div.querySelector('svg') as SVGElement;\n    }\n\n    // Initialize parsing session\n    const session = {\n        context: graphicsContext,\n        defs: {},\n        path: new GraphicsPath(),\n    };\n\n    // Parse definitions (gradients, etc) first\n    parseSVGDefinitions(svg, session);\n\n    // Process all child elements except defs\n    const children = svg.children;\n\n    const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i] as SVGElement;\n\n        if (child.nodeName.toLowerCase() === 'defs') continue;\n        renderChildren(child, session, fillStyle, strokeStyle);\n    }\n\n    return graphicsContext;\n}\n\n/**\n * Recursively renders SVG elements and their children.\n * Handles styling inheritance and different SVG shape types.\n * @param svg - The SVG element to render\n * @param session - The current parsing session\n * @param fillStyle - The inherited fill style\n * @param strokeStyle - The inherited stroke style\n */\nfunction renderChildren(svg: SVGElement, session: Session, fillStyle: FillStyle, strokeStyle: StrokeStyle): void\n{\n    const children = svg.children;\n\n    // Parse element's style and merge with inherited styles\n    const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);\n\n    if (f1 && fillStyle)\n    {\n        fillStyle = { ...fillStyle, ...f1 };\n    }\n    else if (f1)\n    {\n        fillStyle = f1;\n    }\n\n    if (s1 && strokeStyle)\n    {\n        strokeStyle = { ...strokeStyle, ...s1 };\n    }\n    else if (s1)\n    {\n        strokeStyle = s1;\n    }\n\n    const noStyle = !fillStyle && !strokeStyle;\n\n    // Default to black fill if no styles specified\n    if (noStyle)\n    {\n        fillStyle = { color: 0 };\n    }\n\n    // Variables for shape attributes\n    let x;\n    let y;\n    let x1;\n    let y1;\n    let x2;\n    let y2;\n    let cx;\n    let cy;\n    let r;\n    let rx;\n    let ry;\n    let points;\n    let pointsString;\n    let d;\n    let graphicsPath;\n    let width;\n    let height;\n\n    // Handle different SVG element types\n    switch (svg.nodeName.toLowerCase())\n    {\n        case 'path':\n        {\n            d = svg.getAttribute('d') as string;\n\n            const fillRule = svg.getAttribute('fill-rule') as string;\n\n            const subpaths = extractSubpaths(d);\n            const hasExplicitEvenodd = fillRule === 'evenodd';\n            const hasMultipleSubpaths = subpaths.length > 1;\n\n            const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;\n\n            if (shouldProcessHoles)\n            {\n                const subpathsWithArea = subpaths.map((subpath) => ({\n                    path: subpath,\n                    area: calculatePathArea(subpath)\n                }));\n\n                subpathsWithArea.sort((a, b) => b.area - a.area);\n\n                // For complex cases, prefer multiple holes approach\n                const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);\n\n                if (useMultipleHolesApproach)\n                {\n                    // Multiple holes approach: first (largest) is fill, rest are holes\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isMainShape = i === 0;\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isMainShape)\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                        else\n                        {\n                            session.context.cut();\n                        }\n                    }\n                }\n                else\n                {\n                    // Nested holes approach: alternate between fill and cut\n                    for (let i = 0; i < subpathsWithArea.length; i++)\n                    {\n                        const subpath = subpathsWithArea[i];\n                        const isHole = i % 2 === 1; // Odd indices are holes\n\n                        session.context.beginPath();\n                        const newPath = new GraphicsPath(undefined, true); // Always use evenodd for hole processing\n\n                        appendSVGPath(subpath.path, newPath);\n                        session.context.path(newPath);\n\n                        if (isHole)\n                        {\n                            session.context.cut();\n                        }\n                        else\n                        {\n                            if (fillStyle) session.context.fill(fillStyle);\n                            if (strokeStyle) session.context.stroke(strokeStyle);\n                        }\n                    }\n                }\n            }\n            else\n            {\n                const useEvenoddForGraphicsPath = fillRule ? (fillRule === 'evenodd') : true;\n\n                graphicsPath = new GraphicsPath(d, useEvenoddForGraphicsPath);\n                session.context.path(graphicsPath);\n                if (fillStyle) session.context.fill(fillStyle);\n                if (strokeStyle) session.context.stroke(strokeStyle);\n            }\n            break;\n        }\n\n        case 'circle':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            r = parseSVGFloatAttribute(svg, 'r', 0);\n            session.context.ellipse(cx, cy, r, r);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'rect':\n            x = parseSVGFloatAttribute(svg, 'x', 0);\n            y = parseSVGFloatAttribute(svg, 'y', 0);\n            width = parseSVGFloatAttribute(svg, 'width', 0);\n            height = parseSVGFloatAttribute(svg, 'height', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            if (rx || ry)\n            {\n                session.context.roundRect(x, y, width, height, rx || ry);\n            }\n            else\n            {\n                session.context.rect(x, y, width, height);\n            }\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'ellipse':\n            cx = parseSVGFloatAttribute(svg, 'cx', 0);\n            cy = parseSVGFloatAttribute(svg, 'cy', 0);\n            rx = parseSVGFloatAttribute(svg, 'rx', 0);\n            ry = parseSVGFloatAttribute(svg, 'ry', 0);\n\n            session.context.beginPath();\n            session.context.ellipse(cx, cy, rx, ry);\n\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'line':\n            x1 = parseSVGFloatAttribute(svg, 'x1', 0);\n            y1 = parseSVGFloatAttribute(svg, 'y1', 0);\n            x2 = parseSVGFloatAttribute(svg, 'x2', 0);\n            y2 = parseSVGFloatAttribute(svg, 'y2', 0);\n\n            session.context.beginPath();\n            session.context.moveTo(x1, y1);\n            session.context.lineTo(x2, y2);\n\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polygon':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, true);\n            if (fillStyle) session.context.fill(fillStyle);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        case 'polyline':\n            pointsString = svg.getAttribute('points') as string;\n            points = pointsString.match(/\\d+/g).map((n) => parseInt(n, 10));\n            session.context.poly(points, false);\n            if (strokeStyle) session.context.stroke(strokeStyle);\n            break;\n\n        // Group elements - just process children\n        case 'g':\n        case 'svg':\n            break;\n\n        default: {\n            // Log unsupported elements\n            warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);\n            break;\n        }\n    }\n\n    if (noStyle)\n    {\n        fillStyle = null;\n    }\n\n    // Recursively process child elements\n    for (let i = 0; i < children.length; i++)\n    {\n        renderChildren(children[i] as SVGElement, session, fillStyle, strokeStyle);\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\nfunction isTexture(value: unknown): value is Texture\n{\n    return value instanceof Texture;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a Texture\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new Texture(0xff0000))\n */\nfunction handleTexture(fill: FillStyle, value: Texture, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    fill.texture = value;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n    fill.textureSpace = value.textureSpace;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isTexture(value))\n    {\n        return handleTexture(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        pixelLine,\n        ...fill,\n    };\n}\n", "/* eslint-disable max-len */\nimport EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../../color/Color';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { uid } from '../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Bounds } from '../../container/bounds/Bounds';\nimport { GraphicsPath } from './path/GraphicsPath';\nimport { SVGParser } from './svg/SVGParser';\nimport { toFillStyle, toStrokeStyle } from './utils/convertFillInputToFillStyle';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { TextureDestroyOptions, TypeOrBool } from '../../container/destroyTypes';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle, FillInput, StrokeInput } from './FillTypes';\nimport type { RoundedPoint } from './path/roundShape';\n\nconst tmpPoint = new Point();\n\n/**\n * The mode for batching graphics instructions.\n *\n * It can be:\n * - 'auto': Automatically determines whether to batch based on the number of instructions.\n * - 'batch': Forces batching of all instructions.\n * - 'no-batch': Disables batching, processing each instruction individually.\n * @category scene\n * @advanced\n */\nexport type BatchMode = 'auto' | 'batch' | 'no-batch';\n\n/** @internal */\nexport interface FillInstruction\n{\n    action: 'fill' | 'cut'\n    data: { style: ConvertedFillStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface StrokeInstruction\n{\n    action: 'stroke'\n    data: { style: ConvertedStrokeStyle, path: GraphicsPath, hole?: GraphicsPath }\n}\n\n/** @internal */\nexport interface TextureInstruction\n{\n    action: 'texture'\n    data: {\n        image: Texture,\n\n        dx: number\n        dy: number\n\n        dw: number\n        dh: number\n\n        transform: Matrix\n        alpha: number\n        style: number,\n    }\n}\n\n/** @internal */\nexport type GraphicsInstructions = FillInstruction | StrokeInstruction | TextureInstruction;\n\nconst tempMatrix = new Matrix();\n\n/**\n * The GraphicsContext class allows for the creation of lightweight objects that contain instructions for drawing shapes and paths.\n * It is used internally by the Graphics class to draw shapes and paths, and can be used directly and shared between Graphics objects,\n *\n * This sharing of a `GraphicsContext` means that the intensive task of converting graphics instructions into GPU-ready geometry is done once, and the results are reused,\n * much like sprites reusing textures.\n * @category scene\n * @standard\n */\nexport class GraphicsContext extends EventEmitter<{\n    update: GraphicsContext\n    destroy: GraphicsContext\n}>\n{\n    /** The default fill style to use when none is provided. */\n    public static defaultFillStyle: ConvertedFillStyle = {\n        /** The color to use for the fill. */\n        color: 0xffffff,\n        /** The alpha value to use for the fill. */\n        alpha: 1,\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n    };\n\n    /** The default stroke style to use when none is provided. */\n    public static defaultStrokeStyle: ConvertedStrokeStyle = {\n        /** The width of the stroke. */\n        width: 1,\n        /** The color to use for the stroke. */\n        color: 0xffffff,\n        /** The alpha value to use for the stroke. */\n        alpha: 1,\n        /** The alignment of the stroke. */\n        alignment: 0.5,\n        /** The miter limit to use. */\n        miterLimit: 10,\n        /** The line cap style to use. */\n        cap: 'butt',\n        /** The line join style to use. */\n        join: 'miter',\n        /** The texture to use for the fill. */\n        texture: Texture.WHITE,\n        /** The matrix to apply. */\n        matrix: null,\n        /** The fill pattern to use. */\n        fill: null,\n        /** Whether coordinates are 'global' or 'local' */\n        textureSpace: 'local',\n        /** If the stroke is a pixel line. */\n        pixelLine: false,\n    };\n\n    /**\n     * unique id for this graphics context\n     * @internal\n     */\n    public readonly uid: number = uid('graphicsContext');\n    /**\n     * Indicates whether content is updated and have to be re-rendered.\n     * @internal\n     */\n    public dirty = true;\n    /** The batch mode for this graphics context. It can be 'auto', 'batch', or 'no-batch'. */\n    public batchMode: BatchMode = 'auto';\n    /** @internal */\n    public instructions: GraphicsInstructions[] = [];\n    /**\n     * Custom shader to apply to the graphics when rendering.\n     * @advanced\n     */\n    public customShader?: Shader;\n\n    private _activePath: GraphicsPath = new GraphicsPath();\n    private _transform: Matrix = new Matrix();\n\n    private _fillStyle: ConvertedFillStyle = { ...GraphicsContext.defaultFillStyle };\n    private _strokeStyle: ConvertedStrokeStyle = { ...GraphicsContext.defaultStrokeStyle };\n    private _stateStack: { fillStyle: ConvertedFillStyle; strokeStyle: ConvertedStrokeStyle, transform: Matrix }[] = [];\n\n    private _tick = 0;\n\n    private _bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,\n     * including the current drawing state, transformations, styles, and instructions.\n     * @returns A new GraphicsContext instance with the same properties and state as this one.\n     */\n    public clone(): GraphicsContext\n    {\n        const clone = new GraphicsContext();\n\n        clone.batchMode = this.batchMode;\n        clone.instructions = this.instructions.slice();\n        clone._activePath = this._activePath.clone();\n        clone._transform = this._transform.clone();\n        clone._fillStyle = { ...this._fillStyle };\n        clone._strokeStyle = { ...this._strokeStyle };\n        clone._stateStack = this._stateStack.slice();\n        clone._bounds = this._bounds.clone();\n        clone._boundsDirty = true;\n\n        return clone;\n    }\n\n    /**\n     * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.\n     */\n    get fillStyle(): ConvertedFillStyle\n    {\n        return this._fillStyle;\n    }\n\n    set fillStyle(value: FillInput)\n    {\n        this._fillStyle = toFillStyle(value, GraphicsContext.defaultFillStyle);\n    }\n\n    /**\n     * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     */\n    get strokeStyle(): ConvertedStrokeStyle\n    {\n        return this._strokeStyle;\n    }\n\n    set strokeStyle(value: FillInput)\n    {\n        this._strokeStyle = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n    }\n\n    /**\n     * Sets the current fill style of the graphics context. The fill style can be a color, gradient,\n     * pattern, or a more complex style defined by a FillStyle object.\n     * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,\n     *                or a FillStyle or ConvertedFillStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setFillStyle(style: FillInput): this\n    {\n        this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n\n        return this;\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can\n     * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.\n     * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,\n     *                or a StrokeStyle or ConvertedStrokeStyle object.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setStrokeStyle(style: StrokeInput): this\n    {\n        this._strokeStyle = toFillStyle(style, GraphicsContext.defaultStrokeStyle) as ConvertedStrokeStyle;\n\n        return this;\n    }\n\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture.\n     * If only a texture is provided, it uses the texture's width and height for drawing.\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture): this;\n    /**\n     * Adds a texture to the graphics context. This method supports multiple overloads for specifying the texture,\n     * tint, and dimensions. If only a texture is provided, it uses the texture's width and height for drawing.\n     * Additional parameters allow for specifying a tint color, and custom dimensions for the texture drawing area.\n     * @param texture - The Texture object to use.\n     * @param tint - (Optional) A ColorSource to tint the texture. If not provided, defaults to white (0xFFFFFF).\n     * @param dx - (Optional) The x-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dy - (Optional) The y-coordinate in the destination canvas at which to place the top-left corner of\n     * the source image.\n     * @param dw - (Optional) The width of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame width.\n     * @param dh - (Optional) The height of the rectangle within the source image to draw onto the destination canvas.\n     * If not provided, uses the texture's frame height.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this\n    {\n        this.instructions.push({\n            action: 'texture',\n            data: {\n                image: texture,\n\n                dx: dx || 0,\n                dy: dy || 0,\n\n                dw: dw || texture.frame.width,\n                dh: dh || texture.frame.height,\n\n                transform: this._transform.clone(),\n                alpha: this._fillStyle.alpha,\n                style: tint ? Color.shared.setValue(tint).toNumber() : 0xFFFFFF,\n            }\n        });\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public beginPath(): this\n    {\n        this._activePath = new GraphicsPath();\n\n        return this;\n    }\n\n    /**\n     * Fills the current or given path with the current fill style. This method can optionally take\n     * a color and alpha for a simple fill, or a more complex FillInput object for advanced fills.\n     * @param style - (Optional) The style to fill the path with. Can be a color, gradient, pattern, or a complex style object. If omitted, uses the current fill style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha: number): this;\n    public fill(style?: FillInput, alpha?: number): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'stroke')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            if (alpha !== undefined && typeof style === 'number')\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead');\n                // #endif\n\n                style = { color: style, alpha };\n            }\n            this._fillStyle = toFillStyle(style, GraphicsContext.defaultFillStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'fill',\n            // TODO copy fill style!\n            data: { style: this.fillStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    private _initNextPathLocation()\n    {\n        // Reset the _activePath with the last point of the current path\n        const { x, y } = this._activePath.getLastPoint(Point.shared);\n\n        this._activePath.clear();\n        this._activePath.moveTo(x, y);\n    }\n\n    /**\n     * Strokes the current path with the current stroke style. This method can take an optional\n     * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.\n     * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public stroke(style?: StrokeInput): this\n    {\n        let path: GraphicsPath;\n\n        const lastInstruction = this.instructions[this.instructions.length - 1];\n\n        if (this._tick === 0 && lastInstruction && lastInstruction.action === 'fill')\n        {\n            path = lastInstruction.data.path;\n        }\n        else\n        {\n            path = this._activePath.clone();\n        }\n\n        if (!path) return this;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style != null)\n        {\n            this._strokeStyle = toStrokeStyle(style, GraphicsContext.defaultStrokeStyle);\n        }\n\n        // TODO not a fan of the clone!!\n        this.instructions.push({\n            action: 'stroke',\n            // TODO copy fill style!\n            data: { style: this.strokeStyle, path }\n        });\n\n        this.onUpdate();\n\n        this._initNextPathLocation();\n        this._tick = 0;\n\n        return this;\n    }\n\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will\n     * fail to cut correctly!\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public cut(): this\n    {\n        for (let i = 0; i < 2; i++)\n        {\n            const lastInstruction = this.instructions[this.instructions.length - 1 - i];\n\n            const holePath = this._activePath.clone();\n\n            if (lastInstruction)\n            {\n                if (lastInstruction.action === 'stroke' || lastInstruction.action === 'fill')\n                {\n                    if (lastInstruction.data.hole)\n                    {\n                        lastInstruction.data.hole.addPath(holePath);\n                    }\n                    else\n                    {\n                        lastInstruction.data.hole = holePath;\n                        break;\n                    }\n                }\n            }\n        }\n\n        this._initNextPathLocation();\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The arc's radius.\n     * @param startAngle - The starting angle, in radians.\n     * @param endAngle - The ending angle, in radians.\n     * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arc(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            radius,\n            startAngle,\n            endAngle,\n            counterclockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the current path with the given control points and radius, connected to the previous point\n     * by a straight line if necessary.\n     * @param x1 - The x-coordinate of the first control point.\n     * @param y1 - The y-coordinate of the first control point.\n     * @param x2 - The x-coordinate of the second control point.\n     * @param y2 - The y-coordinate of the second control point.\n     * @param radius - The arc's radius.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcTo(\n            (t.a * x1) + (t.c * y1) + t.tx,\n            (t.b * x1) + (t.d * y1) + t.ty,\n            (t.a * x2) + (t.c * y2) + t.tx,\n            (t.b * x2) + (t.d * y2) + t.ty,\n            radius,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number,\n        largeArcFlag: number,\n        sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.arcToSvg(\n            rx, ry,\n            xAxisRotation, // should we rotate this with transform??\n            largeArcFlag,\n            sweepFlag,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        // TODO optimize for no transform\n        const t = this._transform;\n\n        this._activePath.bezierCurveTo(\n            (t.a * cp1x) + (t.c * cp1y) + t.tx,\n            (t.b * cp1x) + (t.d * cp1y) + t.ty,\n            (t.a * cp2x) + (t.c * cp2y) + t.tx,\n            (t.b * cp2x) + (t.d * cp2y) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this._tick++;\n\n        this._activePath?.closePath();\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this\n    {\n        this._tick++;\n\n        this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number): this\n    {\n        this._tick++;\n\n        this._activePath.circle(x, y, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * @param path - The `GraphicsPath` to add.\n     * @returns The instance of the current object for chaining.\n     */\n    public path(path: GraphicsPath): this\n    {\n        this._tick++;\n\n        this._activePath.addPath(path, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.lineTo(\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty\n        );\n\n        return this;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        const instructions = this._activePath.instructions;\n\n        const transformedX = (t.a * x) + (t.c * y) + t.tx;\n        const transformedY = (t.b * x) + (t.d * y) + t.ty;\n\n        if (instructions.length === 1 && instructions[0].action === 'moveTo')\n        {\n            instructions[0].data[0] = transformedX;\n            instructions[0].data[1] = transformedY;\n\n            return this;\n        }\n        this._activePath.moveTo(\n            transformedX,\n            transformedY\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cpx - The x-coordinate of the control point.\n     * @param cpy - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this\n    {\n        this._tick++;\n\n        const t = this._transform;\n\n        this._activePath.quadraticCurveTo(\n            (t.a * cpx) + (t.c * cpy) + t.tx,\n            (t.b * cpx) + (t.d * cpy) + t.ty,\n            (t.a * x) + (t.c * y) + t.tx,\n            (t.b * x) + (t.d * y) + t.ty,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number): this\n    {\n        this._tick++;\n\n        this._activePath.rect(x, y, w, h, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this\n    {\n        this._tick++;\n\n        this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates, of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this\n    {\n        this._tick++;\n\n        this._activePath.poly(points, close, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.regularPoly(x, y, radius, sides, rotation, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this\n    {\n        this._tick++;\n        this._activePath.roundPoly(x, y, radius, sides, corner, rotation);\n\n        return this;\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this\n    {\n        this._tick++;\n        this._activePath.roundShape(points, radius, useQuadratic, smoothness);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        this._tick++;\n        this._activePath.filletRect(x, y, width, height, fillet);\n\n        return this;\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        this._tick++;\n        this._activePath.chamferRect(x, y, width, height, chamfer, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @param x - The x-coordinate of the center of the star.\n     * @param y - The y-coordinate of the center of the star.\n     * @param points - The number of points of the star.\n     * @param radius - The outer radius of the star (distance from the center to the outer points).\n     * @param innerRadius - Optional. The inner radius of the star\n     * (distance from the center to the inner points between the outer points).\n     * If not provided, defaults to half of the `radius`.\n     * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.\n     * Defaults to 0, meaning one point is directly upward.\n     * @returns The instance of the current object for chaining further drawing commands.\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius = 0, rotation = 0): this\n    {\n        this._tick++;\n\n        this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());\n\n        return this;\n    }\n\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths\n     * defined in SVG format to be drawn within the graphics context.\n     * @param svg - The SVG string to be parsed and rendered.\n     */\n    public svg(svg: string): this\n    {\n        this._tick++;\n\n        SVGParser(svg, this);\n\n        return this;\n    }\n\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     */\n    public restore(): this\n    {\n        const state = this._stateStack.pop();\n\n        if (state)\n        {\n            this._transform = state.transform;\n            this._fillStyle = state.fillStyle;\n            this._strokeStyle = state.strokeStyle;\n        }\n\n        return this;\n    }\n\n    /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */\n    public save(): this\n    {\n        this._stateStack.push({\n            transform: this._transform.clone(),\n            fillStyle: { ...this._fillStyle },\n            strokeStyle: { ...this._strokeStyle },\n        });\n\n        return this;\n    }\n\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * @returns The current transformation matrix.\n     */\n    public getTransform(): Matrix\n    {\n        return this._transform;\n    }\n\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public resetTransform(): this\n    {\n        this._transform.identity();\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * @param angle - The angle of rotation in radians.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public rotate(angle: number): this\n    {\n        this._transform.rotate(angle);\n\n        return this;\n    }\n\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.\n     * @param x - The scale factor in the horizontal direction.\n     * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this._transform.scale(x, y);\n\n        return this;\n    }\n\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty);\n\n            return this;\n        }\n\n        this._transform.set(a, b, c, d, dx, dy);\n\n        return this;\n    }\n\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this\n    {\n        if (a instanceof Matrix)\n        {\n            this._transform.append(a);\n\n            return this;\n        }\n\n        tempMatrix.set(a, b, c, d, dx, dy);\n        this._transform.append(tempMatrix);\n\n        return this;\n    }\n\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * @param x - The amount to translate in the horizontal direction.\n     * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public translate(x: number, y: number = x): this\n    {\n        this._transform.translate(x, y);\n\n        return this;\n    }\n\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,\n     * and optionally resetting transformations to the identity matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public clear(): this\n    {\n        this._activePath.clear();\n        this.instructions.length = 0;\n        this.resetTransform();\n\n        this.onUpdate();\n\n        return this;\n    }\n\n    protected onUpdate(): void\n    {\n        // Every time the content is updated - we must invalidate bounds, regardless rendering `dirty` state.\n        // Bounds can be read multiple times per frame.\n        this._boundsDirty = true;\n\n        // Visual updates happen only once per frame.\n        // There is no need to dispatch an `update` in if it was already dispatched this frame.\n        if (this.dirty) return;\n        this.emit('update', this, 0x10);\n        this.dirty = true;\n    }\n\n    /** The bounds of the graphic shape. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        // TODO switch to idy dirty with tick..\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        for (let i = 0; i < this.instructions.length; i++)\n        {\n            const instruction = this.instructions[i];\n            const action = instruction.action;\n\n            if (action === 'fill')\n            {\n                const data = instruction.data as FillInstruction['data'];\n\n                bounds.addBounds(data.path.bounds);\n            }\n            else if (action === 'texture')\n            {\n                const data = instruction.data as TextureInstruction['data'];\n\n                bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);\n            }\n            if (action === 'stroke')\n            {\n                const data = instruction.data as StrokeInstruction['data'];\n\n                const alignment = data.style.alignment;\n\n                const outerPadding = (data.style.width * (1 - alignment));\n\n                const _bounds = data.path.bounds;\n\n                bounds.addFrame(\n                    _bounds.minX - outerPadding,\n                    _bounds.minY - outerPadding,\n                    _bounds.maxX + outerPadding,\n                    _bounds.maxY + outerPadding\n                );\n            }\n        }\n\n        return bounds;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     * @param point - Point to check if it's contained.\n     * @returns {boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: PointData): boolean\n    {\n        // early out if the bounding box is not hit\n        if (!this.bounds.containsPoint(point.x, point.y)) return false;\n\n        const instructions = this.instructions;\n        let hasHit = false;\n\n        for (let k = 0; k < instructions.length; k++)\n        {\n            const instruction = instructions[k];\n\n            const data = instruction.data as FillInstruction['data'];\n            const path = data.path;\n\n            if (!instruction.action || !path) continue;\n\n            const style = data.style;\n            const shapes = path.shapePath.shapePrimitives;\n\n            for (let i = 0; i < shapes.length; i++)\n            {\n                const shape = shapes[i].shape;\n\n                if (!style || !shape) continue;\n\n                const transform = shapes[i].transform;\n\n                const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;\n\n                if (instruction.action === 'fill')\n                {\n                    hasHit = shape.contains(transformedPoint.x, transformedPoint.y);\n                }\n                else\n                {\n                    const strokeStyle = (style as ConvertedStrokeStyle);\n\n                    hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);\n                }\n\n                const holes = data.hole;\n\n                if (holes)\n                {\n                    const holeShapes = holes.shapePath?.shapePrimitives;\n\n                    if (holeShapes)\n                    {\n                        for (let j = 0; j < holeShapes.length; j++)\n                        {\n                            if (holeShapes[j].shape.contains(transformedPoint.x, transformedPoint.y))\n                            {\n                                hasHit = false;\n                            }\n                        }\n                    }\n                }\n\n                if (hasHit)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return hasHit;\n    }\n\n    /**\n     * Destroys the GraphicsData object.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * context.destroy();\n     * context.destroy(true);\n     * context.destroy({ texture: true, textureSource: true });\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false): void\n    {\n        this._stateStack.length = 0;\n        this._transform = null;\n\n        this.emit('destroy', this);\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fillStyle.texture)\n            {\n                this._fillStyle.fill && 'uid' in this._fillStyle.fill\n                    ? this._fillStyle.fill.destroy()\n                    : this._fillStyle.texture.destroy(destroyTextureSource);\n            }\n\n            if (this._strokeStyle.texture)\n            {\n                this._strokeStyle.fill && 'uid' in this._strokeStyle.fill\n                    ? this._strokeStyle.fill.destroy()\n                    : this._strokeStyle.texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fillStyle = null;\n        this._strokeStyle = null;\n\n        this.instructions = null;\n        this._activePath = null;\n        this._bounds = null;\n        this._stateStack = null;\n        this.customShader = null;\n        this._transform = null;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { type Filter } from '../../filters/Filter';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport { toFillStyle, toStrokeStyle } from '../graphics/shared/utils/convertFillInputToFillStyle';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\n/**\n * The alignment of the text.\n *\n * - 'left': Aligns text to the left edge.\n * - 'center': Centers text horizontally.\n * - 'right': Aligns text to the right edge.\n * - 'justify': Justifies text, aligning both left and right edges.\n * @example\n * ```ts\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   align: 'center', // or 'left', 'right', 'justify'\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\n/**\n * The fill style input for text styles.\n *\n * This can be:\n * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n * - A hex number like 0xff0000 for red\n * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n * - A FillGradient for gradient fills\n * - A FillPattern for pattern/texture fills\n * @example\n * ```ts\n * // Simple Fills\n * new TextStyle({ fill: 'red' }); // Color string\n * new TextStyle({ fill: 0x00ff00 }); // Hex color\n * new TextStyle({ fill: 'rgb(255,0,0)' }); // RGB string\n * // Gradients\n * new TextStyle({\n *     fill: new FillGradient({\n *         end: { x: 1, y: 1 },\n *         stops: [\n *             { color: 0xff0000, offset: 0 }, // Red at start\n *             { color: 0x0000ff, offset: 1 }, // Blue at end\n *         ]\n *     }),\n * });\n * // Patterns\n * new TextStyle({\n *    fill: new FillPattern(Assets.get('pattern.png'))\n * });\n * ```\n * @category text\n * @standard\n */\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\n/**\n * The font style input for text styles. Controls the slant or italicization of the text.\n * @example\n * ```ts\n * // Create text with normal font style\n * const normalText = new Text({\n *     text: 'Normal Style Text',\n *     style: {\n *         fontStyle: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create italic text\n * const italicText = new Text({\n *     text: 'Italic Style Text',\n *     style: {\n *         fontStyle: 'italic',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Create oblique text\n * const obliqueText = new Text({\n *     text: 'Oblique Style Text',\n *     style: {\n *         fontStyle: 'oblique',\n *         fontSize: 24,\n *         fontFamily: 'Times New Roman'\n *     }\n * });\n *\n * // Dynamic style changes\n * let isItalic = false;\n * text.style = {\n *     ...text.style,\n *     fontStyle: isItalic ? 'italic' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular upright text with no slant\n * - 'italic': True italics using specifically designed italic glyphs\n * - 'oblique': Slanted version of the regular glyphs\n * @remarks\n * - 'italic' uses specially designed glyphs with cursive characteristics\n * - 'oblique' is a mechanical slant of the normal glyphs\n * - Not all fonts include true italic designs; some may fall back to oblique\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style | MDN font-style}\n * @category text\n * @standard\n */\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\n/**\n * The font variant input for text styles. Controls the capitalization and presentation of letters.\n * Used to enable special rendering like small caps.\n * @example\n * ```ts\n * // Create text with normal font variant\n * const normalText = new Text({\n *     text: 'Normal Text',\n *     style: {\n *         fontVariant: 'normal',\n *         fontSize: 24\n *     }\n * });\n *\n * // Create text with small-caps variant\n * const smallCapsText = new Text({\n *     text: 'Small Caps Text',\n *     style: {\n *         fontVariant: 'small-caps',\n *         fontSize: 24,\n *         fontFamily: 'Arial'\n *     }\n * });\n *\n * // Use in a TextStyle instance\n * const style = new TextStyle({\n *     fontVariant: 'small-caps',\n *     fontSize: 32,\n *     fill: 0x4a4a4a\n * });\n *\n * // Update variant dynamically\n * text.style = {\n *     ...text.style,\n *     fontVariant: text.style.fontVariant === 'normal' ? 'small-caps' : 'normal'\n * };\n * ```\n *\n * Supported values:\n * - 'normal': Regular text rendering with standard capitalization\n * - 'small-caps': Renders lowercase letters as smaller versions of capital letters\n * @remarks\n * Small caps are only available if the font supports them.\n * Not all fonts include true small caps glyphs.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant | MDN font-variant}\n * @category text\n * @standard\n */\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n/**\n * The font weight input for text styles. Controls the thickness or boldness of the text.\n * @example\n * ```ts\n * // Create text with different font weights\n * const normalText = new Text({\n *     text: 'Normal Weight',\n *     style: { fontWeight: 'normal' }\n * });\n *\n * const boldText = new Text({\n *     text: 'Bold Weight',\n *     style: { fontWeight: 'bold' }\n * });\n *\n * // Using numeric weights\n * const lightText = new Text({\n *     text: 'Light Weight',\n *     style: { fontWeight: '300' }\n * });\n *\n * const mediumText = new Text({\n *     text: 'Medium Weight',\n *     style: { fontWeight: '500' }\n * });\n *\n * const heavyText = new Text({\n *     text: 'Heavy Weight',\n *     style: { fontWeight: '900' }\n * });\n *\n * // Responsive weight changes\n * const adaptiveText = new Text({\n *     text: 'Adaptive Weight',\n *     style: { fontWeight: window.innerWidth > 600 ? 'bold' : 'normal' }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Standard weight (equivalent to 400)\n * - 'bold': Bold weight (equivalent to 700)\n * - 'bolder': One weight darker than the parent element\n * - 'lighter': One weight lighter than the parent element\n * - '100': Thin (Hairline)\n * - '200': Extra Light (Ultra Light)\n * - '300': Light\n * - '400': Normal\n * - '500': Medium\n * - '600': Semi Bold (Demi Bold)\n * - '700': Bold\n * - '800': Extra Bold (Ultra Bold)\n * - '900': Heavy (Black)\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight | MDN font-weight}\n * @category text\n * @standard\n */\nexport type TextStyleFontWeight =\n    | 'normal' // Standard weight (400)\n    | 'bold' // Bold weight (700)\n    | 'bolder' // Relative weight increase\n    | 'lighter' // Relative weight decrease\n    | '100' // Thin\n    | '200' // Extra Light\n    | '300' // Light\n    | '400' // Normal\n    | '500' // Medium\n    | '600' // Semi Bold\n    | '700' // Bold\n    | '800' // Extra Bold\n    | '900'; // Heavy\n/**\n * The line join style for text strokes. Determines how lines connect at corners.\n * @example\n * ```ts\n * // Create text with miter joins (sharp corners)\n * const sharpText = new Text({\n *     text: 'Sharp Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'miter'  // Sharp corners\n *         }\n *     }\n * });\n *\n * // Create text with round joins\n * const roundText = new Text({\n *     text: 'Rounded Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'round'  // Smooth rounded corners\n *         }\n *     }\n * });\n *\n * // Create text with beveled joins\n * const bevelText = new Text({\n *     text: 'Beveled Corners',\n *     style: {\n *         fontSize: 36,\n *         stroke: {\n *             color: '#4a1850',\n *             width: 4,\n *             lineJoin: 'bevel'  // Flattened corners\n *         }\n *     }\n * });\n * ```\n * Available values:\n * - 'miter': Creates sharp corners by extending the outer edges until they meet\n * - 'round': Creates smooth, rounded corners using a circular arc\n * - 'bevel': Creates flattened corners by filling an additional triangle between the outer edges\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin | MDN lineJoin}\n * @category text\n * @standard\n */\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\n/**\n * The text baseline for text styles.\n *\n * This can be:\n * - 'alphabetic': The alphabetic baseline\n * - 'top': The top of the text\n * - 'hanging': The hanging baseline\n * - 'middle': The middle of the text\n * - 'ideographic': The ideographic baseline\n * - 'bottom': The bottom of the text\n * @category text\n * @standard\n */\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\n/**\n * Controls how whitespace (spaces, tabs, and line breaks) is handled within the text.\n * This affects text wrapping and spacing behavior.\n * @example\n * ```ts\n * // Normal mode (collapse spaces and newlines)\n * const normalText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'normal',\n *         fontSize: 24\n *     }\n * }); // Renders as: \"Hello World New Line\"\n *\n * // Pre mode (preserve all whitespace)\n * const preText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre',\n *         fontSize: 24\n *     }\n * }); // Preserves spaces and line breaks exactly\n *\n * // Pre-line mode (preserve newlines, collapse spaces)\n * const preLineText = new Text({\n *     text: 'Hello    World\\n\\nNew Line',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         fontSize: 24\n *     }\n * }); // Preserves line breaks, collapses multiple spaces\n *\n * // With word wrap enabled\n * const wrappedText = new Text({\n *     text: 'A long text with    multiple spaces\\nand line breaks',\n *     style: {\n *         whiteSpace: 'pre-line',\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         fontSize: 24\n *     }\n * });\n * ```\n *\n * Supported values:\n * - 'normal': Collapses all whitespace (spaces, tabs, line breaks) into a single space\n * - 'pre': Preserves all whitespace characters exactly as written\n * - 'pre-line': Preserves line breaks but collapses multiple spaces into a single space\n * @remarks\n * - 'normal' is best for single-line text or when you want to ignore formatting\n * - 'pre' is useful for code blocks or when exact spacing is important\n * - 'pre-line' is good for formatted text where you want to keep line breaks but clean up spaces\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space | MDN white-space}\n * @see {@link TextStyle#wordWrap} For controlling text wrapping\n * @category text\n * @standard\n */\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * Defines a drop shadow effect for text rendering.\n * Drop shadows add depth and emphasis to text by creating a shadow offset from the text.\n * @example\n * ```ts\n * // Create text with basic drop shadow\n * const text = new Text({\n *     text: 'Shadow Text',\n *     style: {\n *         fontSize: 48,\n *         dropShadow: {\n *             alpha: 0.5,         // 50% opacity shadow\n *             angle: Math.PI / 6, // 30 degrees\n *             blur: 4,            // Soft shadow edge\n *             color: '#000000',   // Black shadow\n *             distance: 6         // Shadow offset\n *         }\n *     }\n * });\n *\n * // Dynamic shadow updates\n * text.style.dropShadow = {\n *     alpha: Math.sin(Date.now() / 1000) * 0.5 + 0.5, // Pulsing opacity\n *     angle: Date.now() / 1000,                        // Rotating angle\n *     blur: 4,\n *     color: '#000000',\n *     distance: 6\n * };\n * ```\n * @category text\n * @standard\n */\nexport type TextDropShadow = {\n    /**\n     * The opacity of the drop shadow.\n     * - Range: 0 to 1\n     * - 0 = fully transparent\n     * - 1 = fully opaque\n     * @example\n     * ```ts\n     * // Set drop shadow opacity to 50%\n     * dropShadow: {\n     *    alpha: 0.5\n     * }\n     * ```\n     * @default 1\n     */\n    alpha: number;\n\n    /**\n     * The angle of the drop shadow in radians.\n     * - 0 = right\n     * - Math.PI/2 = down\n     * - Math.PI = left\n     * - Math.PI*1.5 = up\n     * @example\n     * ```ts\n     * // Set drop shadow angle to 30 degrees\n     * dropShadow: {\n     *    angle: Math.PI / 6 // 30 degrees\n     * }\n     * ```\n     * @default Math.PI/6 (30 degrees)\n     */\n    angle: number;\n\n    /**\n     * The blur radius of the shadow.\n     * - 0 = sharp shadow\n     * - Higher values = softer shadow\n     * @example\n     * ```ts\n     * // Set drop shadow blur radius to 10 pixels\n     * dropShadow: {\n     *   blur: 10\n     * }\n     * ```\n     * @default 0\n     */\n    blur: number;\n\n    /**\n     * The color of the drop shadow.\n     * Accepts any valid CSS color string, hex number, or RGB/RGBA values.\n     * @example '#000000', 'rgba(0,0,0,0.5)', 0x000000\n     * @default 'black'\n     */\n    color: ColorSource;\n\n    /**\n     * The distance of the drop shadow from the text.\n     * Measured in pixels.\n     * @example\n     * ```ts\n     * // Set drop shadow distance to 5 pixels\n     * dropShadow: {\n     *   distance: 5\n     * }\n     * ```\n     * @default 5\n     */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances. Defines the visual appearance and layout of text.\n * @example\n * ```ts\n * // Basic text style\n * const basicStyle = new TextStyle({\n *     fontSize: 24,\n *     fill: 'black',\n *     fontFamily: 'Arial'\n * });\n *\n * // Rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: ['Arial', 'Helvetica', 'sans-serif'],\n *     fontSize: 36,\n *     fontWeight: 'bold',\n *     fill: 'red',\n *     stroke: { color: '#4a1850', width: 5 },\n *     align: 'center',\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     textBaseline: 'middle'\n * });\n * ```\n * @see {@link TextStyle} For the main style class\n * @category text\n * @standard\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @default 'left'\n     */\n    align?: TextStyleAlign;\n    /**\n     * Whether to allow line breaks within words.\n     * Requires wordWrap to be true.\n     * @example\n     * ```ts\n     * // Enable word breaking\n     * const style = new TextStyle({\n     *    breakWords: true,\n     *    wordWrap: true,\n     *    wordWrapWidth: 200\n     * });\n     * ```\n     * @default false\n     */\n    breakWords?: boolean;\n    /**\n     * Drop shadow configuration for the text.\n     * Can be boolean or a TextDropShadow object.\n     * @default null\n     */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * Fill style for the text.\n     * Can be a color, gradient, or pattern.\n     * @default 'black'\n     */\n    fill?: FillInput;\n    /**\n     * Font family or families to use.\n     * Can be single name or array of fallbacks.\n     * @example\n     * ```ts\n     * // Single font family\n     * fontFamily: 'Arial'\n     * // Multiple font families\n     * fontFamily: ['Helvetica', 'Arial', 'sans-serif']\n     * ```\n     * @default 'Arial'\n     */\n    fontFamily?: string | string[];\n    /**\n     * Font size in pixels or as string.\n     *\n     * Equivalents are '26px','20pt','160%' or '1.6em')\n     * @example\n     * ```ts\n     * // Numeric size\n     * fontSize: 26\n     * // String size\n     * fontSize: '26px'\n     * // Percentage size\n     * fontSize: '160%' // 1.6 times the parent element's font size\n     * // Em size\n     * fontSize: '1.6em' // 1.6 times the parent element's font size\n     * @default 26\n     */\n    fontSize?: number | string;\n    /**\n     * Font style (normal, italic, oblique).\n     * @default 'normal'\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * Font variant (normal, small-caps).\n     * @default 'normal'\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * Font weight (normal, bold, bolder, lighter, 100-900).\n     * @default 'normal'\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Padding around the text.\n     *\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /**\n     * Stroke style for text outline.\n     * @default null\n     */\n    stroke?: StrokeInput;\n    /**\n     * Vertical alignment baseline.\n     * @default 'alphabetic'\n     */\n    textBaseline?: TextStyleTextBaseline;\n    /**\n     * Whether to trim transparent edges.\n     * > [!NOTE] This is an expensive operation and should only be used when necessary.\n     * @default false\n     */\n    trim?: boolean;\n    /**\n     * How to handle whitespace.\n     *\n     * It needs wordWrap to be set to true for this to have an effect.\n     * @default 'pre'\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n    /**\n     * Array of filters to apply to the text.\n     *\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default undefined\n     */\n    filters?: Filter[] | readonly Filter[];\n}\n\n/**\n * A TextStyle Object contains information to decorate Text objects.\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @example\n * ```ts\n * // Create a basic text style\n * const style = new TextStyle({\n *     fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *     fontSize: 36,\n *     fill: 0xff1010,\n *     align: 'center'\n * });\n *\n * // Create a rich text style with multiple features\n * const richStyle = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 32,\n *     fill: 'white',\n *     stroke: {\n *         color: '#4a1850',\n *         width: 5\n *     },\n *     dropShadow: {\n *         color: '#000000',\n *         blur: 4,\n *         distance: 6,\n *         angle: Math.PI / 6\n *     },\n *     wordWrap: true,\n *     wordWrapWidth: 440,\n *     lineHeight: 40,\n *     align: 'center'\n * });\n *\n * // Share style between multiple text objects\n * const text1 = new Text({\n *     text: 'Hello',\n *     style: richStyle\n * });\n *\n * const text2 = new Text({\n *     text: 'World',\n *     style: richStyle\n * });\n *\n * // Update style dynamically - affects all text objects\n * richStyle.fontSize = 48;\n * richStyle.fill = 0x00ff00;\n * ```\n *\n * Key Features:\n * - Shared styling between multiple text objects\n * - Rich text formatting options\n * - Gradient and pattern fills\n * - Drop shadows and strokes\n * - Word wrapping and alignment\n * - Dynamic updates\n * @category text\n * @standard\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /**\n     * Default drop shadow settings used when enabling drop shadows on text.\n     * These values are used as the base configuration when drop shadows are enabled without specific settings.\n     * @example\n     * ```ts\n     * // Customize default settings globally\n     * TextStyle.defaultDropShadow.alpha = 0.5;    // 50% opacity for all shadows\n     * TextStyle.defaultDropShadow.blur = 2;       // 2px blur for all shadows\n     * TextStyle.defaultDropShadow.color = 'blue'; // Blue shadows by default\n     * ```\n     */\n    public static defaultDropShadow: TextDropShadow = {\n        alpha: 1,\n        angle: Math.PI / 6,\n        blur: 0,\n        color: 'black',\n        distance: 5\n    };\n\n    /**\n     * Unique identifier for the TextStyle class.\n     * This is used to track instances and ensure uniqueness.\n     * @internal\n     */\n    public uid = uid('textStyle');\n    /**\n     * Internal tick counter used to track updates and changes.\n     * This is incremented whenever the style is modified, allowing for efficient change detection.\n     * @internal\n     */\n    public _tick = 0;\n\n    /**\n     * Default text style settings used when creating new text objects.\n     * These values serve as the base configuration and can be customized globally.\n     * @example\n     * ```ts\n     * // Customize default text style globally\n     * TextStyle.defaultTextStyle.fontSize = 16;\n     * TextStyle.defaultTextStyle.fill = 0x333333;\n     * TextStyle.defaultTextStyle.fontFamily = ['Arial', 'Helvetica', 'sans-serif'];\n     * ```\n     */\n    public static defaultTextStyle: TextStyleOptions = {\n        align: 'left',\n        breakWords: false,\n        dropShadow: null,\n        fill: 'black',\n        fontFamily: 'Arial',\n        fontSize: 26,\n        fontStyle: 'normal',\n        fontVariant: 'normal',\n        fontWeight: 'normal',\n        leading: 0,\n        letterSpacing: 0,\n        lineHeight: 0,\n        padding: 0,\n        stroke: null,\n        textBaseline: 'alphabetic',\n        trim: false,\n        whiteSpace: 'pre',\n        wordWrap: false,\n        wordWrapWidth: 100\n    };\n\n    // colors!!\n    /** @internal */\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    /** @internal */\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n    private _filters: readonly Filter[];\n\n    private _padding: number;\n\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n        this._tick = 0;\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n\n    set align(value: TextStyleAlign)\n    {\n        if (this._align === value) return;\n\n        this._align = value;\n        this.update();\n    }\n\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n\n    set breakWords(value: boolean)\n    {\n        if (this._breakWords === value) return;\n\n        this._breakWords = value;\n        this.update();\n    }\n\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (this._dropShadow === value) return;\n\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n\n    set fontFamily(value: string | string[])\n    {\n        if (this._fontFamily === value) return;\n\n        this._fontFamily = value;\n        this.update();\n    }\n\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n\n    set fontSize(value: string | number)\n    {\n        if (this._fontSize === value) return;\n\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        if (this._fontStyle === value) return;\n\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n\n    set fontVariant(value: TextStyleFontVariant)\n    {\n        if (this._fontVariant === value) return;\n\n        this._fontVariant = value;\n        this.update();\n    }\n\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n\n    set fontWeight(value: TextStyleFontWeight)\n    {\n        if (this._fontWeight === value) return;\n\n        this._fontWeight = value;\n        this.update();\n    }\n\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n\n    set leading(value: number)\n    {\n        if (this._leading === value) return;\n\n        this._leading = value;\n        this.update();\n    }\n\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n\n    set letterSpacing(value: number)\n    {\n        if (this._letterSpacing === value) return;\n\n        this._letterSpacing = value;\n        this.update();\n    }\n\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n\n    set lineHeight(value: number)\n    {\n        if (this._lineHeight === value) return;\n\n        this._lineHeight = value;\n        this.update();\n    }\n\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     * > [!NOTE] This will NOT affect the positioning or bounds of the text.\n     */\n    get padding(): number { return this._padding; }\n\n    set padding(value: number)\n    {\n        if (this._padding === value) return;\n\n        this._padding = value;\n        this.update();\n    }\n\n    /**\n     * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.\n     * These filters will be applied to the text as it is created, resulting in faster rendering for static text\n     * compared to applying the filter directly to the text object (which would be applied at run time).\n     * @default null\n     */\n    get filters(): readonly Filter[] { return this._filters; }\n\n    set filters(value: Filter[])\n    {\n        if (this._filters === value) return;\n\n        this._filters = Object.freeze(value);\n        this.update();\n    }\n\n    /**\n     * Trim transparent borders from the text texture.\n     * > [!IMPORTANT] PERFORMANCE WARNING:\n     * > This is a costly operation as it requires scanning pixel alpha values.\n     * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.\n     */\n    get trim(): boolean { return this._trim; }\n\n    set trim(value: boolean)\n    {\n        if (this._trim === value) return;\n\n        this._trim = value;\n        this.update();\n    }\n\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n\n    set textBaseline(value: TextStyleTextBaseline)\n    {\n        if (this._textBaseline === value) return;\n\n        this._textBaseline = value;\n        this.update();\n    }\n\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n\n    set whiteSpace(value: TextStyleWhiteSpace)\n    {\n        if (this._whiteSpace === value) return;\n\n        this._whiteSpace = value;\n        this.update();\n    }\n\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n\n    set wordWrap(value: boolean)\n    {\n        if (this._wordWrap === value) return;\n\n        this._wordWrap = value;\n        this.update();\n    }\n\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n\n    set wordWrapWidth(value: number)\n    {\n        if (this._wordWrapWidth === value) return;\n\n        this._wordWrapWidth = value;\n        this.update();\n    }\n\n    /**\n     * The fill style that will be used to color the text.\n     * This can be:\n     * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n     * - A hex number like 0xff0000 for red\n     * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n     * - A FillGradient for gradient fills\n     * - A FillPattern for pattern/texture fills\n     *\n     * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n     * while gradients at any other angle are spread across the entire text body as a whole.\n     * @example\n     * // Vertical gradient applied per line\n     * const verticalGradient = new FillGradient(0, 0, 0, 1)\n     *     .addColorStop(0, 0xff0000)\n     *     .addColorStop(1, 0x0000ff);\n     *\n     * const text = new Text({\n     *     text: 'Line 1\\nLine 2',\n     *     style: { fill: verticalGradient }\n     * });\n     *\n     * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n     * @type {string|number|FillStyle|FillGradient|FillPattern}\n     */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    public update()\n    {\n        this._tick++;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `${this.uid}-${this._tick}`;\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            filters: this._filters ? [...this._filters] : undefined\n        });\n    }\n\n    /**\n     * Returns the final padding for the text style, taking into account any filters applied.\n     * Used internally for correct measurements\n     * @internal\n     * @returns {number} The final padding for the text style.\n     */\n    public _getFinalPadding(): number\n    {\n        let filterPadding = 0;\n\n        if (this._filters)\n        {\n            for (let i = 0; i < this._filters.length; i++)\n            {\n                filterPadding += this._filters[i].padding;\n            }\n        }\n\n        return Math.max(this._padding, filterPadding);\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * // Destroy the text style and its textures\n     * textStyle.destroy({ texture: true, textureSource: true });\n     * textStyle.destroy(true);\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                if (target[property as keyof T] === newValue) return true;\n\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance: oldStyle.dropShadowDistance ?? defaults.distance\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0)\n        {\n            throw new Error('Invalid fill value. Expected an array of colors for gradient fill.');\n        }\n\n        if (oldStyle.fill.length !== oldStyle.fillGradientStops.length)\n        {\n            // #if _DEBUG\n            warn('The number of fill colors must match the number of fill gradient stops.');\n            // #endif\n        }\n\n        const gradientFill = new FillGradient({\n            start: { x: 0, y: 0 },\n            end: { x: 0, y: 1 },\n            textureSpace: 'local'\n        });\n\n        const fillGradientStops = oldStyle.fillGradientStops.slice();\n        const fills: number[] = oldStyle.fill\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fillGradientStops.forEach((stop, index) =>\n        {\n            gradientFill.addColorStop(stop, fills[index]);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n", "import { type ImageLike } from '../../../environment/ImageLike';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: ImageLike | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\n/**\n * A utility type that represents a canvas and its rendering context.\n * @category rendering\n * @internal\n */\nexport interface CanvasAndContext\n{\n    /** The canvas element. */\n    canvas: ICanvas;\n    /** The rendering context of the canvas. */\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.resetTransform();\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport const CanvasPool = new CanvasPoolClass();\nGlobalResourceRegistry.register(CanvasPool);\n", "import { DOMAdapter } from '../../environment/adapter';\nimport { nextPow2 } from '../../maths/misc/pow2';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\n\n// Internal canvas for measuring bounds\nlet _internalCanvas: ICanvas | null = null;\nlet _internalContext: ICanvasRenderingContext2D | null = null;\n\nfunction ensureInternalCanvas(width: number, height: number): void\n{\n    if (!_internalCanvas)\n    {\n        _internalCanvas = DOMAdapter.get().createCanvas(256, 128);\n        _internalContext = _internalCanvas.getContext('2d', { willReadFrequently: true });\n        _internalContext.globalCompositeOperation = 'copy';\n        _internalContext.globalAlpha = 1;\n    }\n\n    if (_internalCanvas.width < width || _internalCanvas.height < height)\n    {\n        // Use power-of-two dimensions for better performance\n        _internalCanvas.width = nextPow2(width);\n        _internalCanvas.height = nextPow2(height);\n    }\n}\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/** @internal */\nexport interface GetCanvasBoundingBoxOptions\n{\n    /** The canvas to measure */\n    canvas: ICanvas;\n    /** Optional. The width to analyze (defaults to canvas.width) */\n    width?: number;\n    /** Optional. The height to analyze (defaults to canvas.height) */\n    height?: number;\n    /**\n     * Optional. The resolution at which to analyze the canvas, between 0-1.\n     * Lower values improve performance for large canvases but may be less precise.\n     * Default is 1 (full resolution).\n     */\n    resolution?: number;\n    /** Optional. The rectangle to store the result in. */\n    output?: Rectangle;\n}\n\n/**\n * Measures the bounding box of a canvas's visible (non-transparent) pixels.\n *\n * This function analyzes the alpha channel of the canvas pixels to find the smallest\n * rectangle containing all non-transparent pixels. It's useful for optimizing sprite\n * rendering by trimming transparent borders.\n *\n * Uses an internal canvas with `willReadFrequently: true` for efficient pixel data access.\n * This internal canvas is reused between calls for better performance.\n * @example\n * ```typescript\n * // Basic usage - get trim bounds at full resolution\n * const bounds = getCanvasBoundingBox({ canvas: myCanvas });\n * console.log(bounds); // Rectangle{x: 10, y: 5, width: 100, height: 200}\n * // Optimized for performance with lower resolution scanning\n * const fastBounds = getCanvasBoundingBox({\n *     canvas: largeCanvas,\n *     width: largeCanvas.width,\n *     height: largeCanvas.height,\n *     resolution: 0.5\n * });\n * // Resolution of 0.5 means scanning at half size, much faster for large canvases\n *\n * // Using custom dimensions - only analyze part of the canvas\n * const partialBounds = getCanvasBoundingBox({ canvas: myCanvas, width: 100, height: 100 });\n * // Only analyzes a 100x100 region starting from top-left\n * ```\n * @param options - The options for measuring the bounding box, including the canvas to measure.\n * @returns The bounding box as a Rectangle containing the visible content.\n *          Returns Rectangle.EMPTY if the canvas is completely transparent.\n * @internal\n */\nexport function getCanvasBoundingBox(\n    options: GetCanvasBoundingBoxOptions,\n): Rectangle;\n/**\n * @param canvas\n * @param resolution\n * @internal\n * @deprecated since 8.10.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution?: number): Rectangle;\n/**\n * @param {...any} args\n * @internal\n */\nexport function getCanvasBoundingBox(...args: [GetCanvasBoundingBoxOptions] | [ICanvas, number?]): Rectangle\n{\n    let options = args[0] as GetCanvasBoundingBoxOptions;\n\n    if (!options.canvas)\n    {\n        options = { canvas: args[0] as ICanvas, resolution: args[1] };\n    }\n\n    const { canvas } = options; // canvas is correctly extracted from options\n\n    // Cap resolution at 1\n    const resolution = Math.min(options.resolution ?? 1, 1);\n    const width = options.width ?? canvas.width;\n    const height = options.height ?? canvas.height;\n    let output = options.output;\n\n    // Ensure internal canvas is large enough\n    ensureInternalCanvas(width, height);\n\n    if (!_internalContext)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    // Set up for pixel replacement (no blending)\n    _internalContext.drawImage(\n        canvas as unknown as CanvasImageSource,\n        0, 0,\n        width, height,\n        0, 0,\n        width * resolution, height * resolution\n    );\n\n    // Get the image data at full resolution\n    const imageData = _internalContext.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    _internalContext.globalCompositeOperation = 'source-over';\n    // draw the rect on the canvas\n    _internalContext.strokeRect(left, top, right - left, bottom - top);\n    _internalContext.globalCompositeOperation = 'copy';\n\n    output ??= new Rectangle();\n\n    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n\n    return output;\n}\n\n", "/**\n * tiny-lru\n *\n * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>\n * @license BSD-3-Clause\n * @version 11.4.5\n */\n/**\n * A high-performance Least Recently Used (LRU) cache implementation with optional TTL support.\n * Items are automatically evicted when the cache reaches its maximum size,\n * removing the least recently used items first. All core operations (get, set, delete) are O(1).\n *\n * @class LRU\n * @example\n * // Create a cache with max 100 items\n * const cache = new LRU(100);\n * cache.set('key1', 'value1');\n * console.log(cache.get('key1')); // 'value1'\n *\n * @example\n * // Create a cache with TTL\n * const cache = new LRU(100, 5000); // 5 second TTL\n * cache.set('key1', 'value1');\n * // After 5 seconds, key1 will be expired\n */\nclass LRU {\n\t/**\n\t * Creates a new LRU cache instance.\n\t * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.\n\t *\n\t * @constructor\n\t * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.\n\t * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.\n\t * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n\t * @example\n\t * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access\n\t * @see {@link lru} For parameter validation\n\t * @since 1.0.0\n\t */\n\tconstructor (max = 0, ttl = 0, resetTtl = false) {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.max = max;\n\t\tthis.resetTtl = resetTtl;\n\t\tthis.size = 0;\n\t\tthis.ttl = ttl;\n\t}\n\n\t/**\n\t * Removes all items from the cache.\n\t *\n\t * @method clear\n\t * @memberof LRU\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.clear();\n\t * console.log(cache.size); // 0\n\t * @since 1.0.0\n\t */\n\tclear () {\n\t\tthis.first = null;\n\t\tthis.items = Object.create(null);\n\t\tthis.last = null;\n\t\tthis.size = 0;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes an item from the cache by key.\n\t *\n\t * @method delete\n\t * @memberof LRU\n\t * @param {string} key - The key of the item to delete.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * cache.delete('key1');\n\t * console.log(cache.has('key1')); // false\n\t * @see {@link LRU#has}\n\t * @see {@link LRU#clear}\n\t * @since 1.0.0\n\t */\n\tdelete (key) {\n\t\tif (this.has(key)) {\n\t\t\tconst item = this.items[key];\n\n\t\t\tdelete this.items[key];\n\t\t\tthis.size--;\n\n\t\t\tif (item.prev !== null) {\n\t\t\t\titem.prev.next = item.next;\n\t\t\t}\n\n\t\t\tif (item.next !== null) {\n\t\t\t\titem.next.prev = item.prev;\n\t\t\t}\n\n\t\t\tif (this.first === item) {\n\t\t\t\tthis.first = item.next;\n\t\t\t}\n\n\t\t\tif (this.last === item) {\n\t\t\t\tthis.last = item.prev;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of [key, value] pairs for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method entries\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.\n\t * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.entries()); // [['a', 1], ['b', 2]]\n\t * console.log(cache.entries(['a'])); // [['a', 1]]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#values}\n\t * @since 11.1.0\n\t */\n\tentries (keys = this.keys()) {\n\t\treturn keys.map(key => [key, this.get(key)]);\n\t}\n\n\t/**\n\t * Removes the least recently used item from the cache.\n\t *\n\t * @method evict\n\t * @memberof LRU\n\t * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('old', 'value').set('new', 'value');\n\t * cache.evict(); // Removes 'old' item\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tevict (bypass = false) {\n\t\tif (bypass || this.size > 0) {\n\t\t\tconst item = this.first;\n\n\t\t\tdelete this.items[item.key];\n\n\t\t\tif (--this.size === 0) {\n\t\t\t\tthis.first = null;\n\t\t\t\tthis.last = null;\n\t\t\t} else {\n\t\t\t\tthis.first = item.next;\n\t\t\t\tthis.first.prev = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the expiration timestamp for a given key.\n\t *\n\t * @method expiresAt\n\t * @memberof LRU\n\t * @param {string} key - The key to check expiration for.\n\t * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.\n\t * @example\n\t * const cache = new LRU(100, 5000); // 5 second TTL\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\texpiresAt (key) {\n\t\tlet result;\n\n\t\tif (this.has(key)) {\n\t\t\tresult = this.items[key].expiry;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves a value from the cache by key. Updates the item's position to most recently used.\n\t *\n\t * @method get\n\t * @memberof LRU\n\t * @param {string} key - The key to retrieve.\n\t * @returns {*} The value associated with the key, or undefined if not found or expired.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.get('key1')); // 'value1'\n\t * console.log(cache.get('nonexistent')); // undefined\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#has}\n\t * @since 1.0.0\n\t */\n\tget (key) {\n\t\tconst item = this.items[key];\n\n\t\tif (item !== undefined) {\n\t\t\t// Check TTL only if enabled to avoid unnecessary Date.now() calls\n\t\t\tif (this.ttl > 0) {\n\t\t\t\tif (item.expiry <= Date.now()) {\n\t\t\t\t\tthis.delete(key);\n\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fast LRU update without full set() overhead\n\t\t\tthis.moveToEnd(item);\n\n\t\t\treturn item.value;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Checks if a key exists in the cache.\n\t *\n\t * @method has\n\t * @memberof LRU\n\t * @param {string} key - The key to check for.\n\t * @returns {boolean} True if the key exists, false otherwise.\n\t * @example\n\t * cache.set('key1', 'value1');\n\t * console.log(cache.has('key1')); // true\n\t * console.log(cache.has('nonexistent')); // false\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#delete}\n\t * @since 9.0.0\n\t */\n\thas (key) {\n\t\treturn key in this.items;\n\t}\n\n\t/**\n\t * Efficiently moves an item to the end of the LRU list (most recently used position).\n\t * This is an internal optimization method that avoids the overhead of the full set() operation\n\t * when only LRU position needs to be updated.\n\t *\n\t * @method moveToEnd\n\t * @memberof LRU\n\t * @param {Object} item - The cache item with prev/next pointers to reposition.\n\t * @private\n\t * @since 11.3.5\n\t */\n\tmoveToEnd (item) {\n\t\t// If already at the end, nothing to do\n\t\tif (this.last === item) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove item from current position in the list\n\t\tif (item.prev !== null) {\n\t\t\titem.prev.next = item.next;\n\t\t}\n\n\t\tif (item.next !== null) {\n\t\t\titem.next.prev = item.prev;\n\t\t}\n\n\t\t// Update first pointer if this was the first item\n\t\tif (this.first === item) {\n\t\t\tthis.first = item.next;\n\t\t}\n\n\t\t// Add item to the end\n\t\titem.prev = this.last;\n\t\titem.next = null;\n\n\t\tif (this.last !== null) {\n\t\t\tthis.last.next = item;\n\t\t}\n\n\t\tthis.last = item;\n\n\t\t// Handle edge case: if this was the only item, it's also first\n\t\tif (this.first === null) {\n\t\t\tthis.first = item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of all keys in the cache, ordered from least to most recently used.\n\t *\n\t * @method keys\n\t * @memberof LRU\n\t * @returns {string[]} Array of keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * cache.get('a'); // Move 'a' to most recent\n\t * console.log(cache.keys()); // ['b', 'a']\n\t * @see {@link LRU#values}\n\t * @see {@link LRU#entries}\n\t * @since 9.0.0\n\t */\n\tkeys () {\n\t\tconst result = [];\n\t\tlet x = this.first;\n\n\t\twhile (x !== null) {\n\t\t\tresult.push(x.key);\n\t\t\tx = x.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets a value in the cache and returns any evicted item.\n\t *\n\t * @method setWithEvicted\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.\n\t * @example\n\t * const cache = new LRU(2);\n\t * cache.set('a', 1).set('b', 2);\n\t * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}\n\t * @see {@link LRU#set}\n\t * @see {@link LRU#evict}\n\t * @since 11.3.0\n\t */\n\tsetWithEvicted (key, value, resetTtl = this.resetTtl) {\n\t\tlet evicted = null;\n\n\t\tif (this.has(key)) {\n\t\t\tthis.set(key, value, true, resetTtl);\n\t\t} else {\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tevicted = {...this.first};\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\tlet item = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn evicted;\n\t}\n\n\t/**\n\t * Sets a value in the cache. Updates the item's position to most recently used.\n\t *\n\t * @method set\n\t * @memberof LRU\n\t * @param {string} key - The key to set.\n\t * @param {*} value - The value to store.\n\t * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.\n\t * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.\n\t * @returns {LRU} The LRU instance for method chaining.\n\t * @example\n\t * cache.set('key1', 'value1')\n\t *      .set('key2', 'value2')\n\t *      .set('key3', 'value3');\n\t * @see {@link LRU#get}\n\t * @see {@link LRU#setWithEvicted}\n\t * @since 1.0.0\n\t */\n\tset (key, value, bypass = false, resetTtl = this.resetTtl) {\n\t\tlet item = this.items[key];\n\n\t\tif (bypass || item !== undefined) {\n\t\t\t// Existing item: update value and position\n\t\t\titem.value = value;\n\n\t\t\tif (bypass === false && resetTtl) {\n\t\t\t\titem.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;\n\t\t\t}\n\n\t\t\t// Always move to end, but the bypass parameter affects TTL reset behavior\n\t\t\tthis.moveToEnd(item);\n\t\t} else {\n\t\t\t// New item: check for eviction and create\n\t\t\tif (this.max > 0 && this.size === this.max) {\n\t\t\t\tthis.evict(true);\n\t\t\t}\n\n\t\t\titem = this.items[key] = {\n\t\t\t\texpiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,\n\t\t\t\tkey: key,\n\t\t\t\tprev: this.last,\n\t\t\t\tnext: null,\n\t\t\t\tvalue\n\t\t\t};\n\n\t\t\tif (++this.size === 1) {\n\t\t\t\tthis.first = item;\n\t\t\t} else {\n\t\t\t\tthis.last.next = item;\n\t\t\t}\n\n\t\t\tthis.last = item;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an array of all values in the cache for the specified keys.\n\t * Order follows LRU order (least to most recently used).\n\t *\n\t * @method values\n\t * @memberof LRU\n\t * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.\n\t * @returns {Array<*>} Array of values corresponding to the keys in LRU order.\n\t * @example\n\t * cache.set('a', 1).set('b', 2);\n\t * console.log(cache.values()); // [1, 2]\n\t * console.log(cache.values(['a'])); // [1]\n\t * @see {@link LRU#keys}\n\t * @see {@link LRU#entries}\n\t * @since 11.1.0\n\t */\n\tvalues (keys = this.keys()) {\n\t\treturn keys.map(key => this.get(key));\n\t}\n}\n\n/**\n * Factory function to create a new LRU cache instance with parameter validation.\n *\n * @function lru\n * @param {number} [max=1000] - Maximum number of items to store. Must be >= 0. Use 0 for unlimited size.\n * @param {number} [ttl=0] - Time to live in milliseconds. Must be >= 0. Use 0 for no expiration.\n * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().\n * @returns {LRU} A new LRU cache instance.\n * @throws {TypeError} When parameters are invalid (negative numbers or wrong types).\n * @example\n * // Create cache with factory function\n * const cache = lru(100, 5000, true);\n * cache.set('key', 'value');\n *\n * @example\n * // Error handling\n * try {\n *   const cache = lru(-1); // Invalid max\n * } catch (error) {\n *   console.error(error.message); // \"Invalid max value\"\n * }\n * @see {@link LRU}\n * @since 1.0.0\n */\nfunction lru (max = 1000, ttl = 0, resetTtl = false) {\n\tif (isNaN(max) || max < 0) {\n\t\tthrow new TypeError(\"Invalid max value\");\n\t}\n\n\tif (isNaN(ttl) || ttl < 0) {\n\t\tthrow new TypeError(\"Invalid ttl value\");\n\t}\n\n\tif (typeof resetTtl !== \"boolean\") {\n\t\tthrow new TypeError(\"Invalid resetTtl value\");\n\t}\n\n\treturn new LRU(max, ttl, resetTtl);\n}export{LRU,lru};", "import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n * @internal\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n", "import { lru } from 'tiny-lru';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        /**\n         * Creates a new Intl.Segmenter object.\n         * @returns A new Intl.Segmenter object.\n         */\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @category text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n * @advanced\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { CanvasTextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = CanvasTextMetrics.measureText('Your text', style);\n * @category text\n * @advanced\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|ÉqÅ';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) =>\n            {\n                const segments = segmenter.segment(s);\n                const result = [];\n\n                let i = 0;\n\n                for (const segment of segments)\n                {\n                    result[i++] = (segment.segment);\n                }\n\n                return result;\n            };\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result === undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@link TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    /** Cache for measured text metrics */\n    private static readonly _measurementCache = lru<CanvasTextMetrics>(1000);\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;\n\n        // check if we have already measured this text with the same style\n        if (CanvasTextMetrics._measurementCache.has(textKey))\n        {\n            return CanvasTextMetrics._measurementCache.get(textKey);\n        }\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // cache the measurements\n        CanvasTextMetrics._measurementCache.set(textKey, measurements);\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                // treat \\r\\n as a single new line token\n                if (char === '\\r' && nextChar === '\\n')\n                {\n                    tokens.push('\\r\\n');\n                    i++;\n                }\n                else\n                {\n                    tokens.push(char);\n                }\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (_cx)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\nimport type { CanvasTextMetrics } from '../CanvasTextMetrics';\n\n// 5 decimal places\nconst PRECISION = 100000;\n\n/**\n * Converts a PixiJS fill style into a Canvas-compatible fill style.\n * Handles solid colors, textures, patterns, and gradients.\n * @param fillStyle - The PixiJS fill style to convert\n * @param context - The canvas rendering context\n * @param textMetrics - Metrics about the text being rendered\n * @param padding - Padding to add to the text metrics (used to ensure that the gradient accommodates the stroke width)\n * @returns Canvas-compatible fill style (string, CanvasGradient, or CanvasPattern)\n * @internal\n */\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D,\n    textMetrics?: CanvasTextMetrics,\n    padding = 0\n): string | CanvasGradient | CanvasPattern\n{\n    // Solid color fill\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    // Basic texture fill\n    else if (!fillStyle.fill)\n    {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Pattern fill\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Gradient fill\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        const isLinear = fillGradient.type === 'linear';\n        const isLocal = fillGradient.textureSpace === 'local';\n\n        let width = 1;\n        let height = 1;\n\n        // Use text dimensions if in local space\n        if (isLocal && textMetrics)\n        {\n            width = textMetrics.width + padding;\n            height = textMetrics.height + padding;\n        }\n\n        let gradient: CanvasGradient;\n        let isNearlyVertical = false;\n\n        if (isLinear)\n        {\n            const { start, end } = fillGradient;\n\n            gradient = context.createLinearGradient(\n                start.x * width,\n                start.y * height,\n                end.x * width,\n                end.y * height\n            );\n\n            // Check if gradient is nearly vertical (10% threshold)\n            isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);\n        }\n        else\n        {\n            const { center, innerRadius, outerCenter, outerRadius } = fillGradient;\n\n            gradient = context.createRadialGradient(\n                center.x * width,\n                center.y * height,\n                innerRadius * width,\n                outerCenter.x * width,\n                outerCenter.y * height,\n                outerRadius * width\n            );\n        }\n\n        // For vertical gradients in local space, repeat gradient per text line\n        if (isNearlyVertical && isLocal && textMetrics)\n        {\n            const ratio = (textMetrics.lineHeight) / height;\n\n            for (let i = 0; i < textMetrics.lines.length; i++)\n            {\n                const start = ((i * textMetrics.lineHeight) + (padding / 2)) / height;\n\n                fillGradient.colorStops.forEach((stop) =>\n                {\n                    // Convert to global space\n                    const globalStop = start + (stop.offset * ratio);\n\n                    gradient.addColorStop(\n                        // fix to 5 decimal places to avoid floating point precision issues\n                        Math.floor(globalStop * PRECISION) / PRECISION,\n                        Color.shared.setValue(stop.color).toHex()\n                    );\n                });\n            }\n        }\n        else\n        {\n            // Standard global space gradient handling\n            fillGradient.colorStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n        }\n\n        return gradient;\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n", "import { Color } from '../../../color/Color';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\nimport { type CanvasAndContext, CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { type TextStyle } from '../TextStyle';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\n/**\n * Temporary rectangle for getting the bounding box of the text.\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Utility for generating and managing canvas-based text rendering.\n *\n * This class is responsible for rendering text to canvas elements based on provided styles,\n * measuring the resulting text dimensions, and managing the lifecycle of canvas resources.\n *\n * CanvasTextGenerator supports:\n * - Text rendering with various styles (fill, stroke, gradient, etc.)\n * - Drop shadows and letter spacing\n * - Automatic trimming of transparent pixels\n * - Canvas resource pooling\n *\n * As a singleton, it's accessed via the exported `CanvasTextGenerator` constant.\n * @example\n * ```typescript\n * // Basic usage - render text to a canvas\n * import { CanvasTextGenerator } from 'pixi.js';\n * import { TextStyle } from 'pixi.js';\n *\n * // Create a text style\n * const style = new TextStyle({\n *   fontFamily: 'Arial',\n *   fontSize: 24,\n *   fill: 0xff1010,\n *   align: 'center',\n * });\n *\n * // Get a canvas with the text rendered to it\n * const { canvasAndContext, frame } = CanvasTextGenerator.getCanvasAndContext({\n *   text: 'Hello Pixi!',\n *   style,\n *   resolution: 1\n * });\n *\n * @internal\n */\nclass CanvasTextGeneratorClass\n{\n    /**\n     * Creates a canvas with the specified text rendered to it.\n     *\n     * Generates a canvas of appropriate size, renders the text with the provided style,\n     * and returns both the canvas/context and a Rectangle representing the text bounds.\n     *\n     * When trim is enabled in the style, the frame will represent the bounds of the\n     * non-transparent pixels, which can be smaller than the full canvas.\n     * @param options - The options for generating the text canvas\n     * @param options.text - The text to render\n     * @param options.style - The style to apply to the text\n     * @param options.resolution - The resolution of the canvas (defaults to 1)\n     * @param options.padding\n     * @returns An object containing the canvas/context and the frame (bounds) of the text\n     */\n    public getCanvasAndContext(options: {text: string, style: TextStyle, resolution?: number, padding?: number})\n    {\n        const { text, style, resolution = 1 } = options;\n\n        const padding = (style as TextStyle)._getFinalPadding();\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n\n        const frame = style.trim\n            ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect })\n            : tempRect.set(0, 0, width, height);\n\n        return {\n            canvasAndContext,\n            frame\n        };\n    }\n\n    /**\n     * Returns a canvas and context to the pool.\n     *\n     * This should be called when you're done with the canvas to allow reuse\n     * and prevent memory leaks.\n     * @param canvasAndContext - The canvas and context to return to the pool\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @param text - The text to render\n     * @param style - The style of the text\n     * @param padding - The padding of the text\n     * @param resolution - The resolution of the text\n     * @param canvasAndContext - The canvas and context to render the text to\n     */\n    private _renderTextToCanvas(\n        text: string,\n        style: TextStyle,\n        padding: number,\n        resolution: number,\n        canvasAndContext: CanvasAndContext\n    ): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured, padding * 2) : null;\n\n                if (style._stroke?.width)\n                {\n                    const strokePadding = (style._stroke.width * 0.5) + (padding * 2);\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, strokePadding);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     *\n     * This method handles rendering text with the correct letter spacing, using either:\n     * 1. Native letter spacing if supported by the browser\n     * 2. Manual letter spacing calculation if not natively supported\n     *\n     * For manual letter spacing, it calculates the position of each character\n     * based on its width and the desired spacing.\n     * @param text - The text to draw\n     * @param style - The text style to apply\n     * @param canvasAndContext - The canvas and context to draw to\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Whether to render the stroke (true) or fill (false)\n     * @private\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n}\n\n/** @internal */\nexport const CanvasTextGenerator = new CanvasTextGeneratorClass();\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions, type Text } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n\n            // We initially increased the frame size by a resolution factor\n            // to achieve a crisper display. Now we need to scale down the already\n            // trimmed frame to render the texture in the expected size.\n            texture.frame.scale(1 / resolution);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters as Filter[]);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n     * @param text - The Text object that needs a texture\n     * @returns A Texture instance that represents the rendered text\n     * @remarks\n     * This method performs the following:\n     * 1. Sets the appropriate resolution based on auto-resolution settings\n     * 2. Checks if a texture already exists for the text's style\n     * 3. Creates a new texture if needed or returns an existing one\n     * 4. Manages reference counting for texture reuse\n     */\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const texture = this.getTexture({\n            text: text.text,\n            style: text.style,\n            resolution: text._resolution,\n            textureStyle: text.textureStyle,\n        });\n\n        this._activeTextures[textKey] = {\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    /**\n     * Decreases the reference count for a texture associated with a text key.\n     * When the reference count reaches zero, the texture is returned to the pool.\n     * @param textKey - The unique key identifying the text style configuration\n     * @remarks\n     * This method is crucial for memory management, ensuring textures are properly\n     * cleaned up when they are no longer needed by any Text instances.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            this.returnTexture(activeTexture.texture);\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? 0;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        // Clean up active textures\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexture(this._activeTextures[key].texture);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\nimport { type GraphicsGpuData } from './GraphicsPipe';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for Graphics instances.\n * Configures the initial state and behavior of a Graphics object.\n * @example\n * ```ts\n * const graphics = new Graphics({\n *     roundPixels: true,\n *     position: { x: 100.5, y: 100.5 }\n * });\n *\n * // Reuse graphics context\n * const sharedContext = new GraphicsContext();\n * const graphics1 = new Graphics({ context: sharedContext });\n * const graphics2 = new Graphics({ context: sharedContext });\n * ```\n * @see {@link Graphics} For the graphics class implementation\n * @see {@link GraphicsContext} For the graphics context API\n * @category scene\n * @standard\n */\nexport interface GraphicsOptions extends PixiMixins.GraphicsOptions, ViewContainerOptions\n{\n    /**\n     * The GraphicsContext to use, useful for reuse and optimisation\n     * If not provided, a new GraphicsContext will be created.\n     * @example\n     * ```ts\n     * const sharedContext = new GraphicsContext();\n     * const graphics1 = new Graphics({ context: sharedContext });\n     * const graphics2 = new Graphics({ context: sharedContext });\n     * ```\n     */\n    context?: GraphicsContext;\n    /**\n     * Whether or not to round the x/y position.\n     * @default false\n     * @example\n     * ```ts\n     * const graphics = new Graphics({ roundPixels: true });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Graphics extends PixiMixins.Graphics, ViewContainer<GraphicsGpuData> {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them. It can also be used to create complex\n * masks and hit areas for interaction.\n * @example\n * ```ts\n * // Create a new graphics object\n * const graphics = new Graphics();\n *\n * // Draw a filled rectangle with a stroke\n * graphics\n *     .rect(0, 0, 100, 100)\n *     .fill({ color: 0xff0000 }) // Fill with red\n *     .stroke({ width: 2, color: 0x000000 }); // Stroke with black\n *\n * // Draw a complex shape\n * graphics\n *     .moveTo(50, 50)\n *     .lineTo(100, 100)\n *     .arc(100, 100, 50, 0, Math.PI)\n *     .closePath()\n *     .fill({ color: 0x00ff00, alpha: 0.5 }); // Fill the shape\n *\n * // Use as a mask\n * sprite.mask = graphics;\n * ```\n * @see {@link GraphicsContext} For the underlying drawing API\n * @see {@link GraphicsPath} For path creation\n * @category scene\n * @standard\n */\nexport class Graphics extends ViewContainer<GraphicsGpuData> implements Instruction\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'graphics';\n    /** @internal */\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * Creates a new Graphics object.\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.didViewUpdate = true;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The underlying graphics context used for drawing operations.\n     * Controls how shapes and paths are rendered.\n     * @example\n     * ```ts\n     * // Create a shared context\n     * const sharedContext = new GraphicsContext();\n     *\n     * // Create graphics objects sharing the same context\n     * const graphics1 = new Graphics();\n     * const graphics2 = new Graphics();\n     *\n     * // Assign shared context\n     * graphics1.context = sharedContext;\n     * graphics2.context = sharedContext;\n     *\n     * // Both graphics will show the same shapes\n     * sharedContext\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @see {@link GraphicsContext} For drawing operations\n     * @see {@link GraphicsOptions} For context configuration\n     */\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphics object.\n     * Returns the boundaries after all graphical operations but before any transforms.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Get bounds information\n     * const bounds = graphics.bounds;\n     * console.log(bounds.width);  // 100\n     * console.log(bounds.height); // 100\n     * ```\n     * @readonly\n     * @see {@link Bounds} For bounds operations\n     * @see {@link Container#getBounds} For transformed bounds\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Graphics objects do not need to update their bounds as the context handles this.\n     * @private\n     */\n    protected updateBounds(): void { /** */ }\n\n    /**\n     * Checks if the object contains the given point.\n     * Returns true if the point lies within the Graphics object's rendered area.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Check point intersection\n     * if (graphics.containsPoint({ x: 50, y: 50 })) {\n     *     console.log('Point is inside rectangle!');\n     * }\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is inside the Graphics object\n     * @see {@link Graphics#bounds} For bounding box checks\n     * @see {@link PointData} For point data structure\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @example\n     * ```ts\n     * // Destroy the graphics and its context\n     * graphics.destroy();\n     * graphics.destroy(true);\n     * graphics.destroy({ context: true, texture: true, textureSource: true });\n     * ```\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context.\n     * The fill style can be a color, gradient, pattern, or a complex style object.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics\n     *     .setFillStyle({ color: 0xff0000 }) // Red fill\n     *     .rect(0, 0, 100, 100)\n     *     .fill();\n     *\n     * // Gradient fill\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setFillStyle(gradient)\n     *     .circle(100, 100, 50)\n     *     .fill();\n     *\n     * // Pattern fill\n     * const pattern = new FillPattern(texture);\n     * graphics\n     *     .setFillStyle({\n     *         fill: pattern,\n     *         alpha: 0.5\n     *     })\n     *     .rect(0, 0, 200, 200)\n     *     .fill();\n     * ```\n     * @param {FillInput} args - The fill style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context.\n     * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color stroke\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 2,\n     *         color: 0x000000\n     *     })\n     *     .rect(0, 0, 100, 100)\n     *     .stroke();\n     *\n     * // Complex stroke style\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 4,\n     *         color: 0xff0000,\n     *         alpha: 0.5,\n     *         join: 'round',\n     *         cap: 'round',\n     *         alignment: 0.5\n     *     })\n     *     .circle(100, 100, 50)\n     *     .stroke();\n     *\n     * // Gradient stroke\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 10,\n     *         fill: gradient\n     *     })\n     *     .poly([0,0, 100,50, 0,100])\n     *     .stroke();\n     * ```\n     * @param {StrokeInput} args - The stroke style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link FillPattern} For pattern strokes\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style or specified style.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Fill with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill('red'); // Red fill\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .fill(myTexture); // Fill with texture\n     *\n     * // Fill with complex style\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({\n     *         color: 0x00ff00,\n     *         alpha: 0.5,\n     *         texture: myTexture,\n     *         matrix: new Matrix()\n     *     });\n     *\n     * // Fill with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill(gradient);\n     * ```\n     * @param {FillInput} style - The style to fill the path with. Can be:\n     * - A ColorSource\n     * - A gradient\n     * - A pattern\n     * - A complex style object\n     * If omitted, uses current fill style.\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style or specified style.\n     * Outlines the shape using the stroke settings.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Stroke with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0xff0000\n     *     }); // 2px red stroke\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .stroke(myTexture); // Fill with texture\n     *\n     * // Stroke with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .stroke({\n     *         width: 4,\n     *         fill: gradient,\n     *         alignment: 0.5,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n     * - A stroke style object with width, color, etc.\n     * - A gradient\n     * - A pattern\n     * If omitted, uses current stroke style.\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link setStrokeStyle} For setting default stroke style\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple ways to draw textures\n     * including basic textures, tinted textures, and textures with custom dimensions.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic texture drawing\n     * graphics.texture(myTexture);\n     *\n     * // Tinted texture with position\n     * graphics.texture(myTexture, 0xff0000); // Red tint\n     *\n     * // Texture with custom position and dimensions\n     * graphics\n     *     .texture(\n     *         myTexture,    // texture\n     *         0xffffff,     // white tint\n     *         100, 100,     // position\n     *         200, 150      // dimensions\n     *     );\n     * ```\n     * Basic texture drawing:\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current Graphics for chaining.\n     *\n     * Extended texture drawing:\n     * @param texture - The Texture object to use.\n     *        tint - A ColorSource to tint the texture (defaults to white).\n     *        dx - The x-coordinate for the texture placement.\n     *        dy - The y-coordinate for the texture placement.\n     *        dw - The width to draw the texture (defaults to texture width).\n     *        dh - The height to draw the texture (defaults to texture height).\n     * @returns The instance of the current Graphics for chaining.\n     * @see {@link Texture} For texture creation\n     * @see {@link FillPattern} For pattern fills\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .circle(150, 150, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .beginPath() // Starts a new path\n     *     .circle(250, 150, 50)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for chaining\n     * @see {@link Graphics#moveTo} For starting a new subpath\n     * @see {@link Graphics#closePath} For closing the current path\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path.\n     *\n     * If a hole is not completely in a shape, it will fail to cut correctly.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw outer circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *     .circle(100, 100, 25) // Inner circle\n     *     .cut() // Cuts out the inner circle from the outer circle\n     * ```\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @example\n     * ```ts\n     * // Draw a simple arc (quarter circle)\n     * const graphics = new Graphics();\n     * graphics\n     *     .arc(100, 100, 50, 0, Math.PI/2)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Draw a full circle using an arc\n     * graphics\n     *     .arc(200, 200, 30, 0, Math.PI * 2)\n     *     .stroke({ color: 0x00ff00 });\n     *\n     * // Draw a counterclockwise arc\n     * graphics\n     *     .arc(150, 150, 40, Math.PI, 0, true)\n     *     .stroke({ width: 2, color: 0x0000ff });\n     * ```\n     * @param x - The x-coordinate of the arc's center\n     * @param y - The y-coordinate of the arc's center\n     * @param radius - The arc's radius (must be positive)\n     * @param startAngle - The starting point of the arc, in radians\n     * @param endAngle - The end point of the arc, in radians\n     * @param counterclockwise - Optional. If true, draws the arc counterclockwise.\n     *                          If false (default), draws clockwise.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing complete circles\n     * @see {@link Graphics#arcTo} For drawing arcs between points\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path that connects two points using a radius.\n     * The arc is drawn between the current point and the specified end point,\n     * using the given control point to determine the curve of the arc.\n     * @example\n     * ```ts\n     * // Draw a simple curved corner\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .arcTo(100, 50, 100, 100, 20) // Rounded corner with 20px radius\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a rounded rectangle using arcTo\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcTo(250, 150, 250, 250, 30) // Top right corner\n     *     .arcTo(250, 250, 150, 250, 30) // Bottom right corner\n     *     .arcTo(150, 250, 150, 150, 30) // Bottom left corner\n     *     .arcTo(150, 150, 250, 150, 30) // Top left corner\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x1 - The x-coordinate of the control point\n     * @param y1 - The y-coordinate of the control point\n     * @param x2 - The x-coordinate of the end point\n     * @param y2 - The y-coordinate of the end point\n     * @param radius - The radius of the arc in pixels (must be positive)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For drawing arcs using center point and angles\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * This is particularly useful when converting SVG paths to Graphics or creating complex curved shapes.\n     * @example\n     * ```ts\n     * // Draw a simple elliptical arc\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(100, 100)\n     *     .arcToSvg(50, 30, 0, 0, 1, 200, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a complex path with rotated elliptical arc\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcToSvg(\n     *         60,    // rx\n     *         30,    // ry\n     *         45,    // x-axis rotation (45 degrees)\n     *         1,     // large arc flag\n     *         0,     // sweep flag\n     *         250,   // end x\n     *         200    // end y\n     *     )\n     *     .stroke({ width: 4, color: 0x00ff00 });\n     *\n     * // Chain multiple arcs for complex shapes\n     * graphics\n     *     .moveTo(300, 100)\n     *     .arcToSvg(40, 20, 0, 0, 1, 350, 150)\n     *     .arcToSvg(40, 20, 0, 0, 1, 300, 200)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param rx - The x-radius of the ellipse (must be non-negative)\n     * @param ry - The y-radius of the ellipse (must be non-negative)\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative to the x-axis, in degrees\n     * @param largeArcFlag - Either 0 or 1, determines if the larger of the two possible arcs is chosen (1) or not (0)\n     * @param sweepFlag - Either 0 or 1, determines if the arc should be swept in\n     *                    a positive angle direction (1) or negative (0)\n     * @param x - The x-coordinate of the arc's end point\n     * @param y - The y-coordinate of the arc's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For simple circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     * @see {@link Graphics#svg} For parsing complete SVG paths\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bézier curve to the path, from the current point to the specified end point.\n     * The curve is influenced by two control points that define its shape and curvature.\n     * @example\n     * ```ts\n     * // Draw a simple curved line\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .bezierCurveTo(\n     *         100, 25,   // First control point\n     *         150, 75,   // Second control point\n     *         200, 50    // End point\n     *     )\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .bezierCurveTo(\n     *         100, 150,\n     *         200, 250,\n     *         250, 200,\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({ width: 4, color: 0x0000ff });\n     * ```\n     * @param cp1x - The x-coordinate of the first control point\n     * @param cp1y - The y-coordinate of the first control point\n     * @param cp2x - The x-coordinate of the second control point\n     * @param cp2y - The y-coordinate of the second control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#quadraticCurveTo} For simpler curves with one control point\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start point.\n     *\n     * This is useful for completing shapes and ensuring they are properly closed for fills.\n     * @example\n     * ```ts\n     * // Create a triangle with closed path\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .closePath()\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path\n     * @see {@link Graphics#fill} For filling closed paths\n     * @see {@link Graphics#stroke} For stroking paths\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic ellipse\n     * graphics\n     *     .ellipse(100, 100, 50, 30)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw an ellipse with stroke\n     * graphics\n     *     .ellipse(200, 100, 70, 40)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the center of the ellipse\n     * @param y - The y-coordinate of the center of the ellipse\n     * @param radiusX - The horizontal radius of the ellipse\n     * @param radiusY - The vertical radius of the ellipse\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing perfect circles\n     * @see {@link Graphics#arc} For drawing partial circular arcs\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape at the specified location with the given radius.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a circle with gradient fill\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *           { offset: 0, color: 0xff0000 }, // Red at start\n     *           { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *           { offset: 1, color: 0x0000ff }, // Blue at end\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(250, 100, 40)\n     *     .fill({ fill: gradient });\n     * ```\n     * @param x - The x-coordinate of the center of the circle\n     * @param y - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#ellipse} For drawing ellipses\n     * @see {@link Graphics#arc} For drawing partial circles\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * This allows for reuse of complex paths and shapes across different graphics instances.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * // Create a reusable path\n     * const heartPath = new GraphicsPath()\n     *     .moveTo(0, 0)\n     *     .bezierCurveTo(-50, -25, -50, -75, 0, -100)\n     *     .bezierCurveTo(50, -75, 50, -25, 0, 0);\n     *\n     * // Use the path multiple times\n     * graphics\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000 })\n     *     .translateTransform(200, 200)\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000, alpha: 0.5 });\n     * ```\n     * @param path - The `GraphicsPath` to add to the current path\n     * @returns The Graphics instance for method chaining\n     * @see {@link GraphicsPath} For creating reusable paths\n     * @see {@link Matrix} For creating transformations\n     * @see {@link Graphics#transform} For applying transformations\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line.\n     * Any subsequent drawing commands will start from this new point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a complex shape with multiple lines\n     * graphics\n     *     .moveTo(200, 50)\n     *     .lineTo(250, 50)\n     *     .lineTo(250, 100)\n     *     .lineTo(200, 100)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the line's end point\n     * @param y - The y-coordinate of the line's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#moveTo} For starting a new sub-path\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path.\n     *\n     * Moves the \"pen\" to a new location without drawing a line.\n     * Any subsequent drawing commands will start from this point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create multiple separate lines\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 50)\n     *     .moveTo(50, 100)    // Start a new line\n     *     .lineTo(100, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create disconnected shapes\n     * graphics\n     *     .moveTo(150, 50)\n     *     .rect(150, 50, 50, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .moveTo(250, 50)    // Start a new shape\n     *     .circle(250, 75, 25)\n     *     .fill({ color: 0x0000ff });\n     *\n     * // Position before curved paths\n     * graphics\n     *     .moveTo(300, 50)\n     *     .bezierCurveTo(\n     *         350, 25,   // Control point 1\n     *         400, 75,   // Control point 2\n     *         450, 50    // End point\n     *     )\n     *     .stroke({ width: 3, color: 0xff00ff });\n     * ```\n     * @param x - The x-coordinate to move to\n     * @param y - The y-coordinate to move to\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#lineTo} For drawing lines\n     * @see {@link Graphics#beginPath} For starting a completely new path\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple curve\n     * graphics\n     *     .moveTo(50, 50)\n     *     .quadraticCurveTo(100, 25, 150, 50)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .quadraticCurveTo(\n     *         150, 150,   // Control point\n     *         250, 200,   // End point\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({\n     *         width: 4,\n     *         color: 0x0000ff,\n     *         alpha: 0.7\n     *     });\n     * ```\n     * @param cpx - The x-coordinate of the control point\n     * @param cpy - The y-coordinate of the control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#bezierCurveTo} For curves with two control points\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape.\n     *\n     * This method adds a new rectangle path to the current drawing.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled rectangle\n     * graphics\n     *     .rect(50, 50, 100, 75)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Rectangle with stroke\n     * graphics\n     *     .rect(200, 50, 100, 75)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners. The corner radius can be specified to\n     * determine how rounded the corners should be.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic rounded rectangle\n     * graphics\n     *     .roundRect(50, 50, 100, 75, 15)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @param radius - The radius of the rectangle's corners (must be non-negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rect} For drawing rectangles with sharp corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed.\n     *\n     * An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle using array of numbers [x1,y1, x2,y2, x3,y3]\n     * graphics\n     *     .poly([50,50, 100,100, 0,100], true)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a polygon using point objects\n     * graphics\n     *     .poly([\n     *         { x: 200, y: 50 },\n     *         { x: 250, y: 100 },\n     *         { x: 200, y: 150 },\n     *         { x: 150, y: 100 }\n     *     ])\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Draw an open polygon with stroke\n     * graphics\n     *     .poly([300,50, 350,50, 350,100, 300,100], false)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0x0000ff,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param points - An array of numbers [x1,y1, x2,y2, ...] or an array of point objects [{x,y}, ...]\n     *                representing the vertices of the polygon in sequence\n     * @param close - Whether to close the polygon path by connecting the last point to the first.\n     *               Default is true.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal,\n     * making shapes like triangles, squares, pentagons, etc.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple triangle (3 sides)\n     * graphics\n     *     .regularPoly(100, 100, 50, 3)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a hexagon (6 sides) with rotation\n     * graphics\n     *     .regularPoly(\n     *         250, 100,    // center position\n     *         40,          // radius\n     *         6,           // sides\n     *         Math.PI / 6  // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Draw an octagon (8 sides) with transform\n     * const transform = new Matrix()\n     *     .scale(1.5, 1)      // stretch horizontally\n     *     .rotate(Math.PI/4); // rotate 45 degrees\n     *\n     * graphics\n     *     .regularPoly(400, 100, 30, 8, 0, transform)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @param transform - Optional Matrix to transform the polygon's shape\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     *\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic rounded triangle\n     * graphics\n     *     .roundPoly(100, 100, 50, 3, 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rounded hexagon with rotation\n     * graphics\n     *     .roundPoly(\n     *         250, 150,     // center position\n     *         40,           // radius\n     *         6,            // sides\n     *         8,            // corner radius\n     *         Math.PI / 6   // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param corner - The radius of the corner rounding (must be non-negative)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing polygons without rounded corners\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a custom shape with rounded corners\n     * graphics\n     *     .roundShape([\n     *         { x: 100, y: 100, radius: 20 },\n     *         { x: 200, y: 100, radius: 10 },\n     *         { x: 200, y: 200, radius: 15 },\n     *         { x: 100, y: 200, radius: 5 }\n     *     ], 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using quadratic curves for corners\n     * graphics\n     *     .roundShape([\n     *         { x: 250, y: 100 },\n     *         { x: 350, y: 100 },\n     *         { x: 350, y: 200 },\n     *         { x: 250, y: 200 }\n     *     ], 15, true, 0.5)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Shape with varying corner radii\n     * graphics\n     *     .roundShape([\n     *         { x: 400, y: 100, radius: 30 },\n     *         { x: 500, y: 100, radius: 5 },\n     *         { x: 450, y: 200, radius: 15 }\n     *     ], 10)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param points - An array of `RoundedPoint` representing the corners of the shape.\n     *                Each point can have its own radius or use the default.\n     *                A minimum of 3 points is required.\n     * @param radius - The default radius for corners without a specific radius defined.\n     *                Applied to any point that doesn't specify its own radius.\n     * @param useQuadratic - When true, corners are drawn using quadratic curves instead\n     *                      of arcs, creating a different visual style. Defaults to false.\n     * @param smoothness - Controls the smoothness of quadratic corners when useQuadratic\n     *                    is true. Values range from 0-1, higher values create smoother curves.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#roundPoly} For drawing regular polygons with rounded corners\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draws a rectangle with fillet corners. Unlike rounded rectangles, this supports negative corner\n     * radii which create external rounded corners rather than internal ones.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a rectangle with internal fillets\n     * graphics\n     *     .filletRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rectangle with external fillets\n     * graphics\n     *     .filletRect(200, 50, 100, 80, -20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param fillet - The radius of the corner fillets (can be positive or negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For standard rounded corners\n     * @see {@link Graphics#chamferRect} For angled corners\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draws a rectangle with chamfered (angled) corners. Each corner is cut off at\n     * a 45-degree angle based on the chamfer size.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic chamfered rectangle\n     * graphics\n     *     .chamferRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Add transform and stroke\n     * const transform = new Matrix()\n     *     .rotate(Math.PI / 4); // 45 degrees\n     *\n     * graphics\n     *     .chamferRect(200, 50, 100, 80, 20, transform)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param chamfer - The size of the corner chamfers (must be non-zero)\n     * @param transform - Optional Matrix to transform the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For rounded corners\n     * @see {@link Graphics#filletRect} For rounded corners with negative radius support\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     * of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     *\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic 5-pointed star\n     * graphics\n     *     .star(100, 100, 5, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Star with custom inner radius\n     * graphics\n     *     .star(250, 100, 6, 50, 20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the star\n     * @param y - The y-coordinate of the center of the star\n     * @param points - The number of points on the star (must be >= 3)\n     * @param radius - The outer radius of the star (distance from center to point tips)\n     * @param innerRadius - Optional. The inner radius of the star (distance from center to inner vertices).\n     *                     If not specified, defaults to half of the outer radius\n     * @param rotation - Optional. The rotation of the star in radians. Default is 0,\n     *                  which aligns one point straight up\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#path} For creating custom shapes\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes\n     * and paths defined in SVG format to be drawn within the graphics context.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .svg(`\n     *         <path d=\"M 50,50 L 100,50 L 100,100 L 50,100 Z\"\n     *               fill=\"blue\" />\n     *         <circle cx=\"150\" cy=\"75\" r=\"25\"\n     *               fill=\"green\" />\n     *     `)\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param svg - The SVG string to be parsed and rendered\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#path} For adding custom paths\n     * @see {@link Graphics#fill} For filling shapes after SVG parsing\n     * @see {@link Graphics#stroke} For stroking shapes after SVG parsing\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save current state\n     * graphics.save();\n     *\n     * // Make temporary changes\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .setFillStyle({ color: 0xff0000 })\n     *     .circle(0, 0, 50)\n     *     .fill();\n     *\n     * // Restore to previous state\n     * graphics.restore();\n     *\n     * // Draw with original transform and styles\n     * graphics\n     *     .circle(50, 50, 30)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#save} For saving the current state\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /**\n     * Saves the current graphics state onto a stack. The state includes:\n     * - Current transformation matrix\n     * - Current fill style\n     * - Current stroke style\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save state before complex operations\n     * graphics.save();\n     *\n     * // Create transformed and styled shape\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4)\n     *     .setFillStyle({\n     *         color: 0xff0000,\n     *         alpha: 0.5\n     *     })\n     *     .rect(-25, -25, 50, 50)\n     *     .fill();\n     *\n     * // Restore to original state\n     * graphics.restore();\n     *\n     * // Continue drawing with previous state\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#restore} For restoring the saved state\n     * @see {@link Graphics#setTransform} For setting transformations\n     */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * This matrix represents all accumulated transformations including translate, scale, and rotate.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply some transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4);\n     *\n     * // Get the current transform matrix\n     * const matrix = graphics.getTransform();\n     * console.log(matrix.tx, matrix.ty); // 100, 100\n     *\n     * // Use the matrix for other operations\n     * graphics\n     *     .setTransform(matrix)\n     *     .circle(0, 0, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @returns The current transformation matrix.\n     * @see {@link Graphics#setTransform} For setting the transform matrix\n     * @see {@link Matrix} For matrix operations\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .scaleTransform(2, 2)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * // Reset transform to default state\n     * graphics\n     *     .resetTransform()\n     *     .circle(50, 50, 25) // Will draw at actual coordinates\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#getTransform} For getting the current transform\n     * @see {@link Graphics#setTransform} For setting a specific transform\n     * @see {@link Graphics#save} For saving the current transform state\n     * @see {@link Graphics#restore} For restoring a previous transform state\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * Positive angles rotate clockwise, while negative angles rotate counterclockwise.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Rotate 45 degrees clockwise\n     * graphics\n     *     .rotateTransform(Math.PI / 4)\n     *     .rect(-25, -25, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param angle - The angle of rotation in radians\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#scaleTransform} For scaling transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally\n     * and by y vertically relative to the current origin.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Uniform scaling\n     * graphics\n     *     .scaleTransform(2)  // Scale both dimensions by 2\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Non-uniform scaling\n     * graphics\n     *     .scaleTransform(0.5, 2)  // Half width, double height\n     *     .rect(100, 100, 50, 50)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x - The scale factor in the horizontal direction\n     * @param y - The scale factor in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rotateTransform} For rotation transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context.\n     *\n     * This method can either\n     * take a Matrix object or individual transform values to create a new transformation matrix.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     *\n     * graphics\n     *     .setTransform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .setTransform(\n     *         2, 0,     // scale x by 2\n     *         0, 1,     // no skew\n     *         100, 100  // translate x,y by 100\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies a transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix. This allows for complex transformations\n     * combining multiple operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .scale(2, 1)      // Scale horizontally\n     *     .rotate(Math.PI/6); // Rotate 30 degrees\n     *\n     * graphics\n     *     .transform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .transform(\n     *         1, 0.5,    // Skew horizontally\n     *         0, 1,      // No vertical skew\n     *         100, 100   // Translate\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * This affects all subsequent drawing operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic translation\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The amount to translate in the horizontal direction\n     * @param y - The amount to translate in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#setTransform} For setting absolute transformations\n     * @see {@link Graphics#transform} For applying complex transformations\n     * @see {@link Graphics#save} For saving the current transform state\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it.\n     * This includes clearing the current path, fill style, stroke style, and transformations.\n     *\n     * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n     * > Instead, they are intended to be used for static or semi-static graphics that\n     * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw some shapes\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 })\n     *     .rect(200, 100, 100, 50)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Clear all graphics\n     * graphics.clear();\n     *\n     * // Start fresh with new shapes\n     * graphics\n     *     .circle(150, 150, 30)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n     * @see {@link Graphics#save} For saving the current state\n     * @see {@link Graphics#restore} For restoring a previous state\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * Gets or sets the current fill style for the graphics context. The fill style determines\n     * how shapes are filled when using the fill() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics.fillStyle = {\n     *     color: 0xff0000,  // Red\n     *     alpha: 1\n     * };\n     *\n     * // Using gradients\n     * const gradient = new FillGradient({\n     *     end: { x: 0, y: 1 }, // Vertical gradient\n     *     stops: [\n     *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n     *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n     *     ]\n     * });\n     *\n     * graphics.fillStyle = {\n     *     fill: gradient,\n     *     alpha: 0.8\n     * };\n     *\n     * // Using patterns\n     * graphics.fillStyle = {\n     *     texture: myTexture,\n     *     alpha: 1,\n     *     matrix: new Matrix()\n     *         .scale(0.5, 0.5)\n     *         .rotate(Math.PI / 4)\n     * };\n     * ```\n     * @type {ConvertedFillStyle}\n     * @see {@link FillStyle} For all available fill style options\n     * @see {@link FillGradient} For creating gradient fills\n     * @see {@link Graphics#fill} For applying the fill to paths\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * Gets or sets the current stroke style for the graphics context. The stroke style determines\n     * how paths are outlined when using the stroke() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic stroke style\n     * graphics.strokeStyle = {\n     *     width: 2,\n     *     color: 0xff0000,\n     *     alpha: 1\n     * };\n     *\n     * // Using with gradients\n     * const gradient = new FillGradient({\n     *   end: { x: 0, y: 1 },\n     *   stops: [\n     *       { offset: 0, color: 0xff0000, alpha: 1 },\n     *       { offset: 1, color: 0x0000ff, alpha: 1 }\n     *   ]\n     * });\n     *\n     * graphics.strokeStyle = {\n     *     width: 4,\n     *     fill: gradient,\n     *     alignment: 0.5,\n     *     join: 'round',\n     *     cap: 'round'\n     * };\n     *\n     * // Complex stroke settings\n     * graphics.strokeStyle = {\n     *     width: 6,\n     *     color: 0x00ff00,\n     *     alpha: 0.5,\n     *     join: 'miter',\n     *     miterLimit: 10,\n     * };\n     * ```\n     * @see {@link StrokeStyle} For all available stroke style options\n     * @see {@link Graphics#stroke} For applying the stroke to paths\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object that copies the current graphics content.\n     * The clone can either share the same context (shallow clone) or have its own independent\n     * context (deep clone).\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create original graphics content\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a shallow clone (shared context)\n     * const shallowClone = graphics.clone();\n     *\n     * // Changes to original affect the clone\n     * graphics\n     *     .circle(200, 100, 30)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Create a deep clone (independent context)\n     * const deepClone = graphics.clone(true);\n     *\n     * // Modify deep clone independently\n     * deepClone\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 40)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @param deep - Whether to create a deep clone of the graphics object.\n     *              If false (default), the context will be shared between objects.\n     *              If true, creates an independent copy of the context.\n     * @returns A new Graphics instance with either shared or copied context\n     * @see {@link Graphics#context} For accessing the underlying graphics context\n     * @see {@link GraphicsContext} For understanding the shared context behavior\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        if (color !== undefined) fillStyle.color = color;\n        if (alpha !== undefined) fillStyle.alpha = alpha;\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n", "// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n", "/** @internal */\nexport const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `,\n    }\n\n};\n\n/** @internal */\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `,\n    }\n\n};\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/** @internal */\nexport class SdfShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/**\n * @category text\n * @advanced\n */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @category text\n * @advanced\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @category text\n * @advanced\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @category text\n * @advanced\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n", "import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @internal */\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n    textureStyle?: TextureStyle | TextureStyleOptions\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @category text\n * @internal\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentMaxCharHeight = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n    private readonly _textureStyle?: TextureStyle;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        if (dynamicOptions.textureStyle)\n        {\n            this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle\n                ? dynamicOptions.textureStyle\n                : new TextureStyle(dynamicOptions.textureStyle);\n        }\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = CanvasTextMetrics.graphemeSegmenter(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        let currentMaxCharHeight = this._currentMaxCharHeight;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += currentMaxCharHeight;\n\n                // reset the line x and height..\n                currentMaxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + currentMaxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentX = 0;\n                    currentY = 0;\n                    currentMaxCharHeight = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._currentMaxCharHeight = currentMaxCharHeight;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        if (this._textureStyle)\n        {\n            texture.source.style = this._textureStyle;\n        }\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        let removeShadow = false;\n\n        if (style.stroke && strokeThickness)\n        {\n            removeShadow = true;\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        const { shadowBlur, shadowOffsetX, shadowOffsetY } = context;\n\n        if (style._fill)\n        {\n            if (removeShadow)\n            {\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (removeShadow)\n        {\n            context.shadowBlur = shadowBlur;\n            context.shadowOffsetX = shadowOffsetX;\n            context.shadowOffsetY = shadowOffsetY;\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n", "import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\n/**\n * The layout data for a bitmap text.\n * This contains the width, height, scale, offsetY and lines of text.\n * Each line contains its width, character positions, characters, space width and spaces index.\n * @category text\n * @internal\n */\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\n/**\n * @param chars\n * @param style\n * @param font\n * @param trimEnd\n * @internal\n */\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n    const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;\n\n    const breakWords = style.wordWrap && style.breakWords;\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += adjustedLineHeight;\n    };\n\n    const checkIsOverflow = (lineWidth: number) =>\n        lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                nextLine();\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);\n\n            if (addWordToNextLine)\n            {\n                nextWord(currentWord);\n                nextLine();\n            }\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n", "/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n", "import { lru } from 'tiny-lru';\nimport { Cache } from '../../assets/cache/Cache';\nimport { type TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n * The options for installing a new BitmapFont. Once installed, the font will be available\n * for use in BitmapText objects through the fontFamily property of TextStyle.\n * @example\n * ```ts\n * import { BitmapFont, BitmapText } from 'pixi.js';\n *\n * // Basic font installation\n * BitmapFont.install({\n *     name: 'BasicFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: '#ffffff'\n *     }\n * });\n *\n * // Advanced font installation\n * BitmapFont.install({\n *     name: 'AdvancedFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ff0000',\n *         stroke: { color: '#000000', width: 2 }\n *     },\n *     // Include specific character ranges\n *     chars: [\n *         ['a', 'z'],           // lowercase letters\n *         ['A', 'Z'],           // uppercase letters\n *         ['0', '9'],           // numbers\n *         '!@#$%^&*()_+-=[]{}' // symbols\n *     ],\n *     resolution: 2,            // High-DPI support\n *     padding: 4,              // Glyph padding\n *     skipKerning: false,      // Enable kerning\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n *\n * // Using the installed font\n * const text = new BitmapText({\n *     text: 'Hello World',\n *     style: {\n *         fontFamily: 'AdvancedFont',\n *         fontSize: 48\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontInstallOptions\n{\n    /**\n     * The name of the font. This will be used as the fontFamily in text styles to access this font.\n     * Must be unique across all installed bitmap fonts.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'MyCustomFont',\n     *     style: { fontFamily: 'Arial' }\n     * });\n     * ```\n     */\n    name?: string;\n\n    /**\n     * Characters included in the font set. You can specify individual characters or ranges.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     * @example\n     * ```ts\n     * // Different ways to specify characters\n     * BitmapFont.install({\n     *     name: 'RangeFont',\n     *     chars: [\n     *         ['a', 'z'],              // Range of characters\n     *         '0123456789',            // String of characters\n     *         [['0', '9'], ['A', 'Z']] // Multiple ranges\n     *     ]\n     * });\n     * ```\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs. Higher values create sharper text at the cost of memory.\n     * Useful for supporting high-DPI displays.\n     * @default 1\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'HiDPIFont',\n     *     resolution: window.devicePixelRatio || 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Balances visual quality with texture space.\n     * - Lower values: More compact, but may have visual artifacts\n     * - Higher values: Better quality, but uses more texture space\n     * @default 4\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'PaddedFont',\n     *     padding: 8 // More padding for better quality\n     * });\n     * ```\n     */\n    padding?: number;\n\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * - true: Faster generation, but text may have inconsistent spacing\n     * - false: Better text appearance, but slower generation\n     * @default false\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'FastFont',\n     *     skipKerning: true // Prioritize performance\n     * });\n     * ```\n     */\n    skipKerning?: boolean;\n\n    /**\n     * Style options to render the BitmapFont with.\n     * Supports all TextStyle properties including fill, stroke, and shadow effects.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'StyledFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: 'white',\n     *         stroke: { color: '#000000', width: 2 },\n     *         dropShadow: {\n     *             color: '#000000',\n     *             blur: 2,\n     *             distance: 3\n     *         }\n     *     }\n     * });\n     * ```\n     */\n    style?: TextStyle | TextStyleOptions;\n\n    /**\n     * Optional texture style to use when creating the font textures.\n     * Controls how the font textures are rendered and filtered.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'CrispFont',\n     *     textureStyle: {\n     *         scaleMode: 'nearest',\n     *     }\n     * });\n     * ```\n     */\n    textureStyle?: TextureStyle | TextureStyleOptions;\n\n    /**\n     * Whether to allow overriding the fill color with a tint at runtime.\n     *\n     * When enabled, the font can be dynamically tinted using the `tint` property of BitmapText,\n     * allowing a single font to display multiple colors without creating separate font textures.\n     * This is memory efficient but requires the font to be rendered with white fill color.\n     *\n     * When disabled, the fill color is permanently baked into the font texture. This allows\n     * any fill color but prevents runtime tinting - each color variation requires a separate font.\n     * @default false (automatically determined based on style)\n     *\n     * **Requirements for tinting:**\n     * - Fill color must be white (`0xFFFFFF` or `'#ffffff'`)\n     * - No stroke effects\n     * - No drop shadows (or only black shadows)\n     * - No gradient or pattern fills\n     *\n     * **Performance considerations:**\n     * - ✅ Enabled: One font texture, multiple colors via tinting (memory efficient)\n     * - ❌ Disabled: Separate font texture per color (higher memory usage)\n     * @example\n     * ```ts\n     * // Correct usage - white fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'TintableFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFFFFFF  // Must be white for tinting\n     *     },\n     *     dynamicFill: true\n     * });\n     *\n     * // Use the font with different colors via tinting\n     * const redText = new BitmapText({\n     *     text: 'Red Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'red }, // Red tint\n     * });\n     *\n     * const blueText = new BitmapText({\n     *     text: 'Blue Text',\n     *     style: { fontFamily: 'TintableFont', fill: 'blue' }, // Blue tint\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Incorrect usage - colored fill with tinting enabled\n     * BitmapFont.install({\n     *     name: 'BadTintFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000  // ❌ Red fill won't tint properly\n     *     },\n     *     dynamicFill: true  // ❌ Will not work as expected\n     * });\n     * ```\n     * @example\n     * ```ts\n     * // Alternative - baked colors (no tinting)\n     * BitmapFont.install({\n     *     name: 'BakedColorFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: 0xFF0000,  // Any color works\n     *         stroke: { color: 0x000000, width: 2 }  // Strokes allowed\n     *     },\n     *     dynamicFill: false  // Color is baked in\n     * });\n     * ```\n     */\n    dynamicFill?: boolean;\n}\n\n/** @advanced */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @type {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n        textureStyle: null,\n    };\n\n    /** Cache for measured text layouts to avoid recalculating them multiple times. */\n    public readonly measureCache = lru<BitmapTextLayoutData>(1000);\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            fontFamilyKey = `${style.styleKey}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const styleCopy = Object.create(style);\n\n            // Override the lineHeight, let the BitmapFont calculate the lineHeight\n            // from the fontMetrics instead using a custom lineHeight from BitmapText parameter\n            styleCopy.lineHeight = 0;\n\n            const fnt = new DynamicBitmapFont({\n                style: styleCopy,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        const id = `${text}-${style.styleKey}-${trimEnd}`;\n\n        // Check if we have a cached layout\n        if (this.measureCache.has(id))\n        {\n            return this.measureCache.get(id);\n        }\n\n        const segments = CanvasTextMetrics.graphemeSegmenter(text);\n\n        // Generate the layout data\n        const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);\n\n        this.measureCache.set(id, layoutData);\n\n        return layoutData;\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false,\n            textureStyle: options.textureStyle,\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n\n    /**\n     * Determines if a style can use tinting instead of baking colors into the bitmap.\n     * Tinting is more efficient as it allows reusing the same bitmap with different colors.\n     * @param style - The text style to evaluate\n     * @returns true if the style can use tinting, false if colors must be baked in\n     * @private\n     */\n    private _canUseTintForStyle(style: TextStyle): boolean\n    {\n        // Exclude strokes, non black shadows and ensure\n        // we have a non gradient or pattern fill,\n        // and the fill color is white\n        return !style._stroke\n            && (!style.dropShadow || style.dropShadow.color === 0x000000)\n            && !style._fill.fill\n            && style._fill.color === 0xFFFFFF;\n    }\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @category text\n * @advanced\n * @class\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nexport const BitmapFontManager = new BitmapFontManagerClass();\n", "import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                // TODO: Check if this is a WebGL renderer before asserting type\n                context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        let fontSize = bitmapFont.fontMetrics.fontSize;\n        let lineHeight = bitmapFont.lineHeight;\n\n        if (style.lineHeight)\n        {\n            fontSize = style.fontSize / scale;\n            lineHeight = style.lineHeight / scale;\n        }\n\n        let linePositionYShift = (lineHeight - fontSize) / 2;\n\n        // if `currentY` is no longer starts from `baseLineOffset`\n        // the `baseLineOffset` below may also need to be removed\n        if (linePositionYShift - bitmapFont.baseLineOffset < 0)\n        {\n            linePositionYShift = 0;\n        }\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = line.chars[j];\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    const texture = charData.texture;\n\n                    context.texture(\n                        texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset + linePositionYShift),\n                        texture.orig.width,\n                        texture.orig.height,\n                    );\n                }\n            }\n\n            currentY += lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n", "import { type Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public texturePromise: Promise<Texture>;\n    public generatingTexture = false;\n    public currentKey: string = '--';\n\n    /**\n     * Creates an instance of BatchableHTMLText.\n     * @param renderer - The renderer instance to be used.\n     */\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n    public resolutionChange()\n    {\n        const text = this.renderable as HTMLText;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n    public destroy()\n    {\n        const { htmlText } = this._renderer;\n\n        htmlText.getReferenceCount(this.currentKey) === null\n            ? htmlText.returnTexturePromise(this.texturePromise)\n            : htmlText.decreaseReferenceCount(this.currentKey);\n        this._renderer.runners.resolutionChange.remove(this);\n        this.texturePromise = null;\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText.styleKey;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(htmlText).catch((e) =>\n                {\n                    console.error(e);\n                });\n            }\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        // We need to preserve the current texture and don't release it until the new texture is generated.\n        // It's necessary to ensure that the texture won't be captured by another field and overwritten with their\n        // content, while our texture is still in progress.\n        const oldTexturePromise = batchableHTMLText.texturePromise;\n\n        batchableHTMLText.texturePromise = null;\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        if (oldTexturePromise)\n        {\n            // Release old texture after new one is generated.\n            texturePromise = texturePromise.finally(() =>\n            {\n                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n            });\n        }\n\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.currentKey = htmlText.styleKey;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText(this._renderer);\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        return batchableHTMLText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\n", "import { DOMAdapter } from '../../environment/adapter';\n\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n", "/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\nimport { type ImageLike } from '../../environment/ImageLike';\n\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\n/** @internal */\nconst nssvg = 'http://www.w3.org/2000/svg';\n/** @internal */\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\n/** @internal */\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image: ImageLike;\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n\n        this.image = DOMAdapter.get().createImage();\n    }\n\n    public destroy(): void\n    {\n        this.svgRoot.remove();\n        this.foreignObject.remove();\n        this.styleElement.remove();\n        this.domElement.remove();\n        this.image.src = '';\n        this.image.remove();\n\n        this.svgRoot = null;\n        this.foreignObject = null;\n        this.styleElement = null;\n        this.domElement = null;\n        this.image = null;\n        this.canvasAndContext = null;\n    }\n}\n", "import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n", "import { loadFontAsBase64 } from './loadFontAsBase64';\n\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions\n{\n    /**\n     * The font family to use in the CSS\n     * @example\n     * 'Arial' or ['Arial', 'Helvetica']\n     */\n    fontFamily: string | string[]\n    /**\n     * The font weight to use in the CSS\n     * @example\n     * 'normal', 'bold', '100', '200', etc.\n     */\n    fontWeight: string\n    /**\n     * The font style to use in the CSS\n     * @example\n     * 'normal', 'italic', 'oblique'\n     */\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n", "import { Cache } from '../../../assets/cache/Cache';\nimport { type FontFaceCache } from '../../../assets/loader/parsers/loadWebFont';\nimport { loadFontCSS } from './loadFontCSS';\n\n/** @internal */\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @returns - The css string\n * @internal\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { entries } = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n                const promises: Promise<string>[] = [];\n\n                entries.forEach((entry) =>\n                {\n                    const url = entry.url;\n                    const faces = entry.faces;\n\n                    const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n\n                    // load each out font with the correct style\n                    promises.push(\n                        ...out.map((style) =>\n                            loadFontCSS(\n                                {\n                                    fontWeight: style.weight,\n                                    fontStyle: style.style,\n                                    fontFamily,\n                                },\n                                url,\n                            ),\n                        ),\n                    );\n                });\n                FontStylePromiseCache.set(\n                    fontFamily,\n                    Promise.all(promises).then((css) => css.join('\\n')),\n                );\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n", "import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n", "import { type ImageLike } from '../../../environment/ImageLike';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: ImageLike, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n", "import { type ImageLike } from '../../../environment/ImageLike';\n\n/**\n * This function loads an SVG image into an IImage element.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: ImageLike, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n", "/* eslint-disable no-restricted-globals */\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n", "import { type ImageLike } from '../../environment/ImageLike';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { type HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLText, HTMLTextOptions } from './HTMLText';\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n        promise: Promise<Texture>,\n    }> = {};\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    /**\n     * @param options\n     * @deprecated Use getTexturePromise instead\n     */\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this.getTexturePromise(options);\n    }\n\n    /**\n     * Increases the reference count for a texture.\n     * @param text - The HTMLText instance associated with the texture.\n     */\n    public getManagedTexture(text: HTMLText): Promise<Texture>\n    {\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? null;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Decreases the reference count for a texture.\n     * If the count reaches zero, the texture is cleaned up.\n     * @param textKey - The key associated with the HTMLText instance.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture.texture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture.texture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Returns a promise that resolves to a texture for the given HTMLText options.\n     * @param options - The options for the HTMLText.\n     * @returns A promise that resolves to a Texture.\n     */\n    public getTexturePromise(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(options);\n    }\n\n    private async _buildTexturePromise(options: HTMLTextOptions)\n    {\n        const { text, style, resolution, textureStyle } = options as {\n            text: string,\n            style: HTMLTextStyle,\n            resolution: number,\n            textureStyle?: TextureStyle,\n        };\n\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(fontFamilies);\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: ImageLike | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (textureStyle) texture.source.style = textureStyle;\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    public returnTexturePromise(texturePromise: Promise<Texture>)\n    {\n        texturePromise.then((texture) =>\n        {\n            this._cleanUp(texture);\n        }).catch(() =>\n        {\n            // #if _DEBUG\n            warn('HTMLTextSystem: Failed to clean texture');\n            // #endif\n        });\n    }\n\n    private _cleanUp(texture: Texture)\n    {\n        TexturePool.returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = 'unknown';\n    }\n\n    public destroy()\n    {\n        // BOOM!\n        (this._renderer as null) = null;\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexturePromise(this._activeTextures[key].promise);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n", "import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n", "/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n", "/** @internal */\nexport const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\n/** @internal */\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n\n};\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n", "import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\n/** @internal */\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n", "import type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n", "import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\nconst sharedQuad = new QuadGeometry();\n\n/** @internal */\nexport class TilingSpriteGpuData\n{\n    public canBatch: boolean = true;\n    public renderable: TilingSprite;\n    public batchableMesh?: BatchableMesh;\n    public geometry?: MeshGeometry;\n    public shader?: TilingSpriteShader;\n\n    constructor()\n    {\n        this.geometry = new MeshGeometry({\n            indices: sharedQuad.indices.slice(),\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\n\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._getTilingSpriteData(tilingSprite);\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): TilingSpriteGpuData\n    {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): TilingSpriteGpuData\n    {\n        const gpuData = new TilingSpriteGpuData();\n\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n", "import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n", "import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n", "import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    /** @internal */\n    public _leftWidth: number;\n    /** @internal */\n    public _rightWidth: number;\n    /** @internal */\n    public _topHeight: number;\n    /** @internal */\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh\n{\n    constructor()\n    {\n        super();\n        this.geometry = new NineSliceGeometry();\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n    }\n}\n\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n\n        const batchableMesh = gpuData;\n\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        return gpuData;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n", "import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * The options to use when creating a new filter.\n * @category filters\n * @advanced\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/**\n * Filter options mixed with shader resources. A filter needs a shader and some resources to work.\n * @category filters\n * @advanced\n * @see {@link FilterOptions}\n */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @category filters\n * @advanced\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @category filters\n * @advanced\n * @example\n * import { Filter } from 'pixi.js';\n *\n * const customFilter = new Filter({\n *     glProgram: new GlProgram({\n *         fragment,\n *         vertex,\n *     }),\n *     resources: {\n *         timeUniforms: {\n *             uTime: { value: 0.0, type: 'f32' },\n *         },\n *     },\n * });\n *\n * // Apply the filter\n * sprite.filters = [customFilter];\n *\n * // Update uniform\n * app.ticker.add((ticker) => {\n *     filter.resources.timeUniforms.uniforms.uTime += 0.04 * ticker.deltaTime;\n * });\n */\nexport class Filter extends Shader\n{\n    /** The default filter settings */\n    public static defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n", "var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=defaultFilter.vert.mjs.map\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\nuniform sampler2D uTexture;\\nvoid main() {\\n    finalColor = texture(uTexture, vTextureCoord);\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=passthrough.frag.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize: vec4<f32>,\\n  uInputPixel: vec4<f32>,\\n  uInputClamp: vec4<f32>,\\n  uOutputFrame: vec4<f32>,\\n  uGlobalFrame: vec4<f32>,\\n  uOutputTexture: vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler: sampler;\\n\\nstruct VSOutput {\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv: vec2<f32>\\n};\\n\\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition: vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n) -> @location(0) vec4<f32> {\\n    return textureSample(uTexture, uSampler, uv);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=passthrough.wgsl.mjs.map\n", "import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './passthrough.frag';\nimport source from './passthrough.wgsl';\n\n/**\n * The PassthroughFilter passes the input data through without altering it.\n * It serves as a basic filter, performing no graphical alterations.\n * @category filters\n * @internal\n */\nexport class PassthroughFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: { source, entryPoint: 'mainVertex' },\n            fragment: { source, entryPoint: 'mainFragment' },\n            name: 'passthrough-filter'\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'passthrough-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n        });\n    }\n}\n", "import { Matrix } from '../../../maths';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * This matrix is used for calculations of the bounds for renderables placed inside cacheAsTexture render groups.\n * @ignore\n * @internal\n */\nconst tempProjectionMatrix: Matrix = new Matrix();\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const actualMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n\n        if (renderGroup?.isCachedAsTexture)\n        {\n            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform)\n                .append(renderable.worldTransform);\n        }\n        else if (renderGroup?._parentCacheAsTextureRenderGroup)\n        {\n            bounds.matrix = tempProjectionMatrix\n                .copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform)\n                .append(renderable.groupTransform);\n        }\n        else\n        {\n            bounds.matrix = renderable.worldTransform;\n        }\n\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = actualMatrix;\n\n    return bounds;\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { PassthroughFilter } from '../filters/defaults/passthrough/PassthroughFilter';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n\n    /** The first enabled filter index in the current filter list. */\n    public firstEnabledIndex = -1;\n\n    /** The last enabled filter index in the current filter list. */\n    public lastEnabledIndex = -1;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n    private _passthroughFilter: Filter;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        // If the filter is disabled, we still need to write something into the output surface.\n        // Render a pass-through (copy) so the pipeline remains intact.\n        const filterToApply = filter.enabled\n            ? filter\n            : this._getPassthroughFilter();\n\n        this._setupBindGroupsAndRender(filterToApply, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.orig.width,\n            1.0 / sprite.texture.orig.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        this._passthroughFilter?.destroy(true);\n        (this._passthroughFilter as null) = null;\n    }\n\n    private _getPassthroughFilter(): Filter\n    {\n        this._passthroughFilter ??= new PassthroughFilter();\n\n        return this._passthroughFilter;\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: Renderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: Renderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        // Very cryptic, but important(!) moment.\n        //\n        // If we try to pull texture from the pool for backTexture before inputTexture,\n        // it will be unbounded later by startRenderPass. It happens because in such a case - the current backTexture\n        // is actually inputTexture from the previous filter application (check `pop` method).\n        //\n        // So maintaining the order (inputTexture -> backTexture) helps us to prevent unwanted texture unbinding.\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n\n        // set the global uniforms to take into account the bounds offset required\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n        const firstEnabled = filterData.firstEnabledIndex;\n        const lastEnabled = filterData.lastEnabledIndex;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (firstEnabled === lastEnabled)\n        {\n            // render a single filter...\n            filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (let i = firstEnabled; i < lastEnabled; i++)\n            {\n                const filter = filters[i];\n\n                if (!filter.enabled) continue;\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n            // apply the last enabled filter to the output\n            filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n        // cache first/last enabled indices for later passes\n        let firstEnabledIndex = -1;\n        let lastEnabledIndex = -1;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // Only enabled filters should influence pipeline characteristics\n            if (!filter.enabled) continue;\n\n            if (firstEnabledIndex === -1) firstEnabledIndex = i;\n            lastEnabledIndex = i;\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = true;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n        filterData.firstEnabledIndex = firstEnabledIndex;\n        filterData.lastEnabledIndex = lastEnabledIndex;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 0)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n", "import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n", "import '../accessibility/init.mjs';\nimport '../app/init.mjs';\nimport '../events/init.mjs';\nimport '../dom/init.mjs';\nimport '../spritesheet/init.mjs';\nimport '../rendering/init.mjs';\nimport '../scene/graphics/init.mjs';\nimport '../scene/mesh/init.mjs';\nimport '../scene/particle-container/init.mjs';\nimport '../scene/text/init.mjs';\nimport '../scene/text-bitmap/init.mjs';\nimport '../scene/text-html/init.mjs';\nimport '../scene/sprite-tiling/init.mjs';\nimport '../scene/sprite-nine-slice/init.mjs';\nimport '../filters/init.mjs';\n\n\"use strict\";\n//# sourceMappingURL=browserAll.mjs.map\n", "import '../app/init.mjs';\nimport '../spritesheet/init.mjs';\nimport '../rendering/init.mjs';\nimport '../scene/graphics/init.mjs';\nimport '../scene/mesh/init.mjs';\nimport '../scene/particle-container/init.mjs';\nimport '../scene/text/init.mjs';\nimport '../scene/text-bitmap/init.mjs';\nimport '../scene/text-html/init.mjs';\nimport '../scene/sprite-tiling/init.mjs';\nimport '../scene/sprite-nine-slice/init.mjs';\nimport '../filters/init.mjs';\n\n\"use strict\";\n//# sourceMappingURL=webworkerAll.mjs.map\n", "import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n * @category environment\n * @advanced\n */\nexport async function loadEnvironmentExtensions(skip: boolean): Promise<void>\n{\n    if (skip) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n * @category environment\n * @advanced\n */\nexport async function autoDetectEnvironment(add: boolean): Promise<void>\n{\n    return loadEnvironmentExtensions(!add);\n}\n", "// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (_e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n", "/**\n * Constants used by the renderer for clearing the screen or render textures.\n * @category rendering\n * @advanced\n */\nexport enum CLEAR\n{\n    /** No clear operation. */\n    NONE = 0,\n    /** Clear the color buffer. */\n    COLOR = 16384,\n    /** Clear the stencil buffer. */\n    STENCIL = 1024,\n    /** Clear the depth buffer. */\n    DEPTH = 256,\n\n    /** Clear the color and depth buffers. */\n    COLOR_DEPTH = COLOR | DEPTH,\n    /** Clear the color and stencil buffers. */\n    COLOR_STENCIL = COLOR | STENCIL,\n    /** Clear the depth and stencil buffers. */\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    /** Clear the color, depth, and stencil buffers. */\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/**\n * Used for clearing render textures. true is the same as `ALL` false is the same as `NONE`\n * @category rendering\n * @advanced\n */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n", "/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @category rendering\n * @internal\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /* jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```ts\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\n/**\n * The configuration for the renderer.\n * This is used to define the systems and render pipes that will be used by the renderer.\n * @category rendering\n * @advanced\n */\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @category rendering\n * @standard\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @category rendering\n * @advanced\n */\nexport interface ClearOptions\n{\n    /**\n     * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n     * please ensure you have set `multiView` to `true` on renderer.\n     */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\n/**\n * Options for destroying the renderer.\n * This can be a boolean or an object.\n * @category rendering\n * @standard\n */\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions & {\n    /** Whether to clean up global resource pools/caches */\n    releaseGlobalResources?: boolean;\n}>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'resetState',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@link WebGLRenderer}\n * or {@link WebGPURenderer}.\n * Alternatively, you can also use {@link autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link EventSystem}           | This manages UI events.                                                       |\n * | {@link AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @category rendering\n * @advanced\n * @property {HelloSystem} hello - HelloSystem instance.\n * @property {TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {FilterSystem} filter - FilterSystem instance.\n * @property {GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {TextureSystem} texture - TextureSystem instance.\n * @property {EventSystem} events - EventSystem instance.\n * @property {ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    /** @internal */\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    /** @internal */\n    public readonly uid = uid('renderer');\n\n    /** @internal */\n    public _roundPixels: 0 | 1;\n\n    /** @internal */\n    public readonly runners: Runners = Object.create(null) as Runners;\n    /** @internal */\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n\n            options.clearColor ??= this.background.colorRgba;\n            options.clear ??= this.background.clearBeforeRender;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        // Check if the container is visible before proceeding with rendering\n        if (!options.container.visible)\n        {\n            return;\n        }\n\n        // lets ensure this object is a render group so we can render it!\n        // the renderer only likes to render - render groups.\n        options.container.enableRenderGroup();\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    /**\n     * Clears the render target.\n     * @param options - The options to use when clearing the render target.\n     * @param options.target - The render target to clear.\n     * @param options.clearColor - The color to clear with.\n     * @param options.clear - The clear mode to use.\n     * @advanced\n     */\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @type {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n\n            this.runners.destroy.add((this.renderPipes as any)[name]);\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        if (options === true || (typeof options === 'object' && options.releaseGlobalResources))\n        {\n            GlobalResourceRegistry.release();\n        }\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n    /**\n     * Resets the rendering state of the renderer.\n     * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n     * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n     * render will reset all internal caches and ensure it executes correctly.\n     *\n     * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n     * ```js\n     * // Reset Three.js state\n     * threeRenderer.resetState();\n     *\n     * // Render a Three.js scene\n     * threeRenderer.render(threeScene, threeCamera);\n     *\n     * // Reset PixiJS state since Three.js modified the WebGL context\n     * pixiRenderer.resetState();\n     *\n     * // Now render Pixi content\n     * pixiRenderer.render(pixiScene);\n     * ```\n     * @advanced\n     */\n    public resetState(): void\n    {\n        this.runners.resetState.emit();\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    private _maxTextures = 0;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        this._maxTextures = renderer.limits.maxBatchableTextures;\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(this._maxTextures),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(\n                    textureBatch.textures,\n                    textureBatch.count,\n                    this._maxTextures\n                );\n\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n", "/** @internal */\nexport const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\n/** @internal */\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n\n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @category rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer as WebGPURenderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @category rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = shader.gpuProgram;\n\n        this._shader = shader;\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry, program);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(\n                textureBatch.textures,\n                textureBatch.count,\n                renderer.limits.maxBatchableTextures\n            );\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState,\n            batch.topology\n        );\n\n        batch.bindGroup._touch(renderer.textureGC.count);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @category rendering\n * @internal\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderer\n * @internal\n */\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The RenderGroupPipe is a render pipe for rendering RenderGroups.\n * @internal\n */\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n\n        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n                offset: { x: 0, y: 0 },\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n", "/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n * @category utils\n * @internal\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n", "import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\n/**\n * @param renderGroup\n * @param updateChildRenderGroups\n * @internal\n */\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\n/**\n * @param renderGroup\n * @internal\n */\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\n/**\n * @param container\n * @param updateTick\n * @param updateFlags\n * @internal\n */\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n", "import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @internal\n */\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            // Early out as nothing further needs to be updated!\n            if (!renderGroup.textureNeedsUpdate) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        // Update the closest cache reference for children if this render group is cached as texture\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture, true);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                const scaleMode = renderGroup.textureOptions.scaleMode ?? 'linear';\n                const texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                texture._source.style = new TextureStyle({ scaleMode });\n                renderGroup.texture = texture;\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture, true);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Sprite } from './Sprite';\n\n/** @internal */\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = new BatchableSprite();\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        sprite._gpuData[this._renderer.uid] = batchableSprite;\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\n\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @type {RegExp}\n * @default /(?:^data:image\\/([\\w+]+);(?:[\\w=]+|charset=[\\w-]+)?(?:;base64)?,)/i\n * @example\n * import { DATA_URI } from 'pixi.js';\n *\n * DATA_URI.test('data:image/png;base64,foobar'); // => true\n * @category utils\n * @advanced\n */\nexport const DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n// export the event emitter so we can use it in external modules\nexport { EventEmitter };\n\n/**\n * The current version of PixiJS. This is automatically replaced by the build process.\n * @internal\n */\nexport const VERSION = '$_VERSION';\n", "import { type ExtensionMetadata, ExtensionType } from '../../extensions/Extensions';\nimport { VERSION } from '../const';\n\nimport type { Application } from '../../app/Application';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\n\ndeclare global\n{\n    /* eslint-disable no-var */\n    var __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    var __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    /* eslint-enable no-var */\n}\n\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @category app\n * @internal\n */\nexport class ApplicationInitHook\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    public static init(): void\n    {\n        globalThis.__PIXI_APP_INIT__?.(this as unknown as Application, VERSION);\n    }\n    public static destroy(): void\n    {\n        // nothing to do\n    }\n}\n\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @category rendering\n * @internal\n */\nexport class RendererInitHook implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'initHook',\n        priority: -10,\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n    public init(): void\n    {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n    }\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\n/** @internal */\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @category rendering\n * @advanced\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher({\n                maxTextures: this.renderer.limits.maxBatchableTextures,\n            });\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n", "var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n", "var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\n/** @internal */\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            clipToViewport: false,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\n/** @internal */\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\n/** @internal */\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\n/** @internal */\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\n/** @internal */\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\n/** @internal */\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\n/** @internal */\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorStack = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\n/** @internal */\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\n/** @internal */\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\n/** @internal */\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n/**\n * Options for the background system.\n * @category rendering\n * @advanced\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /** Alias for `backgroundColor` */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * This value determines whether the canvas is initialized with alpha transparency support.\n     * Note: This cannot be changed after initialization. If set to `1`, the canvas will remain opaque,\n     * even if a transparent background color is set later.\n     * @default 1\n     */\n    backgroundAlpha?: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @default true\n     */\n    clearBeforeRender?: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @category rendering\n * @advanced\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        // #if _DEBUG\n\n        const incoming = Color.shared.setValue(value);\n\n        if (incoming.alpha < 1 && this._backgroundColor.alpha === 1)\n        {\n            warn(\n                'Cannot set a transparent background on an opaque canvas. '\n                + 'To enable transparency, set backgroundAlpha < 1 when initializing your Application.'\n            );\n        }\n        // #endif\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n", "import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @category rendering\n * @internal\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList?: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n    private readonly _blendModeStack: BLEND_MODES[] = [];\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.prerender.add(this);\n    }\n\n    public prerender()\n    {\n        // make sure we reset the blend modes to normal\n        // this way the next render will register any changes\n        this._activeBlendMode = 'normal';\n        this._isAdvanced = false;\n    }\n\n    /**\n     * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n     * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n     * @param blendMode - The blend mode to activate.\n     * @param instructionSet - The instruction set being built.\n     */\n    public pushBlendMode(renderable: Renderable | RenderGroup, blendMode: BLEND_MODES, instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.push(blendMode);\n\n        this.setBlendMode(renderable, blendMode, instructionSet);\n    }\n\n    /**\n     * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public popBlendMode(instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.pop();\n        const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? 'normal';\n\n        this.setBlendMode(null, blendMode, instructionSet);\n    }\n\n    /**\n     * Ensure a blend mode switch is added to the instruction set when the mode changes.\n     * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n     * rendered within a single filter pass.\n     * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n     * @param blendMode - The target blend mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public setBlendMode(\n        renderable: Renderable | RenderGroup | null,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet\n    )\n    {\n        const isRenderGroup = renderable instanceof RenderGroup;\n\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced && renderable && !isRenderGroup)\n            {\n                this._renderableList?.push(renderable);\n            }\n\n            return;\n        }\n\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n\n        this._activeBlendMode = blendMode;\n\n        if (!renderable) return;\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);\n    }\n\n    private _beginAdvancedBlendMode(renderable: Renderable | RenderGroup, instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n                + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        const filterEffect = this._ensureFilterEffect(blendMode);\n        const isRenderGroup = renderable instanceof RenderGroup;\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            filterEffect,\n            renderables: isRenderGroup ? null : [renderable],\n            container: isRenderGroup ? renderable.root : null,\n            canBundle: false\n        };\n\n        this._renderableList = instruction.renderables;\n\n        instructionSet.add(instruction);\n    }\n\n    private _ensureFilterEffect(blendMode: BLEND_MODES): FilterEffect\n    {\n        let filterEffect: FilterEffect = this._filterHash[blendMode];\n\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        return filterEffect;\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._isAdvanced = false;\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (!this._isAdvanced) return;\n\n        this._endAdvancedBlendMode(instructionSet);\n    }\n\n    /** @internal */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * Controls the output format and quality of extracted images.\n * @example\n * ```ts\n * // Extract as PNG (default)\n * const pngImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // Extract as JPEG with quality setting\n * const jpgImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'jpg',\n *     quality: 0.8\n * });\n *\n * // Extract as WebP for better compression\n * const webpImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'webp',\n *     quality: 0.9\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface ImageOptions\n{\n    /**\n     * The format of the extracted image.\n     * - 'png': Lossless format, best for images with text or sharp edges\n     * - 'jpg': Lossy format, smaller file size, good for photos\n     * - 'webp': Modern format with better compression\n     * @example\n     * ```ts\n     * // Extract as PNG\n     * const pngImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'png'\n     * });\n     * // Extract as JPEG\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     * });\n     * ```\n     * @default 'png'\n     */\n    format?: Formats;\n\n    /**\n     * The quality of the extracted image, between 0 and 1.\n     * Only applies to lossy formats (jpg, webp).\n     * - 1: Maximum quality\n     * - 0: Maximum compression\n     * @example\n     * ```ts\n     * // Extract as JPEG with 80% quality\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     *     quality: 0.8\n     * });\n     * // Extract as WebP with 90% quality\n     * const webpImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'webp',\n     *     quality: 0.9\n     * });\n     * ```\n     * @default 1\n     */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * These options control how content is extracted and processed from the renderer.\n * @example\n * ```ts\n * // Basic extraction\n * const pixels = renderer.extract.pixels({\n *     target: sprite,\n * });\n *\n * // Extract with custom region and resolution\n * const canvas = renderer.extract.canvas({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n * });\n *\n * // Extract with background color and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface BaseExtractOptions\n{\n    /**\n     * The target to extract. Can be a Container or Texture.\n     * @example\n     * ```ts\n     * // Extract from a sprite\n     * const sprite = new Sprite(texture);\n     * renderer.extract.pixels({ target: sprite });\n     *\n     * // Extract from a texture directly\n     * renderer.extract.pixels({ target: texture });\n     * ```\n     */\n    target: Container | Texture;\n\n    /**\n     * The region of the target to extract. If not specified, extracts the entire target.\n     * @example\n     * ```ts\n     * // Extract a specific region\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the extracted content. Higher values create sharper images.\n     * @default 1\n     * @example\n     * ```ts\n     * // Extract at 2x resolution for retina displays\n     * renderer.extract.image({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the extracted content before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing during extraction.\n     * Improves quality but may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Enable anti-aliasing for smoother edges\n     * renderer.extract.image({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * Combines base extraction options with image-specific settings.\n * @example\n * ```ts\n * // Basic PNG extraction\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // High-quality JPEG with custom region\n * const image = await renderer.extract.image({\n *     target: container,\n *     format: 'jpg',\n *     quality: 0.9,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // WebP with background and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     format: 'webp',\n *     quality: 0.8,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - {@link ImageOptions} for image format and quality settings\n *\n * Common use cases:\n * - Capturing game screenshots\n * - Saving rendered content\n * - Creating image thumbnails\n * - Exporting canvas content\n * @see {@link ExtractSystem.image} For the method that uses these options\n * @see {@link ExtractSystem.base64} For base64 encoding\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * Combines base extraction options with download-specific settings.\n * @example\n * ```ts\n * // Basic download with default filename\n * renderer.extract.download({\n *     target: sprite\n * });\n *\n * // Download with custom filename and region\n * renderer.extract.download({\n *     target: container,\n *     filename: 'screenshot.png',\n *     frame: new Rectangle(0, 0, 100, 100)\n * });\n *\n * // Download with high resolution and background\n * renderer.extract.download({\n *     target: stage,\n *     filename: 'hd-capture.png',\n *     resolution: 2,\n *     clearColor: '#ff0000'\n * });\n *\n * // Download with anti-aliasing\n * renderer.extract.download({\n *     target: graphics,\n *     filename: 'smooth.png',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - Additional download-specific options\n *\n * Common use cases:\n * - Saving game screenshots\n * - Exporting rendered content\n * - Creating downloadable assets\n * - Saving canvas state\n * @see {@link ExtractSystem.download} For the method that uses these options\n * @see {@link ExtractSystem.image} For creating images without download\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /**\n     * The filename to use when downloading the content.\n     * Should include the desired file extension (e.g., .png).\n     * @default 'image.png'\n     * @example\n     * ```ts\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'my-screenshot.png'\n     * });\n     * ```\n     */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer. Represents a union of all possible extraction option types.\n * Used by various extraction methods to support different output formats and configurations.\n * @example\n * ```ts\n * // Basic canvas extraction\n * const canvas = renderer.extract.canvas({\n *     target: sprite\n * });\n *\n * // Image extraction with format\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png',\n *     quality: 1\n * });\n *\n * // Download with filename\n * renderer.extract.download({\n *     target: sprite,\n *     filename: 'screenshot.png'\n * });\n *\n * // Advanced extraction with multiple options\n * const image = await renderer.extract.image({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     format: 'webp',\n *     quality: 0.8\n * });\n * ```\n *\n * Supports three types of options:\n * - {@link BaseExtractOptions} - Basic extraction settings\n * - {@link ExtractImageOptions} - Image-specific settings with format and quality\n * - {@link ExtractDownloadOptions} - Download settings with filename\n *\n * Common use cases:\n * - Extracting raw pixels\n * - Creating canvas elements\n * - Generating downloadable images\n * - Taking screenshots\n * - Creating thumbnails\n * @see {@link ExtractSystem.canvas} For canvas extraction\n * @see {@link ExtractSystem.image} For image extraction\n * @see {@link ExtractSystem.download} For downloading content\n * @category rendering\n * @advanced\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * ```ts\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n * ```\n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n * @category rendering\n * @standard\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /**\n     * Default options for image extraction.\n     * @example\n     * ```ts\n     * // Customize default options\n     * ExtractSystem.defaultImageOptions.format = 'webp';\n     * ExtractSystem.defaultImageOptions.quality = 0.8;\n     *\n     * // Use defaults\n     * const image = await renderer.extract.image(sprite);\n     * ```\n     */\n    public static defaultImageOptions: ImageOptions = {\n        format: 'png' as Formats,\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Creates an IImage from a display object or texture.\n     * @param options - Options for creating the image, or the target to extract\n     * @returns Promise that resolves with the generated IImage\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const image = await renderer.extract.image(sprite);\n     * document.body.appendChild(image);\n     *\n     * // Advanced usage with options\n     * const image = await renderer.extract.image({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2,\n     *     clearColor: '#ff0000',\n     *     antialias: true\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const image = await renderer.extract.image(texture);\n     * ```\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.base64} For base64 string output\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ImageLike} For the image interface\n     * @category rendering\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>\n    {\n        const image = DOMAdapter.get().createImage();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Converts the target into a base64 encoded string.\n     *\n     * This method works by first creating\n     * a canvas using `Extract.canvas` and then converting it to a base64 string.\n     * @param options - The options for creating the base64 string, or the target to extract\n     * @returns Promise that resolves with the base64 encoded string\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const base64 = await renderer.extract.base64(sprite);\n     * console.log(base64); // data:image/png;base64,...\n     *\n     * // Advanced usage with options\n     * const base64 = await renderer.extract.base64({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2\n     * });\n     * ```\n     * @throws Will throw an error if the platform doesn't support any of:\n     * - ICanvas.toDataURL\n     * - ICanvas.toBlob\n     * - ICanvas.convertToBlob\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @category rendering\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders the target to it and returns it.\n     * This method is useful for creating static images or when you need direct canvas access.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns A Canvas element with the texture rendered on\n     * @example\n     * ```ts\n     * // Basic canvas extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const canvas = renderer.extract.canvas(sprite);\n     * document.body.appendChild(canvas);\n     *\n     * // Extract with custom region\n     * const canvas = renderer.extract.canvas({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const canvas = renderer.extract.canvas({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const canvas = renderer.extract.canvas(texture);\n     *\n     * // Extract with anti-aliasing\n     * const canvas = renderer.extract.canvas({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n     * with integer values between 0 and 255 (inclusive).\n     * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n     * @example\n     * ```ts\n     * // Basic pixel extraction\n     * const sprite = new Sprite(texture);\n     * const pixels = renderer.extract.pixels(sprite);\n     * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n     *\n     * // Extract with custom region\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For image output\n     * @category rendering\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Creates a texture from a display object or existing texture.\n     *\n     * This is useful for creating\n     * reusable textures from rendered content or making copies of existing textures.\n     * > [!NOTE] The returned texture should be destroyed when no longer needed\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns A new texture containing the extracted content\n     * @example\n     * ```ts\n     * // Basic texture extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const extractedTexture = renderer.extract.texture(sprite);\n     *\n     * // Extract with custom region\n     * const regionTexture = renderer.extract.texture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const hiResTexture = renderer.extract.texture({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Create a new sprite from extracted texture\n     * const newSprite = new Sprite(\n     *     renderer.extract.texture({\n     *         target: graphics,\n     *         antialias: true\n     *     })\n     * );\n     *\n     * // Clean up when done\n     * extractedTexture.destroy(true);\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link Texture} For texture management\n     * @see {@link GenerateTextureSystem} For texture generation\n     * @category rendering\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Extracts and downloads content from the renderer as an image file.\n     * This is a convenient way to save screenshots or export rendered content.\n     * > [!NOTE] The download will use PNG format regardless of the filename extension\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     * @example\n     * ```ts\n     * // Basic download with default filename\n     * const sprite = new Sprite(texture);\n     * renderer.extract.download(sprite); // Downloads as 'image.png'\n     *\n     * // Download with custom filename\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'screenshot.png'\n     * });\n     *\n     * // Download with custom region\n     * renderer.extract.download({\n     *     target: container,\n     *     filename: 'region.png',\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Download with high resolution and background\n     * renderer.extract.download({\n     *     target: stage,\n     *     filename: 'hd-screenshot.png',\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Download with anti-aliasing\n     * renderer.extract.download({\n     *     target: graphics,\n     *     filename: 'smooth.png',\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractDownloadOptions} For detailed options\n     * @see {@link ExtractSystem.image} For creating images without download\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @category rendering\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        /* eslint-disable no-restricted-globals */\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        /* eslint-enable no-restricted-globals */\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * The image will be displayed in the browser's console using CSS background images.\n     * @param options - The options for logging the image, or the target to log\n     * @param options.width - The width of the logged image preview in the console (in pixels)\n     * @example\n     * ```ts\n     * // Basic usage\n     * const sprite = new Sprite(texture);\n     * renderer.extract.log(sprite);\n     * ```\n     * @see {@link ExtractSystem.canvas} For getting raw canvas output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     * @advanced\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link Texture}\n * @category rendering\n * @advanced\n */\nexport class RenderTexture extends Texture\n{\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        return new RenderTexture({\n            source: new TextureSource(options)\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n", "import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n    /**\n     * The container to generate the texture from.\n     * This can be any display object like Sprite, Container, or Graphics.\n     * @example\n     * ```ts\n     * const graphics = new Graphics()\n     *     .circle(0, 0, 50)\n     *     .fill('red');\n     *\n     * const texture = renderer.generateTexture({\n     *     target: graphics\n     * });\n     * ```\n     */\n    target: Container;\n\n    /**\n     * The region of the container that should be rendered.\n     * If not specified, defaults to the local bounds of the container.\n     * @example\n     * ```ts\n     * // Extract only a portion of the container\n     * const texture = renderer.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the texture being generated.\n     * Higher values create sharper textures at the cost of memory.\n     * @default renderer.resolution\n     * @example\n     * ```ts\n     * // Generate a high-resolution texture\n     * const hiResTexture = renderer.generateTexture({\n     *     target: sprite,\n     *     resolution: 2 // 2x resolution\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the texture before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Generate a smooth texture\n     * const texture = renderer.generateTexture({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n\n    /**\n     * Advanced options for configuring the texture source.\n     * Controls texture properties like scale mode and filtering.\n     * @advanced\n     * @example\n     * ```ts\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     textureSourceOptions: {\n     *         scaleMode: 'linear',\n     *     }\n     * });\n     * ```\n     */\n    textureSourceOptions?: GenerateTextureSourceOptions;\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Creates a texture from a display object that can be used for creating sprites and other textures.\n     * This is particularly useful for optimizing performance when a complex container needs to be reused.\n     * @param options - Generate texture options or a container to convert to texture\n     * @returns A new RenderTexture containing the rendered display object\n     * @example\n     * ```ts\n     * // Basic usage with a container\n     * const container = new Container();\n     * container.addChild(\n     *     new Graphics()\n     *         .circle(0, 0, 50)\n     *         .fill('red')\n     * );\n     *\n     * const texture = renderer.textureGenerator.generateTexture(container);\n     *\n     * // Advanced usage with options\n     * const texture = renderer.textureGenerator.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n     *     resolution: 2,                        // High DPI\n     *     clearColor: '#ff0000',               // Red background\n     *     antialias: true                      // Smooth edges\n     * });\n     *\n     * // Create a sprite from the generated texture\n     * const sprite = new Sprite(texture);\n     *\n     * // Clean up when done\n     * texture.destroy(true);\n     * ```\n     * @see {@link GenerateTextureOptions} For detailed texture generation options\n     * @see {@link RenderTexture} For the type of texture created\n     * @category rendering\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\n/**\n * Type definition for the global uniforms used in the renderer.\n * This includes projection matrix, world transform matrix, world color, and resolution.\n * @category rendering\n * @advanced\n */\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\n/**\n * Options for the global uniforms system.\n * This includes size, projection matrix, world transform matrix, world color, and offset.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\n/**\n * Data structure for the global uniforms used in the renderer.\n * This includes the projection matrix, world transform matrix, world color, resolution, and bind group.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\n/** @internal */\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @category rendering\n * @advanced\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._globalUniformDataStack.length = 0;\n        this._uniformsPool.length = 0;\n        this._activeUniforms.length = 0;\n        this._bindGroupPool.length = 0;\n        this._activeBindGroups.length = 0;\n        this._currentGlobalUniformData = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @category rendering\n * @advanced\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n", "import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n * @category utils\n * @advanced\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @category rendering\n * @advanced\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @category rendering\n * @advanced\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n", "/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @category utils\n * @internal\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @category utils\n * @internal\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @category rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n * @advanced\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n * @example\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @category rendering\n * @advanced\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @category rendering\n * @advanced\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /** default options for the TextureGCSystem */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     */\n    public count: number;\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     */\n    public checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     */\n    public maxIdle: number;\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     */\n    public checkCountMax: number;\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     */\n    public active: boolean;\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        options = { ...TextureGCSystem.defaultOptions, ...options };\n\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n        this.active = options.textureGCActive;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    protected postrender(): void\n    {\n        if (!this._renderer.renderingToScreen)\n        {\n            return;\n        }\n\n        this.count++;\n\n        if (!this.active) return;\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    public run(): void\n    {\n        const managedTextures = this._renderer.texture.managedTextures;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // Only supports non generated textures at the moment!\n            if (\n                texture.autoGarbageCollect\n                && texture.resource\n                && texture._touched > -1\n                && this.count - texture._touched > this.maxIdle\n            )\n            {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @category rendering\n * @advanced\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @category rendering\n * @advanced\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n", "import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry';\nimport { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nGlobalResourceRegistry.register(canvasCache);\n\n/**\n * @param canvas\n * @param options\n * @internal\n */\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\n/**\n * @param canvas\n * @internal\n */\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { type RendererOptions } from '../../types';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     */\n    height?: number;\n    /** The canvas to use as a view, optional. */\n    canvas?: ICanvas;\n    /**\n     * Alias for `canvas`.\n     * @deprecated since 8.0.0\n     */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     *\n     * This is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** The resolution / device pixel ratio of the renderer. */\n    resolution?: number;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer. */\n    depth?: boolean;\n}\n\n/**\n * Options for destroying the ViewSystem.\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @advanced\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions> >\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n     * @type {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = (options as RendererOptions).backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @example\n     * viewSystem.destroy();\n     * viewSystem.destroy(true);\n     * viewSystem.destroy({ removeView: true });\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        this.texture.destroy();\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n", "import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\n/**\n * Shared systems for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\n/**\n * Shared render pipes for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @category rendering\n * @advanced\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_hash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView({\n\n                });\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._hash))\n        {\n            this._hash[key] = null;\n        }\n\n        this._hash = null;\n\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n * @category rendering\n * @advanced\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuBuffers: { [key: number]: GPUBuffer } = Object.create(null);\n    private readonly _managedBuffers: Buffer[] = [];\n\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        for (const id in this._gpuBuffers)\n        {\n            this._gpuBuffers[id].destroy();\n        }\n\n        this._gpuBuffers = {};\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        if (!this._gpuBuffers[buffer.uid])\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n            buffer.on('destroy', this.onBufferDestroy, this);\n\n            this._managedBuffers.push(buffer);\n        }\n\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n\n    /**\n     * Disposes buffer\n     * @param buffer - buffer with data\n     */\n    protected onBufferDestroy(buffer: Buffer): void\n    {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n\n        this._destroyBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n\n        (this._managedBuffers as null) = null;\n\n        this._gpuBuffers = null;\n    }\n\n    private _destroyBuffer(buffer: Buffer): void\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n        buffer.off('destroy', this.onBufferDestroy, this);\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GPU object.\n * Contains the GPU adapter and device.\n * @category rendering\n * @advanced\n */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @category rendering\n * @advanced\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     */\n    forceFallbackAdapter: boolean;\n    /** Using shared device and adaptor from other engine */\n    gpu?: GPU;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options))\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.textureGC.count);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry, program: GpuProgram)\n    {\n        // when binding a buffers for geometry, there is no need to bind a buffer more than once if it is interleaved.\n        // which is often the case for Pixi. This is a performance optimisation.\n        // Instead of looping through the attributes, we instead call getBufferNamesToBind\n        // which returns a list of buffer names that need to be bound.\n        // we can then loop through this list and bind the buffers.\n        // essentially only binding a single time for any buffers that are interleaved.\n        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n\n        for (const i in buffersToBind)\n        {\n            this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry, shader.gpuProgram);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount ?? geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { type System } from '../shared/system/System';\nimport { type WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the WebGPU Device rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGPURenderer();\n * await renderer.init(); // GPU limits are populated after this call\n *\n * console.log(renderer.limits.maxTextures);\n * console.log(renderer.limits.maxBatchableTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GpuLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n        this.maxBatchableTextures = this.maxTextures;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n", "import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\n/** @internal */\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @category rendering\n * @advanced\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n", "import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n", "// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\n/** @internal */\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n", "import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\n/**\n * @param uboElements\n * @param parserCode\n * @param arrayGenerationFunction\n * @param singleSettersMap\n * @internal\n */\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n", "import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\n/** @internal */\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\n/** @internal */\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n", "import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n", "import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @category rendering\n * @advanced\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @category rendering\n * @advanced\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n", "/** @internal */\nexport class UboBatch\n{\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this.data = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n/** @internal */\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        for (const i in this._bindGroupHash)\n        {\n            this._bindGroupHash[i] = null;\n        }\n\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i]?.destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n\n        this._renderer = null;\n    }\n}\n", "import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in any gaps. We do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of the time users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way,\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n * @internal\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n", "import { STENCIL_MODES } from '../../shared/state/const';\n\n/**\n * The stencil state for the GPU renderer.\n * This is used to define how the stencil buffer should be configured.\n * @category rendering\n * @advanced\n */\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\n/** @internal */\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n};\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @category rendering\n * @advanced\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology ||= geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            const attributes = Object.values(data[i].attributes);\n\n            const shaderLocation = attributes[0].shaderLocation;\n\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === shaderLocation)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n", "import type { Matrix } from '../../../../maths/matrix/Matrix';\n\n/**\n * @param pm\n * @param x\n * @param y\n * @param width\n * @param height\n * @param flipY\n * @internal\n */\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n", "/* eslint-disable no-restricted-globals */\nimport type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n * @internal\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @category rendering\n * @see environment.ICanvas\n * @see Texture\n * @see RenderTarget\n * @advanced\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture.\n     *\n     * NOTE:\n     * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n     *\n     * The following is not valid:\n     * @example\n     * const canvas = document.createElement('canvas')\n     * canvas.width = 200;\n     * canvas.height = 200;\n     *\n     * const ctx = canvas2.getContext('2d')!\n     * ctx.fillStyle = 'red'\n     * ctx.fillRect(0, 0, 200, 200);\n     *\n     * const texture = RenderTexture.create({\n     *   width: 200,\n     *   height: 200,\n     * })\n     * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n     *\n     * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n     *\n     * The best way to copy a canvas is to create a texture from it. Then render with that.\n     *\n     * Parsing in a RenderTarget canvas context (with a 2d context)\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (renderSurface.source instanceof CanvasSource)\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n", "import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n", "import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @category rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always true for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (colorTexture instanceof CanvasSource)\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\n/**\n * Data structure for GPU program layout.\n * Contains bind group layouts and pipeline layout.\n * @category rendering\n * @advanced\n */\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @category rendering\n * @advanced\n */\nexport class GpuShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n", "import type { BLEND_MODES } from '../../shared/state/const';\n\n/** @internal */\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.min = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n};\n\nGpuBlendModesToPixi.max = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @category rendering\n * @advanced\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     */\n    public getColorTargets(state: State): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        return [\n            {\n                format: 'bgra8unorm',\n                writeMask: 0,\n                blend,\n            },\n        ];\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n", "import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelHeight * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n", "import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n/** @internal */\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { warn } from '../../../../../utils/logging/warn';\n\nimport type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas | HTMLImageElement;\n\n        if (!resource) return;\n\n        // WebGPU does not support HTMLImageElement\n        // so we need to convert it to a canvas\n        if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        {\n            const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n            const context = canvas.getContext('2d');\n\n            context.drawImage(resource, 0, 0, resource.width, resource.height);\n\n            // replace with the canvas - for future uploads\n            source.resource = canvas;\n\n            // #if _DEBUG\n            warn('ImageSource: Image element passed, converting to canvas and replacing resource.');\n            // #endif\n        }\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n", "import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\n/** @internal */\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n", "/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @category rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * The system that handles textures for the GPU.\n * @category rendering\n * @advanced\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    protected CONTEXT_UID: number;\n    private _gpuSources: Record<number, GPUTexture> = Object.create(null);\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n    private _textureViewHash: Record<string, GPUTextureView> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuSources');\n        renderer.renderableGC.addManagedHash(this, '_gpuSamplers');\n        renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n        renderer.renderableGC.addManagedHash(this, '_textureViewHash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource): GPUTexture\n    {\n        if (this._gpuSources[source.uid])\n        {\n            return this._gpuSources[source.uid];\n        }\n\n        return this._initSource(source);\n    }\n\n    private _initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpuSources[source.uid] = this._gpu.device.createTexture(textureDescriptor);\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (gpuTexture)\n        {\n            this._gpuSources[source.uid] = null;\n\n            gpuTexture.destroy();\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n\n    /**\n     * this returns s bind group for a specific texture, the bind group contains\n     * - the texture source\n     * - the texture style\n     * - the texture matrix\n     * This is cached so the bind group should only be created once per texture\n     * @param texture - the texture you want the bindgroup for\n     * @returns the bind group for the texture\n     */\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: Texture)\n    {\n        const source = texture.source;\n\n        this._bindGroupHash[texture.uid] = new BindGroup({\n            0: source,\n            1: source.style,\n            2: new UniformGroup({\n                uTextureMatrix: { type: 'mat3x3<f32>', value: texture.textureMatrix.mapCoord },\n            })\n        });\n\n        return this._bindGroupHash[texture.uid];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n\n    private _createTextureView(texture: TextureSource)\n    {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n\n        return this._textureViewHash[texture.uid];\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the aarry with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuLimitsSystem } from './GpuLimitsSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuLimitsSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\n/**\n * The default WebGPU systems. These are the systems that are added by default to the WebGPURenderer.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\n/**\n * The WebGPU renderer pipes. These are used to render the scene.\n * @see {@link WebGPURenderer}\n * @internal\n */\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * import { autoDetectRenderer } from 'pixi.js';\n * // Create a new renderer\n * const renderer = await autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @standard\n * @property {GpuUboSystem} ubo - UboSystem instance.\n * @property {GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {GpuDeviceSystem} device - DeviceSystem instance.\n * @property {GpuBufferSystem} buffer - BufferSystem instance.\n * @property {GpuTextureSystem} texture - TextureSystem instance.\n * @property {GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GpuShaderSystem} shader - ShaderSystem instance.\n * @property {GpuStateSystem} state - StateSystem instance.\n * @property {PipelineSystem} pipeline - PipelineSystem instance.\n * @property {GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {GpuStencilSystem} stencil - StencilSystem instance.\n * @property {BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBitGl } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { type Renderer } from '../../../rendering/renderers/types';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses WebGL to render graphics.\n * @category rendering\n * @ignore\n */\nexport class GlGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public contextChange(renderer: Renderer): void\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = renderer.limits.maxBatchableTextures;\n\n        const glProgram = compileHighShaderGlProgram({\n            name: 'graphics',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this.shader = new Shader({\n            glProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGLRenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions,\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGL specific..\n        shader.groups[0] = renderer.globalUniforms.bindGroup;\n\n        renderer.state.set(graphicsPipe.state);\n\n        renderer.shader.bind(shader);\n\n        renderer.geometry.bind(batcher.geometry, shader.glProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.size)\n            {\n                for (let j = 0; j < batch.textures.count; j++)\n                {\n                    renderer.texture.bind(batch.textures.textures[j], j);\n                }\n\n                renderer.geometry.draw(batch.topology, batch.size, batch.start);\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGlProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBitGl } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * A MeshAdaptor that uses the WebGL to render meshes.\n * @category rendering\n * @ignore\n */\nexport class GlMeshAdaptor implements MeshAdaptor\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBitGl,\n                textureBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        this._shader = new Shader({\n            glProgram,\n            resources: {\n                uTexture: Texture.EMPTY.source,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh): void\n    {\n        const renderer = meshPipe.renderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            const texture = mesh.texture;\n            const source = texture.source;\n\n            shader.resources.uTexture = source;\n            shader.resources.uSampler = source.style;\n            shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;\n        }\n        else if (!shader.glProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no glProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        // setting the groups to be high to be compatible and not\n        // overlap any other groups\n        shader.groups[100] = renderer.globalUniforms.bindGroup;\n        shader.groups[101] = meshPipe.localUniformsBindGroup;\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state,\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\n\nimport type { WebGLRenderer } from '../../renderers/gl/WebGLRenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\n/**\n * A BatcherAdaptor that uses WebGL to render batches.\n * @category rendering\n * @ignore\n */\nexport class GlBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private readonly _tempState = State.for2d();\n\n    /**\n     * We only want to sync the a batched shaders uniforms once on first use\n     * this is a hash of shader uids to a boolean value.  When the shader is first bound\n     * we set the value to true.  When the shader is bound again we check the value and\n     * if it is true we know that the uniforms have already been synced and we skip it.\n     */\n    private _didUploadHash: Record<string, boolean> = {};\n    public init(batcherPipe: BatcherPipe): void\n    {\n        batcherPipe.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._didUploadHash = {};\n    }\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        const didUpload = this._didUploadHash[shader.uid];\n\n        // only want to sync the shade ron its first bind!\n        renderer.shader.bind(shader, didUpload);\n\n        if (!didUpload)\n        {\n            this._didUploadHash[shader.uid] = true;\n        }\n\n        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);\n\n        renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const renderer = batchPipe.renderer as WebGLRenderer;\n\n        this._tempState.blendMode = batch.blendMode;\n\n        renderer.state.set(this._tempState);\n\n        const textures = batch.textures.textures;\n\n        for (let i = 0; i < batch.textures.count; i++)\n        {\n            renderer.texture.bind(textures[i], i);\n        }\n\n        renderer.geometry.draw(batch.topology, batch.size, batch.start);\n    }\n}\n", "/**\n * Constants for various buffer types in Pixi\n * @category rendering\n * @advanced\n */\nexport enum BUFFER_TYPE\n{\n    /** buffer type for using as an index buffer */\n    ELEMENT_ARRAY_BUFFER = 34963,\n    /** buffer type for using attribute data */\n    ARRAY_BUFFER = 34962,\n    /** the buffer type is for uniform buffer objects */\n    UNIFORM_BUFFER = 35345,\n}\n\n", "import type { BUFFER_TYPE } from './const';\n\n/** @internal */\nexport class GlBuffer\n{\n    public buffer: WebGLBuffer;\n    public updateID: number;\n    public byteLength: number;\n    public type: number;\n\n    public _lastBindBaseLocation: number = -1;\n    public _lastBindCallId: number = -1;\n\n    constructor(buffer: WebGLBuffer, type: BUFFER_TYPE)\n    {\n        this.buffer = buffer || null;\n        this.updateID = -1;\n        this.byteLength = -1;\n        this.type = type;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { BufferUsage } from '../../shared/buffer/const';\nimport { BUFFER_TYPE } from './const';\nimport { GlBuffer } from './GlBuffer';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n *\n * WebGL uses Buffers as a way to store objects to the GPU.\n * This system makes working with them a lot easier.\n *\n * Buffers are used in three main places in WebGL\n * - geometry information\n * - Uniform information (via uniform buffer objects - a WebGL 2 only feature)\n * - Transform feedback information. (WebGL 2 only feature)\n *\n * This system will handle the binding of buffers to the GPU as well as uploading\n * them. With this system, you never need to work directly with GPU buffers, but instead work with\n * the Buffer class.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    private _gl: GlRenderingContext;\n    private _gpuBuffers: {[key: number]: GlBuffer} = Object.create(null);\n\n    /** Cache keeping track of the base bound buffer bases */\n    private _boundBufferBases: {[key: number]: GlBuffer} = Object.create(null);\n\n    private _renderer: WebGLRenderer;\n\n    private _minBaseLocation = 0;\n    private _maxBindings: number;\n    private _nextBindBaseIndex = this._minBaseLocation;\n    private _bindCallId = 0;\n\n    /**\n     * @param {Renderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    /** @ignore */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._gl = null;\n        this._gpuBuffers = null;\n        (this._boundBufferBases as null) = null;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        this._gl = this._renderer.gl;\n\n        this._gpuBuffers = Object.create(null);\n        this._maxBindings = this._renderer.limits.maxUniformBindings;\n    }\n\n    public getGlBuffer(buffer: Buffer): GlBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);\n    }\n\n    /**\n     * This binds specified buffer. On first run, it will create the webGL buffers for the context too\n     * @param buffer - the buffer to bind to the renderer\n     */\n    public bind(buffer: Buffer): void\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n    }\n\n    /**\n     * Binds an uniform buffer to at the given index.\n     *\n     * A cache is used so a buffer will not be bound again if already bound.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind it to.\n     */\n    public bindBufferBase(glBuffer: GlBuffer, index: number): void\n    {\n        const { _gl: gl } = this;\n\n        if (this._boundBufferBases[index] !== glBuffer)\n        {\n            this._boundBufferBases[index] = glBuffer;\n            glBuffer._lastBindBaseLocation = index;\n\n            gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);\n        }\n    }\n\n    public nextBindBase(hasTransformFeedback: boolean)\n    {\n        this._bindCallId++;\n        this._minBaseLocation = 0;\n        if (hasTransformFeedback)\n        {\n            this._boundBufferBases[0] = null;\n            this._minBaseLocation = 1;\n            if (this._nextBindBaseIndex < 1)\n            {\n                this._nextBindBaseIndex = 1;\n            }\n        }\n    }\n\n    public freeLocationForBufferBase(glBuffer: GlBuffer): number\n    {\n        let freeIndex = this.getLastBindBaseLocation(glBuffer);\n\n        // check if it is already bound..\n        if (freeIndex >= this._minBaseLocation)\n        {\n            glBuffer._lastBindCallId = this._bindCallId;\n\n            return freeIndex;\n        }\n\n        let loop = 0;\n        let nextIndex = this._nextBindBaseIndex;\n\n        while (loop < 2)\n        {\n            if (nextIndex >= this._maxBindings)\n            {\n                nextIndex = this._minBaseLocation;\n                loop++;\n            }\n\n            const curBuf = this._boundBufferBases[nextIndex];\n\n            if (curBuf && curBuf._lastBindCallId === this._bindCallId)\n            {\n                nextIndex++;\n                continue;\n            }\n            break;\n        }\n\n        freeIndex = nextIndex;\n        this._nextBindBaseIndex = nextIndex + 1;\n\n        if (loop >= 2)\n        {\n            // TODO: error\n            return -1;\n        }\n\n        glBuffer._lastBindCallId = this._bindCallId;\n        this._boundBufferBases[freeIndex] = null;\n\n        return freeIndex;\n    }\n\n    public getLastBindBaseLocation(glBuffer: GlBuffer): number\n    {\n        const index = glBuffer._lastBindBaseLocation;\n\n        if (this._boundBufferBases[index] === glBuffer)\n        {\n            return index;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Binds a buffer whilst also binding its range.\n     * This will make the buffer start from the offset supplied rather than 0 when it is read.\n     * @param glBuffer - the buffer to bind\n     * @param index - the base index to bind at, defaults to 0\n     * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc\n     * @param size - the size to bind at (this is blocks of 256).\n     */\n    public bindBufferRange(glBuffer: GlBuffer, index?: number, offset?: number, size?: number): void\n    {\n        const { _gl: gl } = this;\n\n        offset ||= 0;\n        index ||= 0;\n\n        this._boundBufferBases[index] = null;\n\n        gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, offset * 256, size || 256);\n    }\n\n    /**\n     * Will ensure the data in the buffer is uploaded to the GPU.\n     * @param {Buffer} buffer - the buffer to update\n     */\n    public updateBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        const glBuffer = this.getGlBuffer(buffer);\n\n        if (buffer._updateID === glBuffer.updateID)\n        {\n            return glBuffer;\n        }\n\n        glBuffer.updateID = buffer._updateID;\n\n        gl.bindBuffer(glBuffer.type, glBuffer.buffer);\n\n        const data = buffer.data;\n\n        const drawType = (buffer.descriptor.usage & BufferUsage.STATIC) ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;\n\n        if (data)\n        {\n            if (glBuffer.byteLength >= data.byteLength)\n            {\n                // assuming our buffers are aligned to 4 bits...\n                // offset is always zero for now!\n                gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);\n            }\n            else\n            {\n                glBuffer.byteLength = data.byteLength;\n                // assuming our buffers are aligned to 4 bits...\n                gl.bufferData(glBuffer.type, data, drawType);\n            }\n        }\n        else\n        {\n            glBuffer.byteLength = buffer.descriptor.size;\n            gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType);\n        }\n\n        return glBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        const gl = this._gl;\n\n        for (const id in this._gpuBuffers)\n        {\n            gl.deleteBuffer(this._gpuBuffers[id].buffer);\n        }\n\n        this._gpuBuffers = Object.create(null);\n    }\n\n    /**\n     * Disposes buffer\n     * @param {Buffer} buffer - buffer with data\n     * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onBufferDestroy(buffer: Buffer, contextLost?: boolean): void\n    {\n        const glBuffer = this._gpuBuffers[buffer.uid];\n\n        const gl = this._gl;\n\n        if (!contextLost)\n        {\n            gl.deleteBuffer(glBuffer.buffer);\n        }\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n\n    /**\n     * creates and attaches a GLBuffer object tied to the current context.\n     * @param buffer\n     * @protected\n     */\n    protected createGLBuffer(buffer: Buffer): GlBuffer\n    {\n        const { _gl: gl } = this;\n\n        let type = BUFFER_TYPE.ARRAY_BUFFER;\n\n        if ((buffer.descriptor.usage & BufferUsage.INDEX))\n        {\n            type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;\n        }\n        else if ((buffer.descriptor.usage & BufferUsage.UNIFORM))\n        {\n            type = BUFFER_TYPE.UNIFORM_BUFFER;\n        }\n\n        const glBuffer = new GlBuffer(gl.createBuffer(), type);\n\n        this._gpuBuffers[buffer.uid] = glBuffer;\n\n        buffer.on('destroy', this.onBufferDestroy, this);\n\n        return glBuffer;\n    }\n\n    public resetState(): void\n    {\n        this._boundBufferBases = Object.create(null);\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { type GpuPowerPreference } from '../../types';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { WebGLExtensions } from './WebGLExtensions';\n\n/**\n * Options for the context system.\n * @category rendering\n * @advanced\n * @property {WebGL2RenderingContext | null} [context=null] - User-provided WebGL rendering context object.\n * @property {GpuPowerPreference} [powerPreference='default'] - An optional hint indicating what configuration\n * of GPU is suitable for the WebGL context, can be `'high-performance'` or `'low-power'`. Setting to `'high-performance'`\n * will prioritize rendering performance over power consumption, while setting to `'low-power'` will prioritize power saving\n * over rendering performance.\n * @property {boolean} [premultipliedAlpha=true] - Whether the compositor will assume the drawing buffer contains\n * colors with premultiplied alpha.\n * @property {boolean} [preserveDrawingBuffer=false] - Whether to enable drawing buffer preservation.\n * If enabled, the drawing buffer will preserve\n * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n * @property {boolean} [antialias] - Whether to enable antialiasing.\n * @property {1 | 2} [preferWebGLVersion=2] - The preferred WebGL version to use.\n */\nexport interface ContextSystemOptions\n{\n    /**\n     * User-provided WebGL rendering context object.\n     * @default null\n     */\n    context: WebGL2RenderingContext | null;\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGL context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     */\n    powerPreference?: GpuPowerPreference;\n\n    /**\n     * Whether the compositor will assume the drawing buffer contains colors with premultiplied alpha.\n     * @default true\n     */\n    premultipliedAlpha: boolean;\n    /**\n     * Whether to enable drawing buffer preservation. If enabled, the drawing buffer will preserve\n     * its value until cleared or overwritten. Enable this if you need to call `toDataUrl` on the WebGL context.\n     * @default false\n     */\n    preserveDrawingBuffer: boolean;\n\n    antialias?: boolean;\n\n    /**\n     * The preferred WebGL version to use.\n     * @default 2\n     */\n    preferWebGLVersion?: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    multiView: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context\n * @category rendering\n * @advanced\n */\nexport class GlContextSystem implements System<ContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'context',\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: ContextSystemOptions = {\n        /**\n         * {@link WebGLOptions.context}\n         * @default null\n         */\n        context: null,\n        /**\n         * {@link WebGLOptions.premultipliedAlpha}\n         * @default true\n         */\n        premultipliedAlpha: true,\n        /**\n         * {@link WebGLOptions.preserveDrawingBuffer}\n         * @default false\n         */\n        preserveDrawingBuffer: false,\n        /**\n         * {@link WebGLOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * {@link WebGLOptions.webGLVersion}\n         * @default 2\n         */\n        preferWebGLVersion: 2,\n        /**\n         * {@link WebGLOptions.multiView}\n         * @default false\n         */\n        multiView: false\n    };\n\n    protected CONTEXT_UID: number;\n    protected gl: WebGL2RenderingContext;\n\n    /**\n     * Features supported by current renderer.\n     * @type {object}\n     * @readonly\n     */\n    public supports = {\n        /** Support for 32-bit indices buffer. */\n        uint32Indices: true,\n        /** Support for UniformBufferObjects */\n        uniformBufferObject: true,\n        /** Support for VertexArrayObjects */\n        vertexArrayObject: true,\n        /** Support for SRGB texture format */\n        srgbTextures: true,\n        /** Support for wrapping modes if a texture is non-power of two */\n        nonPowOf2wrapping: true,\n        /** Support for MSAA (antialiasing of dynamic textures) */\n        msaa: true,\n        /** Support for mipmaps if a texture is non-power of two */\n        nonPowOf2mipmaps: true,\n    };\n\n    /**\n     * Extensions available.\n     * @type {object}\n     * @readonly\n     * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension\n     * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension\n     * @property {OES_texture_float} floatTexture - WebGL v1 extension\n     * @property {WEBGL_lose_context} loseContext - WebGL v1 extension\n     * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension\n     * @property {EXT_texture_filter_anisotropic} anisotropicFiltering - WebGL v1 and v2 extension\n     */\n    public extensions: WebGLExtensions;\n\n    public webGLVersion: 1 | 2;\n\n    /**\n     * Whether to enable multi-view rendering. Set to true when rendering to multiple\n     * canvases on the dom.\n     * @default false\n     */\n    public multiView: boolean;\n\n    /**\n     * The canvas that the WebGL Context is rendering to.\n     * This will be the view canvas. But if multiView is enabled, this canvas will not be attached to the DOM.\n     * It will be rendered to and then copied to the target canvas.\n     * @readonly\n     */\n    public canvas: ICanvas;\n\n    private _renderer: WebGLRenderer;\n    private _contextLossForced: boolean;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.extensions = Object.create(null);\n\n        // Bind functions\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n    }\n\n    /**\n     * `true` if the context is lost\n     * @readonly\n     */\n    get isLost(): boolean\n    {\n        return (!this.gl || this.gl.isContextLost());\n    }\n\n    /**\n     * Handles the context change event.\n     * @param {WebGLRenderingContext} gl - New WebGL context.\n     */\n    protected contextChange(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n        this._renderer.gl = gl;\n    }\n\n    public init(options: ContextSystemOptions): void\n    {\n        options = { ...GlContextSystem.defaultOptions, ...options };\n\n        // TODO add to options\n        let multiView = this.multiView = options.multiView;\n\n        if (options.context && multiView)\n        {\n            // eslint-disable-next-line max-len\n            warn('Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together.');\n\n            multiView = false;\n        }\n\n        if (multiView)\n        {\n            this.canvas = DOMAdapter.get()\n                .createCanvas(this._renderer.canvas.width, this._renderer.canvas.height);\n        }\n        else\n        {\n            this.canvas = this._renderer.view.canvas;\n        }\n        /*\n         * The options passed in to create a new WebGL context.\n         */\n        if (options.context)\n        {\n            this.initFromContext(options.context);\n        }\n        else\n        {\n            const alpha = this._renderer.background.alpha < 1;\n            const premultipliedAlpha = options.premultipliedAlpha ?? true;\n            const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;\n\n            this.createContext(options.preferWebGLVersion, {\n                alpha,\n                premultipliedAlpha,\n                antialias,\n                stencil: true,\n                preserveDrawingBuffer: options.preserveDrawingBuffer,\n                powerPreference: options.powerPreference ?? 'default',\n            });\n        }\n    }\n\n    public ensureCanvasSize(targetCanvas: ICanvas): void\n    {\n        if (!this.multiView)\n        {\n            if (targetCanvas !== this.canvas)\n            {\n                warn('multiView is disabled, but targetCanvas is not the main canvas');\n            }\n\n            return;\n        }\n\n        const { canvas } = this;\n\n        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height)\n        {\n            canvas.width = Math.max(targetCanvas.width, targetCanvas.width);\n            canvas.height = Math.max(targetCanvas.height, targetCanvas.height);\n        }\n    }\n\n    /**\n     * Initializes the context.\n     * @protected\n     * @param {WebGLRenderingContext} gl - WebGL context\n     */\n    protected initFromContext(gl: WebGL2RenderingContext): void\n    {\n        this.gl = gl;\n\n        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;\n\n        this.getExtensions();\n\n        this.validateContext(gl);\n\n        this._renderer.runners.contextChange.emit(gl);\n\n        const element = this._renderer.view.canvas;\n\n        (element as any).addEventListener('webglcontextlost', this.handleContextLost, false);\n        element.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n    }\n\n    /**\n     * Initialize from context options\n     * @protected\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext\n     * @param preferWebGLVersion\n     * @param {object} options - context attributes\n     */\n    protected createContext(preferWebGLVersion: 1 | 2, options: WebGLContextAttributes): void\n    {\n        let gl: WebGL2RenderingContext | WebGLRenderingContext;\n\n        const canvas = this.canvas;\n\n        if (preferWebGLVersion === 2)\n        {\n            gl = canvas.getContext('webgl2', options);\n        }\n\n        if (!gl)\n        {\n            gl = canvas.getContext('webgl', options);\n\n            if (!gl)\n            {\n                // fail, not able to get a context\n                throw new Error('This browser does not support WebGL. Try using the canvas renderer');\n            }\n        }\n\n        this.gl = gl as WebGL2RenderingContext;\n\n        this.initFromContext(this.gl);\n    }\n\n    /** Auto-populate the {@link GlContextSystem.extensions extensions}. */\n    protected getExtensions(): void\n    {\n        // time to set up default extensions that Pixi uses.\n        const { gl } = this;\n\n        const common = {\n            anisotropicFiltering: gl.getExtension('EXT_texture_filter_anisotropic'),\n            floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n\n            s3tc: gl.getExtension('WEBGL_compressed_texture_s3tc'),\n            s3tc_sRGB: gl.getExtension('WEBGL_compressed_texture_s3tc_srgb'), // eslint-disable-line camelcase\n            etc: gl.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.getExtension('WEBGL_compressed_texture_etc1'),\n            pvrtc: gl.getExtension('WEBGL_compressed_texture_pvrtc')\n                || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            atc: gl.getExtension('WEBGL_compressed_texture_atc'),\n            astc: gl.getExtension('WEBGL_compressed_texture_astc'),\n            bptc: gl.getExtension('EXT_texture_compression_bptc'),\n            rgtc: gl.getExtension('EXT_texture_compression_rgtc'),\n            loseContext: gl.getExtension('WEBGL_lose_context'),\n        };\n\n        if (this.webGLVersion === 1)\n        {\n            this.extensions = {\n                ...common,\n\n                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),\n                depthTexture: gl.getExtension('WEBGL_depth_texture'),\n                vertexArrayObject: gl.getExtension('OES_vertex_array_object')\n                    || gl.getExtension('MOZ_OES_vertex_array_object')\n                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),\n                uint32ElementIndex: gl.getExtension('OES_element_index_uint'),\n                // Floats and half-floats\n                floatTexture: gl.getExtension('OES_texture_float'),\n                floatTextureLinear: gl.getExtension('OES_texture_float_linear'),\n                textureHalfFloat: gl.getExtension('OES_texture_half_float'),\n                textureHalfFloatLinear: gl.getExtension('OES_texture_half_float_linear'),\n                vertexAttribDivisorANGLE: gl.getExtension('ANGLE_instanced_arrays'),\n                srgb: gl.getExtension('EXT_sRGB'),\n            };\n        }\n        else\n        {\n            this.extensions = {\n                ...common,\n                colorBufferFloat: gl.getExtension('EXT_color_buffer_float'),\n            };\n\n            const provokeExt = gl.getExtension('WEBGL_provoking_vertex');\n\n            if (provokeExt)\n            {\n                provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);\n            }\n        }\n    }\n\n    /**\n     * Handles a lost webgl context\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    protected handleContextLost(event: WebGLContextEvent): void\n    {\n        event.preventDefault();\n\n        // only restore if we purposefully nuked it\n        if (this._contextLossForced)\n        {\n            this._contextLossForced = false;\n            // Restore the context after this event has exited\n            setTimeout(() =>\n            {\n                if (this.gl.isContextLost())\n                {\n                    this.extensions.loseContext?.restoreContext();\n                }\n            }, 0);\n        }\n    }\n\n    /** Handles a restored webgl context. */\n    protected handleContextRestored(): void\n    {\n        this.getExtensions(); // restore extensions state\n        this._renderer.runners.contextChange.emit(this.gl);\n    }\n\n    public destroy(): void\n    {\n        const element = this._renderer.view.canvas;\n\n        this._renderer = null;\n\n        // remove listeners\n        (element as any).removeEventListener('webglcontextlost', this.handleContextLost);\n        element.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.gl.useProgram(null);\n\n        this.extensions.loseContext?.loseContext();\n    }\n\n    /**\n     * this function can be called to force a webGL context loss\n     * this will release all resources on the GPU.\n     * Useful if you need to put Pixi to sleep, and save some GPU memory\n     *\n     * As soon as render is called - all resources will be created again.\n     */\n    public forceContextLoss(): void\n    {\n        this.extensions.loseContext?.loseContext();\n        this._contextLossForced = true;\n    }\n    /**\n     * Validate context.\n     * @param {WebGLRenderingContext} gl - Render context.\n     */\n    protected validateContext(gl: WebGL2RenderingContext): void\n    {\n        const attributes = gl.getContextAttributes();\n\n        // this is going to be fairly simple for now.. but at least we have room to grow!\n        if (attributes && !attributes.stencil)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');\n            // #endif\n        }\n\n        // support\n        const supports = this.supports;\n\n        const isWebGl2 = this.webGLVersion === 2;\n        const extensions = this.extensions;\n\n        supports.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;\n        supports.uniformBufferObject = isWebGl2;\n        supports.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;\n        supports.srgbTextures = isWebGl2 || !!extensions.srgb;\n        supports.nonPowOf2wrapping = isWebGl2;\n        supports.nonPowOf2mipmaps = isWebGl2;\n        supports.msaa = isWebGl2;\n\n        if (!supports.uint32Indices)\n        {\n            // #if _DEBUG\n            warn('Provided WebGL context does not support 32 index buffer, large scenes may not render correctly');\n            // #endif\n        }\n    }\n}\n", "/**\n * Various GL texture/resources formats.\n * @category rendering\n * @advanced\n */\nexport enum GL_FORMATS\n{\n    RGBA = 6408,\n    RGB = 6407,\n    RG = 33319,\n    RED = 6403,\n    RGBA_INTEGER = 36249,\n    RGB_INTEGER = 36248,\n    RG_INTEGER = 33320,\n    RED_INTEGER = 36244,\n    ALPHA = 6406,\n    LUMINANCE = 6409,\n    LUMINANCE_ALPHA = 6410,\n    DEPTH_COMPONENT = 6402,\n    DEPTH_STENCIL = 34041,\n}\n\n/**\n * Various GL target types.\n * @category rendering\n * @advanced\n */\nexport enum GL_TARGETS\n{\n    TEXTURE_2D = 3553,\n    TEXTURE_CUBE_MAP = 34067,\n    TEXTURE_2D_ARRAY = 35866,\n    TEXTURE_CUBE_MAP_POSITIVE_X = 34069,\n    TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,\n    TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,\n    TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,\n    TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,\n    TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,\n}\n\n/**\n * The wrap modes that are supported by pixi.\n *\n * The {@link WRAP_MODE} wrap mode affects the default wrapping mode of future operations.\n * It can be re-assigned to either CLAMP or REPEAT, depending upon suitability.\n * If the texture is non power of two then clamp will be used regardless as WebGL can\n * only use REPEAT if the texture is po2.\n *\n * This property only affects WebGL.\n * @category rendering\n * @advanced\n */\nexport enum GL_WRAP_MODES\n{\n    /**\n     * The textures uvs are clamped\n     * @default 33071\n     */\n    CLAMP = 33071,\n    /**\n     * The texture uvs tile and repeat\n     * @default 10497\n     */\n    REPEAT = 10497,\n    /**\n     * The texture uvs tile and repeat with mirroring\n     * @default 33648\n     */\n    MIRRORED_REPEAT = 33648,\n}\n\n/** @internal */\nexport enum GL_TYPES\n{\n    /**\n     * 8 bits per channel for gl.RGBA\n     * @default 5121\n     */\n    UNSIGNED_BYTE = 5121,\n    /** @default 5123 */\n    UNSIGNED_SHORT = 5123,\n    /**\n     * 5 red bits, 6 green bits, 5 blue bits.\n     * @default 33635\n     */\n    UNSIGNED_SHORT_5_6_5 = 33635,\n    /**\n     * 4 red bits, 4 green bits, 4 blue bits, 4 alpha bits.\n     * @default 32819\n     */\n    UNSIGNED_SHORT_4_4_4_4 = 32819,\n    /**\n     * 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.\n     * @default 32820\n     */\n    UNSIGNED_SHORT_5_5_5_1 = 32820,\n    /** @default 5125 */\n    UNSIGNED_INT = 5125,\n    /** @default 35899 */\n    UNSIGNED_INT_10F_11F_11F_REV = 35899,\n    /** @default 33640 */\n    UNSIGNED_INT_2_10_10_10_REV = 33640,\n    /** @default 34042 */\n    UNSIGNED_INT_24_8 = 34042,\n    /** @default 35902 */\n    UNSIGNED_INT_5_9_9_9_REV = 35902,\n    /** @default 5120 */\n    BYTE = 5120,\n    /** @default 5122 */\n    SHORT = 5122,\n    /** @default 5124 */\n    INT = 5124,\n    /** @default 5126 */\n    FLOAT = 5126,\n    /** @default 36269 */\n    FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,\n    /** @default 36193 */\n    HALF_FLOAT = 36193,\n}\n\n", "import { GL_TYPES } from '../../texture/const';\n\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nconst infoMap = {\n    uint8x2: GL_TYPES.UNSIGNED_BYTE,\n    uint8x4: GL_TYPES.UNSIGNED_BYTE,\n    sint8x2: GL_TYPES.BYTE,\n    sint8x4: GL_TYPES.BYTE,\n    unorm8x2: GL_TYPES.UNSIGNED_BYTE,\n    unorm8x4: GL_TYPES.UNSIGNED_BYTE,\n    snorm8x2: GL_TYPES.BYTE,\n    snorm8x4: GL_TYPES.BYTE,\n    uint16x2: GL_TYPES.UNSIGNED_SHORT,\n    uint16x4: GL_TYPES.UNSIGNED_SHORT,\n    sint16x2: GL_TYPES.SHORT,\n    sint16x4: GL_TYPES.SHORT,\n    unorm16x2: GL_TYPES.UNSIGNED_SHORT,\n    unorm16x4: GL_TYPES.UNSIGNED_SHORT,\n    snorm16x2: GL_TYPES.SHORT,\n    snorm16x4: GL_TYPES.SHORT,\n    float16x2: GL_TYPES.HALF_FLOAT,\n    float16x4: GL_TYPES.HALF_FLOAT,\n    float32: GL_TYPES.FLOAT,\n    float32x2: GL_TYPES.FLOAT,\n    float32x3: GL_TYPES.FLOAT,\n    float32x4: GL_TYPES.FLOAT,\n    uint32: GL_TYPES.UNSIGNED_INT,\n    uint32x2: GL_TYPES.UNSIGNED_INT,\n    uint32x3: GL_TYPES.UNSIGNED_INT,\n    uint32x4: GL_TYPES.UNSIGNED_INT,\n    sint32: GL_TYPES.INT,\n    sint32x2: GL_TYPES.INT,\n    sint32x3: GL_TYPES.INT,\n    sint32x4: GL_TYPES.INT\n};\n\n/**\n * @param format\n * @internal\n */\nexport function getGlTypeFromFormat(format: VertexFormat): number\n{\n    return infoMap[format] ?? infoMap.float32;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @category rendering\n * @advanced\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = Object.create(null);\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n\n        this._renderer.renderableGC.addManagedHash(this, '_geometryVaoHash');\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = Object.create(null);\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader ||= this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public resetState(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = Object.create(null);\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n            const programAttrib = program._attributeData[j];\n\n            if (programAttrib)\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = programAttrib.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                const type = getGlTypeFromFormat(attribute.format);\n\n                if (programAttrib.format?.substring(1, 4) === 'int')\n                {\n                    gl.vertexAttribIPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attribute.stride,\n                        attribute.offset);\n                }\n                else\n                {\n                    gl.vertexAttribPointer(location,\n                        attributeInfo.size,\n                        type,\n                        attributeInfo.normalised,\n                        attribute.stride,\n                        attribute.offset);\n                }\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        // Can't use truthiness check to determine if divisor is set,\n                        // since 0 is a valid value for divisor\n                        const divisor = attribute.divisor ?? 1;\n\n                        gl.vertexAttribDivisor(location, divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     * @returns This instance of the geometry system.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[topology || geometry.topology];\n\n        instanceCount ??= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount !== 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n            }\n        }\n        else if (instanceCount !== 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n        this._geometryVaoHash = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { Geometry } from '../shared/geometry/Geometry';\nimport { Shader } from '../shared/shader/Shader';\nimport { State } from '../shared/state/State';\nimport { TextureSource } from '../shared/texture/sources/TextureSource';\nimport { Texture } from '../shared/texture/Texture';\nimport { GlProgram } from './shader/GlProgram';\n\nimport type { RenderOptions } from '../shared/system/AbstractRenderer';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\nconst bigTriangleGeometry = new Geometry({\n    attributes: {\n        aPosition: [\n            -1.0, -1.0, // Bottom left corner\n            3.0, -1.0, // Bottom right corner, extending beyond right edge\n            -1.0, 3.0 // Top left corner, extending beyond top edge\n        ],\n    },\n});\n\n/**\n * The options for the back buffer system.\n * @category rendering\n * @property {boolean} [useBackBuffer=false] - if true will use the back buffer where required\n * @property {boolean} [antialias=false] - if true will ensure the texture is antialiased\n * @advanced\n */\nexport interface GlBackBufferOptions\n{\n    /**\n     * if true will use the back buffer where required\n     * @default false\n     */\n    useBackBuffer?: boolean;\n    /** if true will ensure the texture is antialiased */\n    antialias?: boolean;\n}\n\n/**\n * For blend modes you need to know what pixels you are actually drawing to. For this to be possible in WebGL\n * we need to render to a texture and then present that texture to the screen. This system manages that process.\n *\n * As the main scene is rendered to a texture, it means we can sample it and copy its pixels,\n * something not possible on the main canvas.\n *\n * If antialiasing is set to to true and useBackBuffer is set to true, then the back buffer will be antialiased.\n * and the main gl context will not.\n *\n * You only need to activate this back buffer if you are using a blend mode that requires it.\n *\n * to activate is simple, you pass `useBackBuffer:true` to your render options\n * @category rendering\n * @advanced\n */\nexport class GlBackBufferSystem implements System<GlBackBufferOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'backBuffer',\n        priority: 1\n    } as const;\n\n    /** default options for the back buffer system */\n    public static defaultOptions: GlBackBufferOptions = {\n        /** if true will use the back buffer where required */\n        useBackBuffer: false,\n    };\n\n    /** if true, the back buffer is used */\n    public useBackBuffer = false;\n\n    private _backBufferTexture: Texture;\n    private readonly _renderer: WebGLRenderer;\n    private _targetTexture: TextureSource;\n    private _useBackBufferThisRender = false;\n    private _antialias: boolean;\n    private _state: State;\n    private _bigTriangleShader: Shader;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public init(options: GlBackBufferOptions = {})\n    {\n        const { useBackBuffer, antialias } = { ...GlBackBufferSystem.defaultOptions, ...options };\n\n        this.useBackBuffer = useBackBuffer;\n\n        this._antialias = antialias;\n\n        if (!this._renderer.context.supports.msaa)\n        {\n            warn('antialiasing, is not supported on when using the back buffer');\n\n            this._antialias = false;\n        }\n\n        this._state = State.for2d();\n\n        const bigTriangleProgram = new GlProgram({\n            vertex: `\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }`,\n            fragment: `\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }`,\n            name: 'big-triangle',\n        });\n\n        this._bigTriangleShader = new Shader({\n            glProgram: bigTriangleProgram,\n            resources: {\n                uTexture: Texture.WHITE.source,\n            },\n        });\n    }\n\n    /**\n     * This is called before the RenderTargetSystem is started. This is where\n     * we replace the target with the back buffer if required.\n     * @param options - The options for this render.\n     */\n    protected renderStart(options: RenderOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;\n\n        if (this._useBackBufferThisRender)\n        {\n            const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);\n\n            this._targetTexture = renderTarget.colorTexture;\n\n            options.target = this._getBackBufferTexture(renderTarget.colorTexture);\n        }\n    }\n\n    protected renderEnd()\n    {\n        this._presentBackBuffer();\n    }\n\n    private _presentBackBuffer()\n    {\n        const renderer = this._renderer;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (!this._useBackBufferThisRender) return;\n\n        renderer.renderTarget.bind(this._targetTexture, false);\n\n        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;\n\n        renderer.encoder.draw({\n            geometry: bigTriangleGeometry,\n            shader: this._bigTriangleShader,\n            state: this._state,\n        });\n    }\n\n    private _getBackBufferTexture(targetSourceTexture: TextureSource)\n    {\n        this._backBufferTexture = this._backBufferTexture || new Texture({\n            source: new TextureSource({\n                width: targetSourceTexture.width,\n                height: targetSourceTexture.height,\n                resolution: targetSourceTexture._resolution,\n                antialias: this._antialias,\n            }),\n        });\n\n        // this will not resize if its the same size already! No extra check required\n        this._backBufferTexture.source.resize(\n            targetSourceTexture.width,\n            targetSourceTexture.height,\n            targetSourceTexture._resolution,\n        );\n\n        return this._backBufferTexture;\n    }\n\n    /** destroys the back buffer */\n    public destroy()\n    {\n        if (this._backBufferTexture)\n        {\n            this._backBufferTexture.destroy();\n            this._backBufferTexture = null;\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles color masking for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGLRenderer;\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.gl.colorMask(\n            !!(colorMask & 0b1000),\n            !!(colorMask & 0b0100),\n            !!(colorMask & 0b0010),\n            !!(colorMask & 0b0001)\n        );\n    }\n\n    public destroy?: () => void;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * The system that handles encoding commands for the WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'encoder',\n    } as const;\n\n    public readonly commandFinished = Promise.resolve();\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setGeometry(geometry: Geometry, shader?: Shader)\n    {\n        this._renderer.geometry.bind(geometry, shader.glProgram);\n    }\n\n    public finishRenderPass()\n    {\n        // noop\n    }\n\n    public draw(options: {\n        geometry: Geometry,\n        shader: Shader,\n        state?: State,\n        topology?: Topology,\n        size?: number,\n        start?: number,\n        instanceCount?: number\n        skipSync?: boolean,\n    })\n    {\n        const renderer = this._renderer;\n        const { geometry, shader, state, skipSync, topology: type, size, start, instanceCount } = options;\n\n        renderer.shader.bind(shader, skipSync);\n\n        renderer.geometry.bind(geometry, renderer.shader._activeProgram);\n\n        if (state)\n        {\n            renderer.state.set(state);\n        }\n\n        renderer.geometry.draw(type, size, start, instanceCount ?? geometry.instanceCount);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { checkMaxIfStatementsInShader } from '../../batcher/gl/utils/checkMaxIfStatementsInShader';\nimport { type System } from '../shared/system/System';\n\nimport type { WebGLRenderer } from './WebGLRenderer';\n/**\n * The GpuLimitsSystem provides information about the capabilities and limitations of the underlying GPU.\n * These limits, such as the maximum number of textures that can be used in a shader\n * (`maxTextures`) or the maximum number of textures that can be batched together (`maxBatchableTextures`),\n * are determined by the specific graphics hardware and driver.\n *\n * The values for these limits are not available immediately upon instantiation of the class.\n * They are populated when the GL rendering context is successfully initialized and ready,\n * which occurs after the `renderer.init()` method has completed.\n * Attempting to access these properties before the context is ready will result in undefined or default values.\n *\n * This system allows the renderer to adapt its behavior and resource allocation strategies\n * to stay within the supported boundaries of the GPU, ensuring optimal performance and stability.\n * @example\n * ```ts\n * const renderer = new WebGlRenderer();\n * await renderer.init();\n *\n * console.log(renderer.limits.maxTextures);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GlLimitsSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'limits',\n    } as const;\n\n    /** The maximum number of textures that can be used by a shader */\n    public maxTextures: number;\n    /** The maximum number of batchable textures */\n    public maxBatchableTextures: number;\n\n    /** The maximum number of uniform bindings */\n    public maxUniformBindings: number;\n\n    private readonly _renderer: WebGLRenderer;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public contextChange(): void\n    {\n        const gl = this._renderer.gl;\n\n        // step 1: first check max textures the GPU can handle.\n        this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        // step 2: check the maximum number of if statements the shader can have too..\n        this.maxBatchableTextures = checkMaxIfStatementsInShader(this.maxTextures, gl);\n\n        // step 3: check the limit of uniform buffer bindings.\n        // UBs are available only in WebGL2 context, requesting within WebGL1 produces a warning.\n        const isWebGl2 = this._renderer.context.webGLVersion === 2;\n\n        this.maxUniformBindings = isWebGl2\n            ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS)\n            : 0;\n    }\n\n    public destroy(): void\n    {\n        // boom!\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuStencilModesToPixi } from '../gpu/state/GpuStencilModesToPixi';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGLRenderer } from './WebGLRenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @category rendering\n * @advanced\n */\nexport class GlStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private _gl: WebGLRenderingContext;\n\n    private readonly _stencilCache = {\n        enabled: false,\n        stencilReference: 0,\n        stencilMode: STENCIL_MODES.NONE,\n    };\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _stencilOpsMapping: {\n        keep: number;\n        zero: number;\n        replace: number;\n        invert: number;\n        'increment-clamp': number;\n        'decrement-clamp': number;\n        'increment-wrap': number;\n        'decrement-wrap': number;\n    };\n\n    private _comparisonFuncMapping: {\n        always: number;\n        never: number;\n        equal: number;\n        'not-equal': number;\n        less: number;\n        'less-equal': number;\n        greater: number;\n        'greater-equal': number;\n    };\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected contextChange(gl: WebGLRenderingContext)\n    {\n        // TODO - this could be declared in a gl const\n        // we know the numbers don't tend to change!\n        this._gl = gl;\n\n        this._comparisonFuncMapping = {\n            always: gl.ALWAYS,\n            never: gl.NEVER,\n            equal: gl.EQUAL,\n            'not-equal': gl.NOTEQUAL,\n            less: gl.LESS,\n            'less-equal': gl.LEQUAL,\n            greater: gl.GREATER,\n            'greater-equal': gl.GEQUAL,\n        };\n\n        this._stencilOpsMapping = {\n            keep: gl.KEEP,\n            zero: gl.ZERO,\n            replace: gl.REPLACE,\n            invert: gl.INVERT,\n            'increment-clamp': gl.INCR,\n            'decrement-clamp': gl.DECR,\n            'increment-wrap': gl.INCR_WRAP,\n            'decrement-wrap': gl.DECR_WRAP,\n        };\n\n        this.resetState();\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        if (this._activeRenderTarget === renderTarget) return;\n\n        this._activeRenderTarget = renderTarget;\n\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        // restore the current render targets stencil state..\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public resetState()\n    {\n        // reset stencil cache\n        this._stencilCache.enabled = false;\n        this._stencilCache.stencilMode = STENCIL_MODES.NONE;\n        this._stencilCache.stencilReference = 0;\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        const gl = this._gl;\n        const mode = GpuStencilModesToPixi[stencilMode];\n\n        const _stencilCache = this._stencilCache;\n\n        // store the stencil state for restoration later, if a render target changes\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        if (stencilMode === STENCIL_MODES.DISABLED)\n        {\n            if (this._stencilCache.enabled)\n            {\n                this._stencilCache.enabled = false;\n\n                gl.disable(gl.STENCIL_TEST);\n            }\n\n            return;\n        }\n\n        if (!this._stencilCache.enabled)\n        {\n            this._stencilCache.enabled = true;\n            gl.enable(gl.STENCIL_TEST);\n        }\n\n        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference)\n        {\n            _stencilCache.stencilMode = stencilMode;\n            _stencilCache.stencilReference = stencilReference;\n\n            // this is pretty simple mapping.\n            // will work for pixi's simple mask cases.\n            // although a true mapping of the GPU state to webGL state should be done\n            gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 0xFF);\n            gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);\n        }\n    }\n\n    public destroy?: () => void;\n}\n", "import type { UboElement, UboLayout, UniformData } from '../../../shared/shader/types';\n\n/** @internal */\nexport const WGSL_TO_STD40_SIZE: Record<string, number> = {\n    f32: 4,\n    i32: 4,\n    'vec2<f32>': 8,\n    'vec3<f32>': 12,\n    'vec4<f32>': 16,\n\n    'vec2<i32>': 8,\n    'vec3<i32>': 12,\n    'vec4<i32>': 16,\n\n    'mat2x2<f32>': 16 * 2,\n    'mat3x3<f32>': 16 * 3,\n    'mat4x4<f32>': 16 * 4,\n\n    // TODO - not essential for now but support these in the future\n    // int:      4,\n    // ivec2:    8,\n    // ivec3:    12,\n    // ivec4:    16,\n\n    // uint:     4,\n    // uvec2:    8,\n    // uvec3:    12,\n    // uvec4:    16,\n\n    // bool:     4,\n    // bvec2:    8,\n    // bvec3:    12,\n    // bvec4:    16,\n\n    // mat2:     16 * 2,\n    // mat3:     16 * 3,\n    // mat4:     16 * 4,\n};\n\n/**\n * @param uniformData\n * @internal\n */\nexport function createUboElementsSTD40(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    const chunkSize = 16;\n\n    let size = 0;\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        size = WGSL_TO_STD40_SIZE[uboElement.data.type];\n\n        if (!size)\n        {\n            throw new Error(`Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, chunkSize) * uboElement.data.size;\n        }\n\n        const boundary = size === 12 ? 16 : size;\n\n        uboElement.size = size;\n\n        const curOffset = offset % chunkSize;\n\n        if (curOffset > 0 && chunkSize - curOffset < boundary)\n        {\n            offset += (chunkSize - curOffset) % 16;\n        }\n        else\n        {\n            offset += (size - (curOffset % size)) % size;\n        }\n\n        uboElement.offset = offset;\n        offset += size;\n    }\n\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n", "import { WGSL_TO_STD40_SIZE } from './createUboElementsSTD40';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the std140 layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n * @internal\n */\nexport function generateArraySyncSTD40(uboElement: UboElement, offsetToAdd: number): string\n{\n    const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n    const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;// size / rowSize;\n\n    const remainder = (4 - (elementSize % 4)) % 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n        v = uv.${uboElement.data.name};\n        offset += ${offsetToAdd};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)\n        {\n            for(var j = 0; j < ${elementSize}; j++)\n            {\n                ${data}[arrayOffset++] = v[t++];\n            }\n            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n        }\n    `;\n}\n", "import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsSTD40 } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncSTD40 } from './generateArraySyncSTD40';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param uboElements\n * @internal\n */\nexport function createUboSyncFunctionSTD40(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboStd40',\n        generateArraySyncSTD40,\n        uboSyncFunctionsSTD40,\n    );\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsSTD40 } from './shader/utils/createUboElementsSTD40';\nimport { createUboSyncFunctionSTD40 } from './shader/utils/createUboSyncSTD40';\n\n/**\n * System plugin to the renderer to manage uniform buffers. But with an WGSL adaptor.\n * @category rendering\n * @advanced\n */\nexport class GlUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsSTD40,\n            generateUboSync: createUboSyncFunctionSTD40,\n        });\n    }\n}\n", "/**\n * Represents a render target.\n * @category rendering\n * @ignore\n */\nexport class GlRenderTarget\n{\n    public width = -1;\n    public height = -1;\n    public msaa = false;\n    public framebuffer: WebGLFramebuffer;\n    public resolveTargetFramebuffer: WebGLFramebuffer;\n    public msaaRenderBuffer: WebGLRenderbuffer[] = [];\n    public depthStencilRenderBuffer: WebGLRenderbuffer;\n}\n", "import { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { warn } from '../../../../utils/logging/warn';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { CLEAR } from '../const';\nimport { GlRenderTarget } from '../GlRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { CLEAR_OR_BOOL } from '../const';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGL renderer\n * @category rendering\n * @ignore\n */\nexport class GlRenderTargetAdaptor implements RenderTargetAdaptor<GlRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GlRenderTarget>;\n    private _renderer: WebGLRenderer<HTMLCanvasElement>;\n    private _clearColorCache: RgbaArray = [0, 0, 0, 0];\n    private _viewPortCache: Rectangle = new Rectangle();\n\n    public init(renderer: WebGLRenderer, renderTargetSystem: RenderTargetSystem<GlRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n\n        renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._clearColorCache = [0, 0, 0, 0];\n        this._viewPortCache = new Rectangle();\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const renderer = this._renderer;\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);\n        const gl = renderer.gl;\n\n        this.finishRenderPass(sourceRenderSurfaceTexture);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n\n        renderer.texture.bind(destinationTexture, 0);\n\n        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0,\n            originDest.x, originDest.y,\n            originSrc.x,\n            originSrc.y,\n            size.width,\n            size.height\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const source = renderTarget.colorTexture;\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        let viewPortY = viewport.y;\n\n        if (renderTarget.isRoot)\n        {\n            // /TODO this is the same logic?\n            viewPortY = source.pixelHeight - viewport.height;\n        }\n\n        // unbind the current render texture..\n        renderTarget.colorTextures.forEach((texture) =>\n        {\n            this._renderer.texture.unbind(texture);\n        });\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);\n\n        const viewPortCache = this._viewPortCache;\n\n        if (viewPortCache.x !== viewport.x\n            || viewPortCache.y !== viewPortY\n            || viewPortCache.width !== viewport.width\n            || viewPortCache.height !== viewport.height)\n        {\n            viewPortCache.x = viewport.x;\n            viewPortCache.y = viewPortY;\n            viewPortCache.width = viewport.width;\n            viewPortCache.height = viewport.height;\n\n            gl.viewport(\n                viewport.x,\n                viewPortY,\n                viewport.width,\n                viewport.height,\n            );\n        }\n\n        // if the stencil buffer has been requested, we need to create a stencil buffer\n        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth))\n        {\n            this._initStencil(gpuRenderTarget);\n        }\n\n        this.clear(renderTarget, clear, clearColor);\n    }\n\n    public finishRenderPass(renderTarget?: RenderTarget)\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (!glRenderTarget.msaa) return;\n\n        const gl = this._renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        gl.blitFramebuffer(\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            0, 0, glRenderTarget.width, glRenderTarget.height,\n            gl.COLOR_BUFFER_BIT, gl.NEAREST,\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);\n\n        // dont think we need this anymore? keeping around just in case the wheels fall off\n        // gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GlRenderTarget\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n\n        // do single...\n\n        const glRenderTarget = new GlRenderTarget();\n\n        // we are rendering to the main canvas..\n        const colorTexture = renderTarget.colorTexture;\n\n        if (colorTexture instanceof CanvasSource)\n        {\n            this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource);\n\n            glRenderTarget.framebuffer = null;\n\n            return glRenderTarget;\n        }\n\n        this._initColor(renderTarget, glRenderTarget);\n\n        // set up a depth texture..\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return glRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        if (gpuRenderTarget.framebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.framebuffer);\n            gpuRenderTarget.framebuffer = null;\n        }\n\n        if (gpuRenderTarget.resolveTargetFramebuffer)\n        {\n            gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);\n            gpuRenderTarget.resolveTargetFramebuffer = null;\n        }\n\n        if (gpuRenderTarget.depthStencilRenderBuffer)\n        {\n            gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);\n            gpuRenderTarget.depthStencilRenderBuffer = null;\n        }\n\n        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) =>\n        {\n            gl.deleteRenderbuffer(renderBuffer);\n        });\n\n        gpuRenderTarget.msaaRenderBuffer = null;\n    }\n\n    public clear(_renderTarget: RenderTarget, clear: CLEAR_OR_BOOL, clearColor?: RgbaArray)\n    {\n        if (!clear) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        // if clear is boolean..\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const gl = this._renderer.gl;\n\n        if (clear & CLEAR.COLOR)\n        {\n            clearColor ??= renderTargetSystem.defaultClearColor;\n\n            const clearColorCache = this._clearColorCache;\n            const clearColorArray = clearColor as number[];\n\n            if (clearColorCache[0] !== clearColorArray[0]\n                || clearColorCache[1] !== clearColorArray[1]\n                || clearColorCache[2] !== clearColorArray[2]\n                || clearColorCache[3] !== clearColorArray[3])\n            {\n                clearColorCache[0] = clearColorArray[0];\n                clearColorCache[1] = clearColorArray[1];\n                clearColorCache[2] = clearColorArray[2];\n                clearColorCache[3] = clearColorArray[3];\n\n                gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);\n            }\n        }\n\n        gl.clear(clear);\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        if (renderTarget.isRoot) return;\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        this._resizeColor(renderTarget, glRenderTarget);\n\n        if (renderTarget.stencil || renderTarget.depth)\n        {\n            this._resizeStencil(glRenderTarget);\n        }\n    }\n\n    private _initColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const renderer = this._renderer;\n\n        const gl = renderer.gl;\n        // deal with our outputs..\n        const resolveTargetFramebuffer = gl.createFramebuffer();\n\n        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;\n\n        // set up the texture..\n        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);\n\n        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;\n        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            const source = colorTexture.source;\n\n            if (source.antialias)\n            {\n                if (renderer.context.supports.msaa)\n                {\n                    glRenderTarget.msaa = true;\n                }\n                else\n                {\n                    warn('[RenderTexture] Antialiasing on textures is not supported in WebGL1');\n                }\n            }\n\n            // TODO bindSource could return the glTexture\n            renderer.texture.bindSource(source, 0);\n            const glSource = renderer.texture.getGlSource(source);\n\n            const glTexture = glSource.texture;\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,\n                gl.COLOR_ATTACHMENT0 + i,\n                3553, // texture.target,\n                glTexture,\n                0);// mipLevel);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const viewFramebuffer = gl.createFramebuffer();\n\n            glRenderTarget.framebuffer = viewFramebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((_, i) =>\n            {\n                const msaaRenderBuffer = gl.createRenderbuffer();\n\n                glRenderTarget.msaaRenderBuffer[i] = msaaRenderBuffer;\n            });\n        }\n        else\n        {\n            glRenderTarget.framebuffer = resolveTargetFramebuffer;\n        }\n\n        this._resizeColor(renderTarget, glRenderTarget);\n    }\n\n    private _resizeColor(renderTarget: RenderTarget, glRenderTarget: GlRenderTarget)\n    {\n        const source = renderTarget.colorTexture.source;\n\n        glRenderTarget.width = source.pixelWidth;\n        glRenderTarget.height = source.pixelHeight;\n\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            // nno need to resize the first texture..\n            if (i === 0) return;\n\n            colorTexture.source.resize(source.width, source.height, source._resolution);\n        });\n\n        if (glRenderTarget.msaa)\n        {\n            const renderer = this._renderer;\n            const gl = renderer.gl;\n\n            const viewFramebuffer = glRenderTarget.framebuffer;\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);\n\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const source = colorTexture.source;\n\n                renderer.texture.bindSource(source, 0);\n                const glSource = renderer.texture.getGlSource(source);\n\n                const glInternalFormat = glSource.internalFormat;\n\n                const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];\n\n                gl.bindRenderbuffer(\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n\n                gl.renderbufferStorageMultisample(\n                    gl.RENDERBUFFER,\n                    4,\n                    glInternalFormat,\n                    source.pixelWidth,\n                    source.pixelHeight\n                );\n\n                gl.framebufferRenderbuffer(\n                    gl.FRAMEBUFFER,\n                    gl.COLOR_ATTACHMENT0 + i,\n                    gl.RENDERBUFFER,\n                    msaaRenderBuffer\n                );\n            });\n        }\n    }\n\n    private _initStencil(glRenderTarget: GlRenderTarget)\n    {\n        // this already exists on the default screen\n        if (glRenderTarget.framebuffer === null) return;\n\n        const gl = this._renderer.gl;\n\n        const depthStencilRenderBuffer = gl.createRenderbuffer();\n\n        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        gl.framebufferRenderbuffer(\n            gl.FRAMEBUFFER,\n            gl.DEPTH_STENCIL_ATTACHMENT,\n            gl.RENDERBUFFER,\n            depthStencilRenderBuffer\n        );\n\n        // TDO DO>>\n        this._resizeStencil(glRenderTarget);\n    }\n\n    private _resizeStencil(glRenderTarget: GlRenderTarget)\n    {\n        const gl = this._renderer.gl;\n\n        gl.bindRenderbuffer(\n            gl.RENDERBUFFER,\n            glRenderTarget.depthStencilRenderBuffer\n        );\n\n        if (glRenderTarget.msaa)\n        {\n            gl.renderbufferStorageMultisample(\n                gl.RENDERBUFFER,\n                4,\n                gl.DEPTH24_STENCIL8,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n        else\n        {\n            gl.renderbufferStorage(\n                gl.RENDERBUFFER,\n                this._renderer.context.webGLVersion === 2\n                    ? gl.DEPTH24_STENCIL8\n                    : gl.DEPTH_STENCIL,\n                glRenderTarget.width,\n                glRenderTarget.height\n            );\n        }\n    }\n\n    public prerender(renderTarget: RenderTarget)\n    {\n        const resource = renderTarget.colorTexture.resource;\n\n        // if the render target is a canvas, ensure its size matches the source\n        if (this._renderer.context.multiView && CanvasSource.test(resource))\n        {\n            this._renderer.context.ensureCanvasSize(resource);\n        }\n    }\n\n    public postrender(renderTarget: RenderTarget)\n    {\n        // if multiView is not enabled, we don't need to do anything\n        if (!this._renderer.context.multiView) return;\n\n        // if the render target is a canvas, we need to copy the pixels from the gl canvas\n        // to the canvas target\n        if (CanvasSource.test(renderTarget.colorTexture.resource))\n        {\n            const contextCanvas = this._renderer.context.canvas;\n            const canvasSource = renderTarget.colorTexture as unknown as CanvasSource;\n\n            canvasSource.context2D.drawImage(\n                contextCanvas as CanvasImageSource,\n                0, canvasSource.pixelHeight - contextCanvas.height\n            );\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GlRenderTargetAdaptor } from './GlRenderTargetAdaptor';\n\nimport type { GlRenderTarget } from '../GlRenderTarget';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @category rendering\n * @advanced\n */\nexport class GlRenderTargetSystem extends RenderTargetSystem<GlRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGLSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GlRenderTargetAdaptor();\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n", "import { BufferResource } from '../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\n\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { GlShaderSystem, ShaderSyncFunction } from './GlShaderSystem';\n\n/**\n * Generates the a function that will efficiently sync shader resources with the GPU.\n * @param shader - The shader to generate the code for\n * @param shaderSystem - An instance of the shader system\n * @internal\n */\nexport function generateShaderSyncCode(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n{\n    const funcFragments: string[] = [];\n\n    /**\n     * rS = renderer.shader\n     * sS = shaderSystem\n     * sD = shaderData\n     * g = shader.groups\n     * s = shader\n     * r = renderer\n     * ugS = renderer.uniformGroupSystem\n     */\n    const headerFragments: string[] = [`\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    `];\n\n    let addedTextreSystem = false;\n    let textureCount = 0;\n\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    for (const i in shader.groups)\n    {\n        const group = shader.groups[i];\n\n        funcFragments.push(`\n            resources = g[${i}].resources;\n        `);\n\n        for (const j in group.resources)\n        {\n            const resource = group.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    const resName = shader._uniformBindMap[i][Number(j)];\n\n                    funcFragments.push(`\n                        sS.bindUniformBlock(\n                            resources[${j}],\n                            '${resName}',\n                            ${shader.glProgram._uniformBlockData[resName].index}\n                        );\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        ugS.updateUniformGroup(resources[${j}], p, sD);\n                    `);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                const resName = shader._uniformBindMap[i][Number(j)];\n\n                funcFragments.push(`\n                    sS.bindUniformBlock(\n                        resources[${j}],\n                        '${resName}',\n                        ${shader.glProgram._uniformBlockData[resName].index}\n                    );\n                `);\n            }\n            else if (resource instanceof TextureSource)\n            {\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (!addedTextreSystem)\n                    {\n                        addedTextreSystem = true;\n                        headerFragments.push(`\n                        var tS = r.texture;\n                        `);\n                    }\n\n                    shaderSystem._gl.uniform1i(uniformData.location, textureCount);\n\n                    funcFragments.push(`\n                        tS.bind(resources[${j}], ${textureCount});\n                    `);\n\n                    textureCount++;\n                }\n            }\n        }\n    }\n\n    const functionSource = [...headerFragments, ...funcFragments].join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('r', 's', 'sD', functionSource) as ShaderSyncFunction;\n}\n", "/** @private */\nexport class IGLUniformData\n{\n    public location: WebGLUniformLocation;\n    public value: number | boolean | Float32Array | Int32Array | Uint32Array | boolean[];\n}\n\n/**\n * Helper class to create a WebGL Program\n * @private\n */\nexport class GlProgramData\n{\n    /** The shader program. */\n    public program: WebGLProgram;\n\n    /**\n     * Holds the uniform data which contains uniform locations\n     * and current uniform values used for caching and preventing unneeded GPU commands.\n     */\n    public uniformData: Record<string, any>;\n\n    /**\n     * UniformGroups holds the various upload functions for the shader. Each uniform group\n     * and program have a unique upload function generated.\n     */\n    public uniformGroups: Record<string, any>;\n\n    /** A hash that stores where UBOs are bound to on the program. */\n    public uniformBlockBindings: Record<string, any>;\n\n    /** A hash for lazily-generated uniform uploading functions. */\n    public uniformSync: Record<string, any>;\n\n    /**\n     * A place where dirty ticks are stored for groups\n     * If a tick here does not match with the Higher level Programs tick, it means\n     * we should re upload the data.\n     */\n    public uniformDirtyGroups: Record<string, any>;\n\n    /**\n     * Makes a new Pixi program.\n     * @param program - webgl program\n     * @param uniformData - uniforms\n     */\n    constructor(program: WebGLProgram, uniformData: {[key: string]: IGLUniformData})\n    {\n        this.program = program;\n        this.uniformData = uniformData;\n        this.uniformGroups = {};\n        this.uniformDirtyGroups = {};\n        this.uniformBlockBindings = {};\n    }\n\n    /** Destroys this program. */\n    public destroy(): void\n    {\n        this.uniformData = null;\n        this.uniformGroups = null;\n        this.uniformDirtyGroups = null;\n        this.uniformBlockBindings = null;\n        this.program = null;\n    }\n}\n", "/**\n * @private\n * @param {WebGLRenderingContext} gl - The current WebGL context {WebGLProgram}\n * @param {number} type - the type, can be either VERTEX_SHADER or FRAGMENT_SHADER\n * @param {string} src - The vertex shader source as an array of strings.\n * @returns {WebGLShader} the shader\n */\nexport function compileShader(gl: WebGLRenderingContextBase, type: number, src: string): WebGLShader\n{\n    const shader = gl.createShader(type);\n\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    return shader;\n}\n", "function booleanArray(size: number): Array<boolean>\n{\n    const array = new Array(size);\n\n    for (let i = 0; i < array.length; i++)\n    {\n        array[i] = false;\n    }\n\n    return array;\n}\n\n/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function defaultValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'float':\n            return 0;\n\n        case 'vec2':\n            return new Float32Array(2 * size);\n\n        case 'vec3':\n            return new Float32Array(3 * size);\n\n        case 'vec4':\n            return new Float32Array(4 * size);\n\n        case 'int':\n        case 'uint':\n        case 'sampler2D':\n        case 'sampler2DArray':\n            return 0;\n\n        case 'ivec2':\n            return new Int32Array(2 * size);\n\n        case 'ivec3':\n            return new Int32Array(3 * size);\n\n        case 'ivec4':\n            return new Int32Array(4 * size);\n\n        case 'uvec2':\n            return new Uint32Array(2 * size);\n\n        case 'uvec3':\n            return new Uint32Array(3 * size);\n\n        case 'uvec4':\n            return new Uint32Array(4 * size);\n\n        case 'bool':\n            return false;\n\n        case 'bvec2':\n\n            return booleanArray(2 * size);\n\n        case 'bvec3':\n            return booleanArray(3 * size);\n\n        case 'bvec4':\n            return booleanArray(4 * size);\n\n        case 'mat2':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n", "import type { Dict } from '../../../../../utils/types';\nimport type { VertexFormat } from '../../../shared/geometry/const';\n\nlet GL_TABLE: Dict<string> = null;\n\nconst GL_TO_GLSL_TYPES: Dict<string> = {\n    FLOAT:       'float',\n    FLOAT_VEC2:  'vec2',\n    FLOAT_VEC3:  'vec3',\n    FLOAT_VEC4:  'vec4',\n\n    INT:         'int',\n    INT_VEC2:    'ivec2',\n    INT_VEC3:    'ivec3',\n    INT_VEC4:    'ivec4',\n\n    UNSIGNED_INT:         'uint',\n    UNSIGNED_INT_VEC2:    'uvec2',\n    UNSIGNED_INT_VEC3:    'uvec3',\n    UNSIGNED_INT_VEC4:    'uvec4',\n\n    BOOL:        'bool',\n    BOOL_VEC2:   'bvec2',\n    BOOL_VEC3:   'bvec3',\n    BOOL_VEC4:   'bvec4',\n\n    FLOAT_MAT2:  'mat2',\n    FLOAT_MAT3:  'mat3',\n    FLOAT_MAT4:  'mat4',\n\n    SAMPLER_2D:              'sampler2D',\n    INT_SAMPLER_2D:          'sampler2D',\n    UNSIGNED_INT_SAMPLER_2D: 'sampler2D',\n    SAMPLER_CUBE:              'samplerCube',\n    INT_SAMPLER_CUBE:          'samplerCube',\n    UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',\n    SAMPLER_2D_ARRAY:              'sampler2DArray',\n    INT_SAMPLER_2D_ARRAY:          'sampler2DArray',\n    UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',\n};\n\nconst GLSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    float: 'float32',\n    vec2: 'float32x2',\n    vec3: 'float32x3',\n    vec4: 'float32x4',\n\n    int: 'sint32',\n    ivec2: 'sint32x2',\n    ivec3: 'sint32x3',\n    ivec4: 'sint32x4',\n\n    uint: 'uint32',\n    uvec2: 'uint32x2',\n    uvec3: 'uint32x3',\n    uvec4: 'uint32x4',\n\n    bool: 'uint32',\n    bvec2: 'uint32x2',\n    bvec3: 'uint32x3',\n    bvec4: 'uint32x4',\n};\n\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapType(gl: any, type: number): string\n{\n    if (!GL_TABLE)\n    {\n        const typeNames = Object.keys(GL_TO_GLSL_TYPES);\n\n        GL_TABLE = {};\n\n        for (let i = 0; i < typeNames.length; ++i)\n        {\n            const tn = typeNames[i];\n\n            GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];\n        }\n    }\n\n    return GL_TABLE[type];\n}\n\n/**\n * @param gl\n * @param type\n * @internal\n */\nexport function mapGlToVertexFormat(gl: any, type: number): VertexFormat\n{\n    const typeValue = mapType(gl, type);\n\n    return GLSL_TO_VERTEX_TYPES[typeValue] || 'float32';\n}\n", "import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { mapGlToVertexFormat } from './mapType';\n\nimport type { Attribute } from '../../../shared/geometry/Geometry';\n\n/**\n * This interface represents the extracted attribute data from a WebGL program.\n * It extends the `Attribute` interface but omits the `buffer` property.\n * It includes an optional `location` property that indicates where the shader location is for this attribute.\n * @category rendering\n * @advanced\n */\nexport interface ExtractedAttributeData extends Omit<Attribute, 'buffer'>\n{\n    /** set where the shader location is for this attribute */\n    location?: number;\n}\n\n/**\n * returns the attribute data from the program\n * @private\n * @param {WebGLProgram} [program] - the WebGL program\n * @param {WebGLRenderingContext} [gl] - the WebGL context\n * @param sortAttributes\n * @returns {object} the attribute data for this program\n */\nexport function extractAttributesFromGlProgram(\n    program: WebGLProgram,\n    gl: WebGLRenderingContextBase,\n    sortAttributes = false\n): Record<string, ExtractedAttributeData>\n{\n    const attributes: {[key: string]: ExtractedAttributeData} = {};\n\n    const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n    for (let i = 0; i < totalAttributes; i++)\n    {\n        const attribData = gl.getActiveAttrib(program, i);\n\n        // ignore the default ones!\n        if (attribData.name.startsWith('gl_'))\n        {\n            continue;\n        }\n\n        const format = mapGlToVertexFormat(gl, attribData.type);\n\n        attributes[attribData.name] = {\n            location: 0, // set further down..\n            format,\n            stride: getAttributeInfoFromFormat(format).stride,\n            offset: 0,\n            instance: false,\n            start: 0,\n        };\n    }\n\n    const keys = Object.keys(attributes);\n\n    if (sortAttributes)\n    {\n        keys.sort((a, b) => (a > b) ? 1 : -1); // eslint-disable-line no-confusing-arrow\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = i;\n\n            gl.bindAttribLocation(program, i, keys[i]);\n        }\n\n        gl.linkProgram(program);\n    }\n    else\n    {\n        for (let i = 0; i < keys.length; i++)\n        {\n            attributes[keys[i]].location = gl.getAttribLocation(program, keys[i]);\n        }\n    }\n\n    return attributes;\n}\n", "import type { GlUniformBlockData } from '../GlProgram';\n\n/**\n * returns the uniform block data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUboData(program: WebGLProgram, gl: WebGL2RenderingContext): Record<string, GlUniformBlockData>\n{\n    // if uniform buffer data is not supported, early out\n    if (!gl.ACTIVE_UNIFORM_BLOCKS) return {};\n\n    const uniformBlocks: Record<string, GlUniformBlockData> = {};\n\n    // const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);\n\n    for (let i = 0; i < totalUniformsBlocks; i++)\n    {\n        const name = gl.getActiveUniformBlockName(program, i);\n        const uniformBlockIndex = gl.getUniformBlockIndex(program, name);\n\n        const size = gl.getActiveUniformBlockParameter(program, i, gl.UNIFORM_BLOCK_DATA_SIZE);\n\n        uniformBlocks[name] = {\n            name,\n            index: uniformBlockIndex,\n            size,\n        };\n    }\n\n    return uniformBlocks;\n}\n", "import { defaultValue } from './defaultValue';\nimport { mapType } from './mapType';\n\nimport type { GlUniformData } from '../GlProgram';\n\n/**\n * returns the uniform data from the program\n * @private\n * @param program - the webgl program\n * @param gl - the WebGL context\n * @returns {object} the uniform data for this program\n */\nexport function getUniformData(program: WebGLProgram, gl: WebGLRenderingContextBase): {[key: string]: GlUniformData}\n{\n    const uniforms: {[key: string]: GlUniformData} = {};\n\n    const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n    for (let i = 0; i < totalUniforms; i++)\n    {\n        const uniformData = gl.getActiveUniform(program, i);\n        const name = uniformData.name.replace(/\\[.*?\\]$/, '');\n\n        const isArray = !!(uniformData.name.match(/\\[.*?\\]$/));\n\n        const type = mapType(gl, uniformData.type);\n\n        uniforms[name] = {\n            name,\n            index: i,\n            type,\n            size: uniformData.size,\n            isArray,\n            value: defaultValue(type, uniformData.size),\n        };\n    }\n\n    return uniforms;\n}\n", "/**\n * will log a shader error highlighting the lines with the error\n * also will add numbers along the side.\n * @param gl - the WebGLContext\n * @param shader - the shader to log errors for\n */\nfunction logPrettyShaderError(gl: WebGLRenderingContext, shader: WebGLShader): void\n{\n    const shaderSrc = gl.getShaderSource(shader)\n        .split('\\n')\n        .map((line, index) => `${index}: ${line}`);\n\n    const shaderLog = gl.getShaderInfoLog(shader);\n    const splitShader = shaderLog.split('\\n');\n\n    const dedupe: Record<number, boolean> = {};\n\n    const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, '$1')))\n        .filter((n) =>\n        {\n            if (n && !dedupe[n])\n            {\n                dedupe[n] = true;\n\n                return true;\n            }\n\n            return false;\n        });\n\n    const logArgs = [''];\n\n    lineNumbers.forEach((number) =>\n    {\n        shaderSrc[number - 1] = `%c${shaderSrc[number - 1]}%c`;\n        logArgs.push('background: #FF0000; color:#FFFFFF; font-size: 10px', 'font-size: 10px');\n    });\n\n    const fragmentSourceToLog = shaderSrc\n        .join('\\n');\n\n    logArgs[0] = fragmentSourceToLog;\n\n    console.error(shaderLog);\n\n    // eslint-disable-next-line no-console\n    console.groupCollapsed('click to view full shader code');\n    console.warn(...logArgs);\n    // eslint-disable-next-line no-console\n    console.groupEnd();\n}\n\n/**\n *\n * logs out any program errors\n * @param gl - The current WebGL context\n * @param program - the WebGL program to display errors for\n * @param vertexShader  - the fragment WebGL shader program\n * @param fragmentShader - the vertex WebGL shader program\n * @private\n */\nexport function logProgramError(\n    gl: WebGLRenderingContext,\n    program: WebGLProgram,\n    vertexShader: WebGLShader,\n    fragmentShader: WebGLShader\n): void\n{\n    // if linking fails, then log and cleanup\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS))\n    {\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, vertexShader);\n        }\n\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))\n        {\n            logPrettyShaderError(gl, fragmentShader);\n        }\n\n        console.error('PixiJS Error: Could not initialize shader.');\n\n        // if there is a program info log, log it\n        if (gl.getProgramInfoLog(program) !== '')\n        {\n            console.warn('PixiJS Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));\n        }\n    }\n}\n", "import { warn } from '../../../../../utils/logging/warn';\nimport { GlProgramData } from '../GlProgramData';\nimport { compileShader } from './compileShader';\nimport { defaultValue } from './defaultValue';\nimport { extractAttributesFromGlProgram } from './extractAttributesFromGlProgram';\nimport { getUboData } from './getUboData';\nimport { getUniformData } from './getUniformData';\nimport { logProgramError } from './logProgramError';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlProgram } from '../GlProgram';\nimport type { IGLUniformData } from '../GlProgramData';\n\n/**\n * generates a WebGL Program object from a high level Pixi Program.\n * @param gl - a rendering context on which to generate the program\n * @param program - the high level Pixi Program.\n * @private\n */\nexport function generateProgram(gl: GlRenderingContext, program: GlProgram): GlProgramData\n{\n    const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);\n    const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);\n\n    const webGLProgram = gl.createProgram();\n\n    gl.attachShader(webGLProgram, glVertShader);\n    gl.attachShader(webGLProgram, glFragShader);\n\n    const transformFeedbackVaryings = program.transformFeedbackVaryings;\n\n    if (transformFeedbackVaryings)\n    {\n        if (typeof gl.transformFeedbackVaryings !== 'function')\n        {\n            // #if _DEBUG\n            warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);\n            // #endif\n        }\n        else\n        {\n            gl.transformFeedbackVaryings(\n                webGLProgram,\n                transformFeedbackVaryings.names,\n                transformFeedbackVaryings.bufferMode === 'separate'\n                    ? gl.SEPARATE_ATTRIBS\n                    : gl.INTERLEAVED_ATTRIBS\n            );\n        }\n    }\n\n    gl.linkProgram(webGLProgram);\n\n    if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS))\n    {\n        logProgramError(gl, webGLProgram, glVertShader, glFragShader);\n    }\n\n    // GLSL 1.00: bind attributes sorted by name in ascending order\n    // GLSL 3.00: don't change the attribute locations that where chosen by the compiler\n    //            or assigned by the layout specifier in the shader source code\n    program._attributeData = extractAttributesFromGlProgram(\n        webGLProgram,\n        gl,\n        !(/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m).test(program.vertex)\n    );\n\n    program._uniformData = getUniformData(webGLProgram, gl);\n    program._uniformBlockData = getUboData(webGLProgram, gl);\n\n    gl.deleteShader(glVertShader);\n    gl.deleteShader(glFragShader);\n\n    const uniformData: {[key: string]: IGLUniformData} = {};\n\n    for (const i in program._uniformData)\n    {\n        const data = program._uniformData[i];\n\n        uniformData[i] = {\n            location: gl.getUniformLocation(webGLProgram, i),\n            value: defaultValue(data.type, data.size),\n        };\n    }\n\n    const glProgram = new GlProgramData(webGLProgram, uniformData);\n\n    return glProgram;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateShaderSyncCode } from './GenerateShaderSyncCode';\nimport { generateProgram } from './program/generateProgram';\n\nimport type { BufferResource } from '../../shared/buffer/BufferResource';\nimport type { Shader } from '../../shared/shader/Shader';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram } from './GlProgram';\nimport type { GlProgramData } from './GlProgramData';\n\n/** @internal */\nexport interface ShaderSyncData\n{\n    textureCount: number;\n    blockIndex: number;\n}\n\n/** @internal */\nexport type ShaderSyncFunction = (renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData) => void;\n\n// default sync data so we don't create a new one each time!\nconst defaultSyncData: ShaderSyncData = {\n    textureCount: 0,\n    blockIndex: 0,\n};\n\n/**\n * System plugin to the renderer to manage the shaders for WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    /** @internal */\n    public _activeProgram: GlProgram = null;\n\n    private _programDataHash: Record<string, GlProgramData> = Object.create(null);\n    private readonly _renderer: WebGLRenderer;\n    /** @internal */\n    public _gl: WebGL2RenderingContext;\n    private _shaderSyncFunctions: Record<string, ShaderSyncFunction> = Object.create(null);\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_programDataHash');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        this._programDataHash = Object.create(null);\n        /**\n         * these need to also be cleared as internally some uniforms are set as an optimisation as the sync\n         * function is generated. Specifically the texture ints.\n         */\n        this._shaderSyncFunctions = Object.create(null);\n        this._activeProgram = null;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter.\n     * @param shader - the new shader\n     * @param skipSync - false if the shader should automatically sync its uniforms.\n     * @returns the glProgram that belongs to the shader.\n     */\n    public bind(shader: Shader, skipSync?: boolean): void\n    {\n        this._setProgram(shader.glProgram);\n\n        if (skipSync) return;\n\n        defaultSyncData.textureCount = 0;\n        defaultSyncData.blockIndex = 0;\n\n        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];\n\n        if (!syncFunction)\n        {\n            syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);\n        }\n\n        // TODO: take into account number of TF buffers. Currently works only with interleaved\n        this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings);\n        syncFunction(this._renderer, shader, defaultSyncData);\n    }\n\n    /**\n     * Updates the uniform group.\n     * @param uniformGroup - the uniform group to update\n     */\n    public updateUniformGroup(uniformGroup: UniformGroup): void\n    {\n        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);\n    }\n\n    /**\n     * Binds a uniform block to the shader.\n     * @param uniformGroup - the uniform group to bind\n     * @param name - the name of the uniform block\n     * @param index - the index of the uniform block\n     */\n    public bindUniformBlock(uniformGroup: UniformGroup | BufferResource, name: string, index = 0): void\n    {\n        const bufferSystem = this._renderer.buffer;\n        const programData = this._getProgramData(this._activeProgram);\n\n        const isBufferResource = (uniformGroup as BufferResource)._bufferResource;\n\n        if (!isBufferResource)\n        {\n            this._renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n        }\n\n        const buffer = uniformGroup.buffer;\n\n        const glBuffer = bufferSystem.updateBuffer(buffer);\n\n        const boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);\n\n        if (isBufferResource)\n        {\n            const { offset, size } = (uniformGroup as BufferResource);\n\n            // trivial case of buffer resource, can be cached\n            if (offset === 0 && size === buffer.data.byteLength)\n            {\n                bufferSystem.bindBufferBase(glBuffer, boundLocation);\n            }\n            else\n            {\n                bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);\n            }\n        }\n        else if (bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation)\n        {\n            // confirmation that buffer isn't there yet\n            bufferSystem.bindBufferBase(glBuffer, boundLocation);\n        }\n\n        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;\n\n        if (programData.uniformBlockBindings[index] === boundLocation) return;\n        programData.uniformBlockBindings[index] = boundLocation;\n\n        this._renderer.gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundLocation);\n    }\n\n    private _setProgram(program: GlProgram)\n    {\n        if (this._activeProgram === program) return;\n\n        this._activeProgram = program;\n\n        const programData = this._getProgramData(program);\n\n        this._gl.useProgram(programData.program);\n    }\n\n    /**\n     * @param program - the program to get the data for\n     * @internal\n     */\n    public _getProgramData(program: GlProgram): GlProgramData\n    {\n        return this._programDataHash[program._key] || this._createProgramData(program);\n    }\n\n    private _createProgramData(program: GlProgram): GlProgramData\n    {\n        const key = program._key;\n\n        this._programDataHash[key] = generateProgram(this._gl, program);\n\n        return this._programDataHash[key];\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._programDataHash))\n        {\n            const programData = this._programDataHash[key];\n\n            programData.destroy();\n            this._programDataHash[key] = null;\n        }\n\n        this._programDataHash = null;\n        this._shaderSyncFunctions = null;\n        this._activeProgram = null;\n        (this._renderer as null) = null;\n        this._gl = null;\n    }\n\n    /**\n     * Creates a function that can be executed that will sync the shader as efficiently as possible.\n     * Overridden by the unsafe eval package if you don't want eval used in your project.\n     * @param shader - the shader to generate the sync function for\n     * @param shaderSystem - the shader system to use\n     * @returns - the generated sync function\n     * @ignore\n     */\n    public _generateShaderSync(shader: Shader, shaderSystem: GlShaderSystem): ShaderSyncFunction\n    {\n        return generateShaderSyncCode(shader, shaderSystem);\n    }\n\n    public resetState(): void\n    {\n        this._activeProgram = null;\n    }\n}\n", "// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport type { UNIFORM_TYPES } from '../../../shared/shader/types';\n\n/** @internal */\nexport const UNIFORM_TO_SINGLE_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }`,\n    'vec2<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }`,\n    'vec3<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<f32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }`,\n    i32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<i32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    u32: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }`,\n    'vec2<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }`,\n    'vec3<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<u32>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }`,\n    bool: `if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }`,\n    'vec2<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }`,\n    'vec3<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }`,\n    'vec4<bool>': `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n};\n\n/** @internal */\nexport const UNIFORM_TO_ARRAY_SETTERS: Record<UNIFORM_TYPES | string, string> = {\n    f32: `gl.uniform1fv(location, v);`,\n    'vec2<f32>': `gl.uniform2fv(location, v);`,\n    'vec3<f32>': `gl.uniform3fv(location, v);`,\n    'vec4<f32>': `gl.uniform4fv(location, v);`,\n    'mat2x2<f32>': `gl.uniformMatrix2fv(location, false, v);`,\n    'mat3x3<f32>': `gl.uniformMatrix3fv(location, false, v);`,\n    'mat4x4<f32>': `gl.uniformMatrix4fv(location, false, v);`,\n    i32: `gl.uniform1iv(location, v);`,\n    'vec2<i32>': `gl.uniform2iv(location, v);`,\n    'vec3<i32>': `gl.uniform3iv(location, v);`,\n    'vec4<i32>': `gl.uniform4iv(location, v);`,\n    u32: `gl.uniform1iv(location, v);`,\n    'vec2<u32>': `gl.uniform2iv(location, v);`,\n    'vec3<u32>': `gl.uniform3iv(location, v);`,\n    'vec4<u32>': `gl.uniform4iv(location, v);`,\n    bool: `gl.uniform1iv(location, v);`,\n    'vec2<bool>': `gl.uniform2iv(location, v);`,\n    'vec3<bool>': `gl.uniform3iv(location, v);`,\n    'vec4<bool>': `gl.uniform4iv(location, v);`,\n};\n", "// cu = Cached value's uniform data field\n// cv = Cached value\n// v = value to upload\n// ud = uniformData\n// uv = uniformValue\n\nimport { BufferResource } from '../../../shared/buffer/BufferResource';\nimport { UniformGroup } from '../../../shared/shader/UniformGroup';\nimport { uniformParsers } from '../../../shared/shader/utils/uniformParsers';\nimport { UNIFORM_TO_ARRAY_SETTERS, UNIFORM_TO_SINGLE_SETTERS } from './generateUniformsSyncTypes';\n\nimport type { UniformsSyncCallback } from '../../../shared/shader/types';\n\n/**\n * @param group\n * @param uniformData\n * @internal\n */\nexport function generateUniformsSync(group: UniformGroup, uniformData: Record<string, any>): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    `];\n\n    for (const i in group.uniforms)\n    {\n        if (!uniformData[i])\n        {\n            if (group.uniforms[i] instanceof UniformGroup)\n            {\n                if ((group.uniforms[i] as UniformGroup).ubo)\n                {\n                    funcFragments.push(`\n                        renderer.shader.bindUniformBlock(uv.${i}, \"${i}\");\n                    `);\n                }\n                else\n                {\n                    funcFragments.push(`\n                        renderer.shader.updateUniformGroup(uv.${i});\n                    `);\n                }\n            }\n            else if (group.uniforms[i] instanceof BufferResource)\n            {\n                funcFragments.push(`\n                        renderer.shader.bindBufferResource(uv.${i}, \"${i}\");\n                    `);\n            }\n\n            continue;\n        }\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                funcFragments.push(`name = \"${i}\";`, uniformParsers[j].uniform);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;\n\n            const template = templateType[uniform.type].replace('location', `ud[\"${i}\"].location`);\n\n            funcFragments.push(`\n            cu = ud[\"${i}\"];\n            cv = cu.value;\n            v = uv[\"${i}\"];\n            ${template};`);\n        }\n    }\n\n    /*\n     * the introduction of syncData is to solve an issue where textures in uniform groups are not set correctly\n     * the texture count was always starting from 0 in each group. This needs to increment each time a texture is used\n     * no matter which group is being used\n     *\n     */\n    // eslint-disable-next-line no-new-func\n    return new Function('ud', 'uv', 'renderer', 'syncData', funcFragments.join('\\n')) as UniformsSyncCallback;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { generateUniformsSync } from './utils/generateUniformsSync';\n\nimport type { UniformsSyncCallback } from '../../shared/shader/types';\nimport type { UniformGroup } from '../../shared/shader/UniformGroup';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GlProgram, GlUniformData } from './GlProgram';\n\n/**\n * System plugin to the renderer to manage shaders.\n * @category rendering\n * @advanced\n */\nexport class GlUniformGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'uniformGroup',\n    } as const;\n\n    /**\n     * The current WebGL rendering context.\n     * @type {WebGLRenderingContext}\n     */\n    protected gl: GlRenderingContext;\n\n    /** Cache to holds the generated functions. Stored against UniformObjects unique signature. */\n    private _cache: Record<string, UniformsSyncCallback> = {};\n    private _renderer: WebGLRenderer;\n\n    private _uniformGroupSyncHash: Record<string, Record<string, UniformsSyncCallback>> = {};\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n\n        this.gl = null;\n        this._cache = {};\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n    }\n\n    /**\n     * Uploads the uniforms values to the currently bound shader.\n     * @param group - the uniforms values that be applied to the current shader\n     * @param program\n     * @param syncData\n     * @param syncData.textureCount\n     */\n    public updateUniformGroup(group: UniformGroup, program: GlProgram, syncData: { textureCount: number }): void\n    {\n        const programData = this._renderer.shader._getProgramData(program);\n\n        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid])\n        {\n            programData.uniformDirtyGroups[group.uid] = group._dirtyId;\n\n            const syncFunc = this._getUniformSyncFunction(group, program);\n\n            syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);\n        }\n    }\n\n    /**\n     * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.\n     * @param group\n     * @param program\n     */\n    private _getUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        return this._uniformGroupSyncHash[group._signature]?.[program._key]\n            || this._createUniformSyncFunction(group, program);\n    }\n\n    private _createUniformSyncFunction(group: UniformGroup, program: GlProgram): UniformsSyncCallback\n    {\n        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature]\n            || (this._uniformGroupSyncHash[group._signature] = {});\n\n        const id = this._getSignature(group, program._uniformData, 'u');\n\n        if (!this._cache[id])\n        {\n            this._cache[id] = this._generateUniformsSync(group, program._uniformData);\n        }\n\n        uniformGroupSyncHash[program._key] = this._cache[id];\n\n        return uniformGroupSyncHash[program._key];\n    }\n\n    private _generateUniformsSync(group: UniformGroup, uniformData: Record<string, GlUniformData>): UniformsSyncCallback\n    {\n        return generateUniformsSync(group, uniformData);\n    }\n\n    /**\n     * Takes a uniform group and data and generates a unique signature for them.\n     * @param group - The uniform group to get signature of\n     * @param group.uniforms\n     * @param uniformData - Uniform information generated by the shader\n     * @param preFix\n     * @returns Unique signature of the uniform group\n     */\n    private _getSignature(group: UniformGroup, uniformData: Record<string, any>, preFix: string): string\n    {\n        const uniforms = group.uniforms;\n\n        const strings = [`${preFix}-`];\n\n        for (const i in uniforms)\n        {\n            strings.push(i);\n\n            if (uniformData[i])\n            {\n                strings.push(uniformData[i].type);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    /** Destroys this System and removes all its textures. */\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._cache = null;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\n/**\n * Maps gl blend combinations to WebGL.\n * @param gl\n * @returns {object} Map of gl blend combinations to WebGL.\n * @internal\n */\nexport function mapWebGLBlendModesToPixi(gl: GlRenderingContext): Record<BLEND_MODES, number[]>\n{\n    const blendMap: Partial<Record<BLEND_MODES, number[]>> = {};\n\n    // TODO - premultiply alpha would be different.\n    // add a boolean for that!\n    blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.add = [gl.ONE, gl.ONE];\n    blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap.none = [0, 0];\n\n    // not-premultiplied blend modes\n    blendMap['normal-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n    blendMap['add-npm'] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];\n    blendMap['screen-npm'] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n\n    blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n\n    const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());\n\n    if (isWebGl2)\n    {\n        blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];\n        blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];\n    }\n    else\n    {\n        const ext = gl.getExtension('EXT_blend_minmax');\n\n        if (ext)\n        {\n            blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];\n            blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];\n        }\n    }\n\n    // TODO - implement if requested!\n    // composite operations\n    // array[BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];\n    // array[BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];\n    // array[BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];\n    // array[BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];\n    // array[BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];\n    // array[BLEND_MODES.XOR] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n    // SUBTRACT from flash\n    // array[BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];\n\n    return blendMap as Record<BLEND_MODES, number[]>;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport { State } from '../../shared/state/State';\nimport { type WebGLRenderer } from '../WebGLRenderer';\nimport { mapWebGLBlendModesToPixi } from './mapWebGLBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\n\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * System plugin to the renderer to manage WebGL state machines\n * @category rendering\n * @advanced\n */\nexport class GlStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'state',\n    } as const;\n\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @type {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gl: GlRenderingContext;\n\n    protected blendModesMap: Record<BLEND_MODES, number[]>;\n\n    /**\n     * Collection of calls\n     * @type {Function[]}\n     */\n    protected readonly map: ((value: boolean) => void)[];\n\n    /**\n     * Collection of check calls\n     * @type {Function[]}\n     */\n    protected readonly checks: ((system: this, state: State) => void)[];\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    /**\n     * Whether to invert the front face when rendering\n     * This is used for render textures where the Y-coordinate is flipped\n     * @default false\n     */\n    private _invertFrontFace: boolean = false;\n    private _glFrontFace: boolean;\n    private _cullFace: boolean;\n    private _frontFaceDirty: boolean;\n    private _frontFace: boolean;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this.gl = null;\n\n        this.stateId = 0;\n        this.polygonOffset = 0;\n        this.blendMode = 'none';\n\n        this._blendEq = false;\n\n        // map functions for when we set state..\n        this.map = [];\n        this.map[BLEND] = this.setBlend;\n        this.map[OFFSET] = this.setOffset;\n        this.map[CULLING] = this.setCullFace;\n        this.map[DEPTH_TEST] = this.setDepthTest;\n        this.map[WINDING] = this.setFrontFace;\n        this.map[DEPTH_MASK] = this.setDepthMask;\n\n        this.checks = [];\n\n        this.defaultState = State.for2d();\n\n        // listen for when the renderTarget changes\n        // as rendering to textures means we need to invert the front face\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        this._invertFrontFace = !renderTarget.isRoot;\n\n        // mini optimization to avoid setting the front face if culling is disabled\n        if (this._cullFace)\n        {\n            // need to set the front face to the requested value as it matters because of the culling is active!\n            this.setFrontFace(this._frontFace);\n        }\n        else\n        {\n            // if culling is disabled, we need to set the front face dirty\n            this._frontFaceDirty = true;\n        }\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this.gl = gl;\n\n        this.blendModesMap = mapWebGLBlendModesToPixi(gl);\n\n        // Reset face culling variables\n\n        this.resetState();\n    }\n\n    /**\n     * Sets the current state\n     * @param {*} state - The state to set.\n     */\n    public set(state: State): void\n    {\n        state ||= this.defaultState;\n\n        // TODO maybe to an object check? ( this.state === state )?\n        if (this.stateId !== state.data)\n        {\n            let diff = this.stateId ^ state.data;\n            let i = 0;\n\n            // order from least to most common\n            while (diff)\n            {\n                if (diff & 1)\n                {\n                    // state change!\n                    this.map[i].call(this, !!(state.data & (1 << i)));\n                }\n\n                diff >>= 1;\n                i++;\n            }\n\n            this.stateId = state.data;\n        }\n\n        // based on the above settings we check for specific modes..\n        // for example if blend is active we check and set the blend modes\n        // or of polygon offset is active we check the poly depth.\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n    }\n\n    /**\n     * Sets the state, when previous state is unknown.\n     * @param {*} state - The state to set\n     */\n    public forceState(state: State): void\n    {\n        state ||= this.defaultState;\n        for (let i = 0; i < this.map.length; i++)\n        {\n            this.map[i].call(this, !!(state.data & (1 << i)));\n        }\n        for (let i = 0; i < this.checks.length; i++)\n        {\n            this.checks[i](this, state);\n        }\n\n        this.stateId = state.data;\n    }\n\n    /**\n     * Sets whether to enable or disable blending.\n     * @param value - Turn on or off WebGl blending.\n     */\n    public setBlend(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkBlendMode, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);\n    }\n\n    /**\n     * Sets whether to enable or disable polygon offset fill.\n     * @param value - Turn on or off webgl polygon offset testing.\n     */\n    public setOffset(value: boolean): void\n    {\n        this._updateCheck(GlStateSystem._checkPolygonOffset, value);\n\n        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);\n    }\n\n    /**\n     * Sets whether to enable or disable depth test.\n     * @param value - Turn on or off webgl depth testing.\n     */\n    public setDepthTest(value: boolean): void\n    {\n        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);\n    }\n\n    /**\n     * Sets whether to enable or disable depth mask.\n     * @param value - Turn on or off webgl depth mask.\n     */\n    public setDepthMask(value: boolean): void\n    {\n        this.gl.depthMask(value);\n    }\n\n    /**\n     * Sets whether to enable or disable cull face.\n     * @param {boolean} value - Turn on or off webgl cull face.\n     */\n    public setCullFace(value: boolean): void\n    {\n        this._cullFace = value;\n        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);\n\n        if (this._cullFace && this._frontFaceDirty)\n        {\n            // need to set the front face to the requested value as it matters because of the culling is active!\n            this.setFrontFace(this._frontFace);\n        }\n    }\n\n    /**\n     * Sets the gl front face.\n     * @param {boolean} value - true is clockwise and false is counter-clockwise\n     */\n    public setFrontFace(value: boolean): void\n    {\n        this._frontFace = value;\n        this._frontFaceDirty = false;\n        // If invertFrontFace is true, we invert the face direction\n        const faceMode = this._invertFrontFace ? !value : value;\n\n        if (this._glFrontFace !== faceMode)\n        {\n            this._glFrontFace = faceMode;\n            this.gl.frontFace(this.gl[faceMode ? 'CW' : 'CCW']);\n        }\n    }\n\n    /**\n     * Sets the blend mode.\n     * @param {number} value - The blend mode to set to.\n     */\n    public setBlendMode(value: BLEND_MODES): void\n    {\n        if (!this.blendModesMap[value])\n        {\n            value = 'normal';\n        }\n\n        if (value === this.blendMode)\n        {\n            return;\n        }\n\n        this.blendMode = value;\n\n        const mode = this.blendModesMap[value];\n        const gl = this.gl;\n\n        if (mode.length === 2)\n        {\n            gl.blendFunc(mode[0], mode[1]);\n        }\n        else\n        {\n            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);\n        }\n\n        if (mode.length === 6)\n        {\n            this._blendEq = true;\n            gl.blendEquationSeparate(mode[4], mode[5]);\n        }\n        else if (this._blendEq)\n        {\n            this._blendEq = false;\n            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        }\n    }\n\n    /**\n     * Sets the polygon offset.\n     * @param {number} value - the polygon offset\n     * @param {number} scale - the polygon offset scale\n     */\n    public setPolygonOffset(value: number, scale: number): void\n    {\n        this.gl.polygonOffset(value, scale);\n    }\n\n    /** Resets all the logic and disables the VAOs. */\n    public resetState(): void\n    {\n        this._glFrontFace = false;\n        this._frontFace = false;\n        this._cullFace = false;\n        this._frontFaceDirty = false;\n        this._invertFrontFace = false;\n\n        this.gl.frontFace(this.gl.CCW);\n        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);\n\n        this.forceState(this.defaultState);\n\n        this._blendEq = true;\n        // setting to '' means the blend mode will be set as soon as we set the first blend mode when rendering!\n        this.blendMode = '' as BLEND_MODES;\n        this.setBlendMode('normal');\n    }\n\n    /**\n     * Checks to see which updates should be checked based on which settings have been activated.\n     *\n     * For example, if blend is enabled then we should check the blend modes each time the state is changed\n     * or if polygon fill is activated then we need to check if the polygon offset changes.\n     * The idea is that we only check what we have too.\n     * @param func - the checking function to add or remove\n     * @param value - should the check function be added or removed.\n     */\n    private _updateCheck(func: (system: this, state: State) => void, value: boolean): void\n    {\n        const index = this.checks.indexOf(func);\n\n        if (value && index === -1)\n        {\n            this.checks.push(func);\n        }\n        else if (!value && index !== -1)\n        {\n            this.checks.splice(index, 1);\n        }\n    }\n\n    /**\n     * A private little wrapper function that we call to check the blend mode.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkBlendMode(system: GlStateSystem, state: State): void\n    {\n        system.setBlendMode(state.blendMode);\n    }\n\n    /**\n     * A private little wrapper function that we call to check the polygon offset.\n     * @param system - the System to perform the state check on\n     * @param state - the state that the blendMode will pulled from\n     */\n    private static _checkPolygonOffset(system: GlStateSystem, state: State): void\n    {\n        system.setPolygonOffset(1, state.polygonOffset);\n    }\n\n    /** @ignore */\n    public destroy(): void\n    {\n        this.gl = null;\n        this.checks.length = 0;\n    }\n}\n", "import { GL_FORMATS, GL_TARGETS, GL_TYPES } from './const';\n\n/**\n * Internal texture for WebGL context\n * @category rendering\n * @ignore\n */\nexport class GlTexture\n{\n    public target: GL_TARGETS = GL_TARGETS.TEXTURE_2D;\n\n    /** The WebGL texture. */\n    public texture: WebGLTexture;\n\n    /** Width of texture that was used in texImage2D. */\n    public width: number;\n\n    /** Height of texture that was used in texImage2D. */\n    public height: number;\n\n    /** Whether mip levels has to be generated. */\n    public mipmap: boolean;\n\n    /** Type copied from texture source. */\n    public type: number;\n\n    /** Type copied from texture source. */\n    public internalFormat: number;\n\n    /** Type of sampler corresponding to this texture. See {@link SAMPLER_TYPES} */\n    public samplerType: number;\n\n    public format: GL_FORMATS;\n\n    constructor(texture: WebGLTexture)\n    {\n        this.texture = texture;\n        this.width = -1;\n        this.height = -1;\n        this.type = GL_TYPES.UNSIGNED_BYTE;\n        this.internalFormat = GL_FORMATS.RGBA;\n        this.format = GL_FORMATS.RGBA;\n        this.samplerType = 0;\n    }\n}\n", "import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadBufferImageResource = {\n\n    id: 'buffer',\n\n    upload(source: TextureSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        if (glTexture.width === source.width || glTexture.height === source.height)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                source.width,\n                source.height,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                source.width,\n                source.height,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource\n            );\n        }\n\n        glTexture.width = source.width;\n        glTexture.height = source.height;\n    }\n} as GLTextureUploader;\n\n", "import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\nconst compressedFormatMap: Record<string, boolean> = {\n    'bc1-rgba-unorm': true,\n    'bc1-rgba-unorm-srgb': true,\n    'bc2-rgba-unorm': true,\n    'bc2-rgba-unorm-srgb': true,\n    'bc3-rgba-unorm': true,\n    'bc3-rgba-unorm-srgb': true,\n    'bc4-r-unorm': true,\n    'bc4-r-snorm': true,\n    'bc5-rg-unorm': true,\n    'bc5-rg-snorm': true,\n    'bc6h-rgb-ufloat': true,\n    'bc6h-rgb-float': true,\n    'bc7-rgba-unorm': true,\n    'bc7-rgba-unorm-srgb': true,\n\n    // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'etc2-rgb8unorm': true,\n    'etc2-rgb8unorm-srgb': true,\n    'etc2-rgb8a1unorm': true,\n    'etc2-rgb8a1unorm-srgb': true,\n    'etc2-rgba8unorm': true,\n    'etc2-rgba8unorm-srgb': true,\n    'eac-r11unorm': true,\n    'eac-r11snorm': true,\n    'eac-rg11unorm': true,\n    'eac-rg11snorm': true,\n\n    // ASTC compressed formats usable if \"texture-compression-astc\" is both\n    // supported by the device/user agent and enabled in requestDevice.\n    'astc-4x4-unorm': true,\n    'astc-4x4-unorm-srgb': true,\n    'astc-5x4-unorm': true,\n    'astc-5x4-unorm-srgb': true,\n    'astc-5x5-unorm': true,\n    'astc-5x5-unorm-srgb': true,\n    'astc-6x5-unorm': true,\n    'astc-6x5-unorm-srgb': true,\n    'astc-6x6-unorm': true,\n    'astc-6x6-unorm-srgb': true,\n    'astc-8x5-unorm': true,\n    'astc-8x5-unorm-srgb': true,\n    'astc-8x6-unorm': true,\n    'astc-8x6-unorm-srgb': true,\n    'astc-8x8-unorm': true,\n    'astc-8x8-unorm-srgb': true,\n    'astc-10x5-unorm': true,\n    'astc-10x5-unorm-srgb': true,\n    'astc-10x6-unorm': true,\n    'astc-10x6-unorm-srgb': true,\n    'astc-10x8-unorm': true,\n    'astc-10x8-unorm-srgb': true,\n    'astc-10x10-unorm': true,\n    'astc-10x10-unorm-srgb': true,\n    'astc-12x10-unorm': true,\n    'astc-12x10-unorm-srgb': true,\n    'astc-12x12-unorm': true,\n    'astc-12x12-unorm-srgb': true,\n};\n\n/** @internal */\nexport const glUploadCompressedTextureResource = {\n\n    id: 'compressed',\n\n    upload(source: CompressedSource, glTexture: GlTexture, gl: GlRenderingContext)\n    {\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);\n\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const compressed = !!compressedFormatMap[source.format];\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            if (compressed)\n            {\n                gl.compressedTexImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    levelBuffer\n                );\n            }\n            else\n            {\n                gl.texImage2D(\n                    gl.TEXTURE_2D, i, glTexture.internalFormat,\n                    mipWidth, mipHeight, 0,\n                    glTexture.format, glTexture.type,\n                    levelBuffer);\n            }\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GLTextureUploader;\n\n", "import type { CanvasSource } from '../../../shared/texture/sources/CanvasSource';\nimport type { ImageSource } from '../../../shared/texture/sources/ImageSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadImageResource = {\n\n    id: 'image',\n\n    upload(source: ImageSource | CanvasSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        const glWidth = glTexture.width;\n        const glHeight = glTexture.height;\n\n        const textureWidth = source.pixelWidth;\n        const textureHeight = source.pixelHeight;\n\n        const resourceWidth = source.resourceWidth;\n        const resourceHeight = source.resourceHeight;\n\n        if (resourceWidth < textureWidth || resourceHeight < textureHeight)\n        {\n            if (glWidth !== textureWidth || glHeight !== textureHeight)\n            {\n                gl.texImage2D(\n                    glTexture.target,\n                    0,\n                    glTexture.internalFormat,\n                    textureWidth,\n                    textureHeight,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    null\n                );\n            }\n\n            if (webGLVersion === 2)\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    resourceWidth,\n                    resourceHeight,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n            else\n            {\n                gl.texSubImage2D(\n                    gl.TEXTURE_2D,\n                    0,\n                    0,\n                    0,\n                    glTexture.format,\n                    glTexture.type,\n                    source.resource as TexImageSource\n                );\n            }\n        }\n        else if (glWidth === textureWidth && glHeight === textureHeight)\n        {\n            gl.texSubImage2D(\n                gl.TEXTURE_2D,\n                0,\n                0,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else if (webGLVersion === 2)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                textureWidth,\n                textureHeight,\n                0,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n        else\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                glTexture.format,\n                glTexture.type,\n                source.resource as TexImageSource\n            );\n        }\n\n        glTexture.width = textureWidth;\n        glTexture.height = textureHeight;\n    }\n} as GLTextureUploader;\n\n", "import { glUploadImageResource } from './glUploadImageResource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { GlTexture } from '../GlTexture';\nimport type { GLTextureUploader } from './GLTextureUploader';\n\n/** @internal */\nexport const glUploadVideoResource = {\n\n    id: 'video',\n\n    upload(source: VideoSource, glTexture: GlTexture, gl: GlRenderingContext, webGLVersion: number)\n    {\n        if (!source.isValid)\n        {\n            gl.texImage2D(\n                glTexture.target,\n                0,\n                glTexture.internalFormat,\n                1,\n                1,\n                0,\n                glTexture.format,\n                glTexture.type,\n                null\n            );\n\n            return;\n        }\n\n        glUploadImageResource.upload(source, glTexture, gl, webGLVersion);\n    }\n} as GLTextureUploader;\n\n", "/** @internal */\nexport const scaleModeToGlFilter = {\n    linear: 9729,\n    nearest: 9728,\n};\n\n/** @internal */\nexport const mipmapScaleModeToGlFilter = {\n    linear: {\n        linear: 9987,\n        nearest: 9985,\n    },\n    nearest: {\n        linear: 9986,\n        nearest: 9984,\n    }\n};\n\n/** @internal */\nexport const wrapModeToGlAddress = {\n    'clamp-to-edge': 33071,\n    repeat: 10497,\n    'mirror-repeat': 33648,\n};\n\n/** @internal */\nexport const compareModeToGlCompare = {\n    never: 512,\n    less: 513,\n    equal: 514,\n    'less-equal': 515,\n    greater: 516,\n    'not-equal': 517,\n    'greater-equal': 518,\n    always: 519,\n};\n\n", "import {\n    compareModeToGlCompare,\n    mipmapScaleModeToGlFilter,\n    scaleModeToGlFilter,\n    wrapModeToGlAddress\n} from './pixiToGlMaps';\n\nimport type { TextureStyle } from '../../../shared/texture/TextureStyle';\n\n/**\n * @param style\n * @param gl\n * @param mipmaps\n * @param anisotropicExt\n * @param glFunctionName\n * @param firstParam\n * @param forceClamp\n * @param firstCreation\n * @internal\n */\nexport function applyStyleParams(\n    style: TextureStyle,\n    gl: WebGL2RenderingContext,\n    mipmaps: boolean,\n    // eslint-disable-next-line camelcase\n    anisotropicExt: EXT_texture_filter_anisotropic,\n    glFunctionName: 'samplerParameteri' | 'texParameteri',\n    firstParam: 3553 | WebGLSampler,\n    forceClamp: boolean,\n    /** if true we can skip setting certain values if the values is the same as the default gl values */\n    firstCreation: boolean\n)\n{\n    const castParam = firstParam as 3553;\n\n    if (!firstCreation\n        || style.addressModeU !== 'repeat'\n        || style.addressModeV !== 'repeat'\n        || style.addressModeW !== 'repeat'\n    )\n    {\n        // 1. set the wrapping mode\n        const wrapModeS = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeU];\n        const wrapModeT = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeV];\n        const wrapModeR = wrapModeToGlAddress[forceClamp ? 'clamp-to-edge' : style.addressModeW];\n\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);\n        gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);\n\n        // does not exist in webGL1\n        if (gl.TEXTURE_WRAP_R) gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);\n    }\n\n    if (!firstCreation || style.magFilter !== 'linear')\n    {\n        // 2. set the filtering mode\n        gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);\n    }\n\n    // assuming the currently bound texture is the one we want to set the filter for\n    // the only smelly part of this code, WebGPU is much better here :P\n    if (mipmaps)\n    {\n        if (!firstCreation || style.mipmapFilter !== 'linear')\n        {\n            const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];\n\n            gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);\n        }\n    }\n\n    else\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);\n    }\n\n    // 3. set the anisotropy\n    if (anisotropicExt && style.maxAnisotropy > 1)\n    {\n        const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n\n        gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);\n    }\n\n    // 4. set the compare mode\n    if (style.compare)\n    {\n        gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);\n    }\n}\n", "import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlFormat(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.RED,\n        r8snorm: gl.RED,\n        r8uint: gl.RED,\n        r8sint: gl.RED,\n\n        // 16-bit formats\n        r16uint: gl.RED,\n        r16sint:    gl.RED,\n        r16float: gl.RED,\n        rg8unorm:  gl.RG,\n        rg8snorm:   gl.RG,\n        rg8uint:  gl.RG,\n        rg8sint:  gl.RG,\n\n        // 32-bit formats\n        r32uint: gl.RED,\n        r32sint: gl.RED,\n        r32float: gl.RED,\n        rg16uint:   gl.RG,\n        rg16sint:  gl.RG,\n        rg16float:  gl.RG,\n        rgba8unorm: gl.RGBA,\n        'rgba8unorm-srgb': gl.RGBA,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA,\n        rgba8uint: gl.RGBA,\n        rgba8sint: gl.RGBA,\n        bgra8unorm: gl.RGBA,\n        'bgra8unorm-srgb': gl.RGBA,\n        rgb9e5ufloat: gl.RGB,\n        rgb10a2unorm: gl.RGBA,\n        rg11b10ufloat: gl.RGB,\n\n        // 64-bit formats\n        rg32uint: gl.RG,\n        rg32sint: gl.RG,\n        rg32float:  gl.RG,\n        rgba16uint: gl.RGBA,\n        rgba16sint: gl.RGBA,\n        rgba16float: gl.RGBA,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA,\n        rgba32sint: gl.RGBA,\n        rgba32float: gl.RGBA,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT,\n        depth24plus: gl.DEPTH_COMPONENT,\n        'depth24plus-stencil8': gl.DEPTH_STENCIL,\n        depth32float: gl.DEPTH_COMPONENT,\n        'depth32float-stencil8': gl.DEPTH_STENCIL,\n\n    };\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\nimport type { WebGLExtensions } from '../../context/WebGLExtensions';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param gl - The rendering context.\n * @param extensions - The WebGL extensions.\n * @returns Lookup table.\n */\nexport function mapFormatToGlInternalFormat(\n    gl: GlRenderingContext,\n    extensions: WebGLExtensions,\n): Record<string, number>\n{\n    let srgb = {};\n    let bgra8unorm: number = gl.RGBA;\n\n    if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext()))\n    {\n        srgb = {\n            'rgba8unorm-srgb': gl.SRGB8_ALPHA8,\n            'bgra8unorm-srgb': gl.SRGB8_ALPHA8,\n        };\n\n        bgra8unorm = gl.RGBA8;\n    }\n    else if (extensions.srgb)\n    {\n        srgb = {\n            'rgba8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n            'bgra8unorm-srgb': extensions.srgb.SRGB8_ALPHA8_EXT,\n        };\n    }\n\n    return {\n        // 8-bit formats\n        r8unorm: gl.R8,\n        r8snorm: gl.R8_SNORM,\n        r8uint: gl.R8UI,\n        r8sint: gl.R8I,\n\n        // 16-bit formats\n        r16uint: gl.R16UI,\n        r16sint: gl.R16I,\n        r16float: gl.R16F,\n        rg8unorm: gl.RG8,\n        rg8snorm: gl.RG8_SNORM,\n        rg8uint: gl.RG8UI,\n        rg8sint: gl.RG8I,\n\n        // 32-bit formats\n        r32uint: gl.R32UI,\n        r32sint: gl.R32I,\n        r32float: gl.R32F,\n        rg16uint: gl.RG16UI,\n        rg16sint: gl.RG16I,\n        rg16float: gl.RG16F,\n        rgba8unorm: gl.RGBA,\n\n        ...srgb,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.RGBA8_SNORM,\n        rgba8uint: gl.RGBA8UI,\n        rgba8sint: gl.RGBA8I,\n        bgra8unorm,\n        rgb9e5ufloat: gl.RGB9_E5,\n        rgb10a2unorm: gl.RGB10_A2,\n        rg11b10ufloat: gl.R11F_G11F_B10F,\n\n        // 64-bit formats\n        rg32uint: gl.RG32UI,\n        rg32sint: gl.RG32I,\n        rg32float: gl.RG32F,\n        rgba16uint: gl.RGBA16UI,\n        rgba16sint: gl.RGBA16I,\n        rgba16float: gl.RGBA16F,\n\n        // 128-bit formats\n        rgba32uint: gl.RGBA32UI,\n        rgba32sint: gl.RGBA32I,\n        rgba32float: gl.RGBA32F,\n\n        // Depth/stencil formats\n        stencil8: gl.STENCIL_INDEX8,\n        depth16unorm: gl.DEPTH_COMPONENT16,\n        depth24plus: gl.DEPTH_COMPONENT24,\n        'depth24plus-stencil8': gl.DEPTH24_STENCIL8,\n        depth32float: gl.DEPTH_COMPONENT32F,\n        'depth32float-stencil8': gl.DEPTH32F_STENCIL8,\n\n        // Compressed formats\n        ...extensions.s3tc ? {\n            'bc1-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm': extensions.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.s3tc_sRGB ? {\n            'bc1-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n            'bc2-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n            'bc3-rgba-unorm-srgb': extensions.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n        } : {},\n        ...extensions.rgtc ? {\n            'bc4-r-unorm': extensions.rgtc.COMPRESSED_RED_RGTC1_EXT,\n            'bc4-r-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n            'bc5-rg-unorm': extensions.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,\n            'bc5-rg-snorm': extensions.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n        } : {},\n        ...extensions.bptc ? {\n            'bc6h-rgb-float': extensions.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,\n            'bc6h-rgb-ufloat': extensions.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,\n            'bc7-rgba-unorm': extensions.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,\n            'bc7-rgba-unorm-srgb': extensions.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,\n        } : {},\n        ...extensions.etc ? {\n            'etc2-rgb8unorm': extensions.etc.COMPRESSED_RGB8_ETC2,\n            'etc2-rgb8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ETC2,\n            'etc2-rgb8a1unorm': extensions.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgb8a1unorm-srgb': extensions.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n            'etc2-rgba8unorm': extensions.etc.COMPRESSED_RGBA8_ETC2_EAC,\n            'etc2-rgba8unorm-srgb': extensions.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n            'eac-r11unorm': extensions.etc.COMPRESSED_R11_EAC,\n            // 'eac-r11snorm'\n            'eac-rg11unorm': extensions.etc.COMPRESSED_SIGNED_RG11_EAC,\n            // 'eac-rg11snorm'\n        } : {},\n        ...extensions.astc ? {\n            'astc-4x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,\n            'astc-4x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n            'astc-5x4-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,\n            'astc-5x4-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,\n            'astc-5x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,\n            'astc-5x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n            'astc-6x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,\n            'astc-6x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n            'astc-6x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,\n            'astc-6x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n            'astc-8x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,\n            'astc-8x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n            'astc-8x6-unorm':   extensions.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,\n            'astc-8x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n            'astc-8x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,\n            'astc-8x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n            'astc-10x5-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,\n            'astc-10x5-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n            'astc-10x6-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,\n            'astc-10x6-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n            'astc-10x8-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,\n            'astc-10x8-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n            'astc-10x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,\n            'astc-10x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n            'astc-12x10-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,\n            'astc-12x10-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n            'astc-12x12-unorm': extensions.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,\n            'astc-12x12-unorm-srgb': extensions.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n        } : {},\n    };\n}\n", "import type { GlRenderingContext } from '../../context/GlRenderingContext';\n\n/**\n * Returns a lookup table that maps each type-format pair to a compatible internal format.\n * @function mapTypeAndFormatToInternalFormat\n * @private\n * @param {WebGLRenderingContext} gl - The rendering context.\n * @returns Lookup table.\n */\nexport function mapFormatToGlType(gl: GlRenderingContext): Record<string, number>\n{\n    return {\n        // 8-bit formats\n        r8unorm: gl.UNSIGNED_BYTE,\n        r8snorm: gl.BYTE,\n        r8uint: gl.UNSIGNED_BYTE,\n        r8sint: gl.BYTE,\n\n        // 16-bit formats\n        r16uint: gl.UNSIGNED_SHORT,\n        r16sint: gl.SHORT,\n        r16float: gl.HALF_FLOAT,\n        rg8unorm: gl.UNSIGNED_BYTE,\n        rg8snorm: gl.BYTE,\n        rg8uint: gl.UNSIGNED_BYTE,\n        rg8sint: gl.BYTE,\n\n        // 32-bit formats\n        r32uint: gl.UNSIGNED_INT,\n        r32sint: gl.INT,\n        r32float: gl.FLOAT,\n        rg16uint: gl.UNSIGNED_SHORT,\n        rg16sint: gl.SHORT,\n        rg16float: gl.HALF_FLOAT,\n        rgba8unorm: gl.UNSIGNED_BYTE,\n        'rgba8unorm-srgb': gl.UNSIGNED_BYTE,\n\n        // Packed 32-bit formats\n        rgba8snorm: gl.BYTE,\n        rgba8uint: gl.UNSIGNED_BYTE,\n        rgba8sint: gl.BYTE,\n        bgra8unorm: gl.UNSIGNED_BYTE,\n        'bgra8unorm-srgb': gl.UNSIGNED_BYTE,\n        rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,\n        rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,\n        rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,\n\n        // 64-bit formats\n        rg32uint: gl.UNSIGNED_INT,\n        rg32sint: gl.INT,\n        rg32float: gl.FLOAT,\n        rgba16uint: gl.UNSIGNED_SHORT,\n        rgba16sint: gl.SHORT,\n        rgba16float: gl.HALF_FLOAT,\n\n        // 128-bit formats\n        rgba32uint: gl.UNSIGNED_INT,\n        rgba32sint: gl.INT,\n        rgba32float: gl.FLOAT,\n\n        // Depth/stencil formats\n        stencil8: gl.UNSIGNED_BYTE,\n        depth16unorm: gl.UNSIGNED_SHORT,\n        depth24plus: gl.UNSIGNED_INT,\n        'depth24plus-stencil8': gl.UNSIGNED_INT_24_8,\n        depth32float: gl.FLOAT,\n        'depth32float-stencil8': gl.FLOAT_32_UNSIGNED_INT_24_8_REV,\n\n    };\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Texture } from '../../shared/texture/Texture';\nimport { GlTexture } from './GlTexture';\nimport { glUploadBufferImageResource } from './uploaders/glUploadBufferImageResource';\nimport { glUploadCompressedTextureResource } from './uploaders/glUploadCompressedTextureResource';\nimport { glUploadImageResource } from './uploaders/glUploadImageResource';\nimport { glUploadVideoResource } from './uploaders/glUploadVideoResource';\nimport { applyStyleParams } from './utils/applyStyleParams';\nimport { mapFormatToGlFormat } from './utils/mapFormatToGlFormat';\nimport { mapFormatToGlInternalFormat } from './utils/mapFormatToGlInternalFormat';\nimport { mapFormatToGlType } from './utils/mapFormatToGlType';\nimport { unpremultiplyAlpha } from './utils/unpremultiplyAlpha';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { WebGLRenderer } from '../WebGLRenderer';\nimport type { GLTextureUploader } from './uploaders/GLTextureUploader';\n\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The system for managing textures in WebGL.\n * @category rendering\n * @advanced\n */\nexport class GlTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    private readonly _renderer: WebGLRenderer;\n\n    private _glTextures: Record<number, GlTexture> = Object.create(null);\n    private _glSamplers: Record<string, WebGLSampler> = Object.create(null);\n\n    private _boundTextures: TextureSource[] = [];\n    private _activeTextureLocation = -1;\n\n    private _boundSamplers: Record<number, WebGLSampler> = Object.create(null);\n\n    private readonly _uploads: Record<string, GLTextureUploader> = {\n        image: glUploadImageResource,\n        buffer: glUploadBufferImageResource,\n        video: glUploadVideoResource,\n        compressed: glUploadCompressedTextureResource,\n    };\n\n    private _gl: GlRenderingContext;\n    private _mapFormatToInternalFormat: Record<string, number>;\n    private _mapFormatToType: Record<string, number>;\n    private _mapFormatToFormat: Record<string, number>;\n\n    private _premultiplyAlpha = false;\n\n    // TODO - separate samplers will be a cool thing to add, but not right now!\n    private readonly _useSeparateSamplers = false;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_glTextures');\n        this._renderer.renderableGC.addManagedHash(this, '_glSamplers');\n    }\n\n    protected contextChange(gl: GlRenderingContext): void\n    {\n        this._gl = gl;\n\n        if (!this._mapFormatToInternalFormat)\n        {\n            this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);\n\n            this._mapFormatToType = mapFormatToGlType(gl);\n            this._mapFormatToFormat = mapFormatToGlFormat(gl);\n        }\n\n        this._glTextures = Object.create(null);\n        this._glSamplers = Object.create(null);\n        this._boundSamplers = Object.create(null);\n        this._premultiplyAlpha = false;\n\n        for (let i = 0; i < 16; i++)\n        {\n            this.bind(Texture.EMPTY, i);\n        }\n    }\n\n    /**\n     * Initializes a texture source, if it has already been initialized nothing will happen.\n     * @param source - The texture source to initialize.\n     * @returns The initialized texture source.\n     */\n    public initSource(source: TextureSource)\n    {\n        this.bind(source);\n    }\n\n    public bind(texture: BindableTexture, location = 0)\n    {\n        const source = texture.source;\n\n        if (texture)\n        {\n            this.bindSource(source, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(source.style, location);\n            }\n        }\n        else\n        {\n            this.bindSource(null, location);\n\n            if (this._useSeparateSamplers)\n            {\n                this._bindSampler(null, location);\n            }\n        }\n    }\n\n    public bindSource(source: TextureSource, location = 0): void\n    {\n        const gl = this._gl;\n\n        source._touched = this._renderer.textureGC.count;\n\n        if (this._boundTextures[location] !== source)\n        {\n            this._boundTextures[location] = source;\n            this._activateLocation(location);\n\n            source ||= Texture.EMPTY.source;\n\n            // bind texture and source!\n            const glTexture = this.getGlSource(source);\n\n            gl.bindTexture(glTexture.target, glTexture.texture);\n        }\n    }\n\n    private _bindSampler(style: TextureStyle, location = 0): void\n    {\n        const gl = this._gl;\n\n        if (!style)\n        {\n            this._boundSamplers[location] = null;\n            gl.bindSampler(location, null);\n\n            return;\n        }\n\n        const sampler = this._getGlSampler(style);\n\n        if (this._boundSamplers[location] !== sampler)\n        {\n            this._boundSamplers[location] = sampler;\n            gl.bindSampler(location, sampler);\n        }\n    }\n\n    public unbind(texture: BindableTexture): void\n    {\n        const source = texture.source;\n        const boundTextures = this._boundTextures;\n        const gl = this._gl;\n\n        for (let i = 0; i < boundTextures.length; i++)\n        {\n            if (boundTextures[i] === source)\n            {\n                this._activateLocation(i);\n\n                const glTexture = this.getGlSource(source);\n\n                gl.bindTexture(glTexture.target, null);\n                boundTextures[i] = null;\n            }\n        }\n    }\n\n    private _activateLocation(location: number): void\n    {\n        if (this._activeTextureLocation !== location)\n        {\n            this._activeTextureLocation = location;\n            this._gl.activeTexture(this._gl.TEXTURE0 + location);\n        }\n    }\n\n    private _initSource(source: TextureSource): GlTexture\n    {\n        const gl = this._gl;\n\n        const glTexture = new GlTexture(gl.createTexture());\n\n        glTexture.type = this._mapFormatToType[source.format];\n        glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];\n        glTexture.format = this._mapFormatToFormat[source.format];\n\n        if (source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo))\n        {\n            const biggestDimension = Math.max(source.width, source.height);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        this._glTextures[source.uid] = glTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceUpdate, this);\n            source.on('styleChange', this.onStyleChange, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n        this.updateStyle(source, false);\n\n        return glTexture;\n    }\n\n    protected onStyleChange(source: TextureSource): void\n    {\n        this.updateStyle(source, false);\n    }\n\n    protected updateStyle(source: TextureSource, firstCreation: boolean): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        applyStyleParams(\n            source.style,\n            gl,\n            source.mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'texParameteri',\n            gl.TEXTURE_2D,\n            // will force a clamp to edge if the texture is not a power of two\n            !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo,\n            firstCreation,\n        );\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const glTexture = this._glTextures[source.uid];\n\n        if (!glTexture) return;\n\n        this.unbind(source);\n        this._glTextures[source.uid] = null;\n\n        this._gl.deleteTexture(glTexture.texture);\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gl = this._gl;\n\n        const glTexture = this.getGlSource(source);\n\n        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n\n        this._boundTextures[this._activeTextureLocation] = source;\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        if (this._premultiplyAlpha !== premultipliedAlpha)\n        {\n            this._premultiplyAlpha = premultipliedAlpha;\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);\n        }\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion);\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source, false);\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource, bind = true): void\n    {\n        if (bind) this.bindSource(source, 0);\n\n        const glTexture = this.getGlSource(source);\n\n        this._gl.generateMipmap(glTexture.target);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('update', this.onSourceUpdate, this);\n        source.off('resize', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('styleChange', this.onStyleChange, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    private _initSampler(style: TextureStyle): WebGLSampler\n    {\n        const gl = this._gl;\n\n        const glSampler = this._gl.createSampler();\n\n        this._glSamplers[style._resourceId] = glSampler;\n\n        applyStyleParams(\n            style,\n            gl,\n            this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,\n            this._renderer.context.extensions.anisotropicFiltering,\n            'samplerParameteri',\n            glSampler,\n            false,\n            true,\n        );\n\n        return this._glSamplers[style._resourceId];\n    }\n\n    private _getGlSampler(sampler: TextureStyle): WebGLSampler\n    {\n        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGlSource(source: TextureSource): GlTexture\n    {\n        return this._glTextures[source.uid] || this._initSource(source);\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const { pixels, width, height } = this.getPixels(texture);\n\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = width;\n        canvas.height = height;\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx)\n        {\n            const imageData = ctx.createImageData(width, height);\n\n            imageData.data.set(pixels);\n            ctx.putImageData(imageData, 0, 0);\n        }\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const resolution = texture.source.resolution;\n        const frame = texture.frame;\n\n        const width = Math.max(Math.round(frame.width * resolution), 1);\n        const height = Math.max(Math.round(frame.height * resolution), 1);\n        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        const renderer = this._renderer;\n\n        const renderTarget = renderer.renderTarget.getRenderTarget(texture);\n        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);\n\n        const gl = renderer.gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);\n\n        gl.readPixels(\n            Math.round(frame.x * resolution),\n            Math.round(frame.y * resolution),\n            width,\n            height,\n            gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            pixels\n        );\n\n        // if (texture.source.premultiplyAlpha > 0)\n        // TODO - premultiplied alpha does not exist right now, need to add that back in!\n        // eslint-disable-next-line no-constant-condition\n        if (false)\n        {\n            unpremultiplyAlpha(pixels);\n        }\n\n        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the array with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n        this._glTextures = null;\n        this._glSamplers = null;\n        this._boundTextures = null;\n        this._boundSamplers = null;\n        this._mapFormatToInternalFormat = null;\n        this._mapFormatToType = null;\n        this._mapFormatToFormat = null;\n        (this._uploads as null) = null;\n        (this._renderer as null) = null;\n    }\n\n    public resetState(): void\n    {\n        this._activeTextureLocation = -1;\n        this._boundTextures.fill(Texture.EMPTY.source);\n        this._boundSamplers = Object.create(null);\n\n        const gl = this._gl;\n\n        this._premultiplyAlpha = false;\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);\n    }\n}\n\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GlGraphicsAdaptor } from '../../../scene/graphics/gl/GlGraphicsAdaptor';\nimport { GlMeshAdaptor } from '../../../scene/mesh/gl/GlMeshAdaptor';\nimport { GlBatchAdaptor } from '../../batcher/gl/GlBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { GlBufferSystem } from './buffer/GlBufferSystem';\nimport { GlContextSystem } from './context/GlContextSystem';\nimport { GlGeometrySystem } from './geometry/GlGeometrySystem';\nimport { GlBackBufferSystem } from './GlBackBufferSystem';\nimport { GlColorMaskSystem } from './GlColorMaskSystem';\nimport { GlEncoderSystem } from './GlEncoderSystem';\nimport { GlLimitsSystem } from './GlLimitsSystem';\nimport { GlStencilSystem } from './GlStencilSystem';\nimport { GlUboSystem } from './GlUboSystem';\nimport { GlRenderTargetSystem } from './renderTarget/GlRenderTargetSystem';\nimport { GlShaderSystem } from './shader/GlShaderSystem';\nimport { GlUniformGroupSystem } from './shader/GlUniformGroupSystem';\nimport { GlStateSystem } from './state/GlStateSystem';\nimport { GlTextureSystem } from './texture/GlTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\nimport type { GlRenderingContext } from './context/GlRenderingContext';\n\nconst DefaultWebGLSystems = [\n    ...SharedSystems,\n    GlUboSystem,\n    GlBackBufferSystem,\n    GlContextSystem,\n    GlLimitsSystem,\n    GlBufferSystem,\n    GlTextureSystem,\n    GlRenderTargetSystem,\n    GlGeometrySystem,\n    GlUniformGroupSystem,\n    GlShaderSystem,\n    GlEncoderSystem,\n    GlStateSystem,\n    GlStencilSystem,\n    GlColorMaskSystem,\n];\nconst DefaultWebGLPipes = [...SharedRenderPipes];\nconst DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGLSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @category rendering\n * @standard\n * @interface\n */\nexport type WebGLSystems = ExtractSystemTypes<typeof DefaultWebGLSystems>\n& PixiMixins.RendererSystems & PixiMixins.WebGLSystems;\n\n/**\n * The default WebGL renderer, uses WebGL2 contexts.\n * @internal\n */\nexport type WebGLPipes = ExtractSystemTypes<typeof DefaultWebGLPipes> & PixiMixins.RendererPipes & PixiMixins.WebGLPipes;\n\n/**\n * Options for WebGLRenderer.\n * @category rendering\n * @standard\n */\nexport interface WebGLOptions\n    extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGLSystems>,\n    PixiMixins.WebGLOptions {}\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>,\n    WebGLSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGL PixiJS Renderer. This renderer allows you to use the most common graphics API, WebGL (and WebGL2).\n *\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGLRenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n *\n *\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer({\n *    preference:'webgl',\n * });\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGL renderer:\n *\n * | WebGL Core Systems                          | Systems that are specific to the WebGL renderer                               |\n * | ------------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link GlUboSystem}               | This manages WebGL2 uniform buffer objects feature for shaders                |\n * | {@link GlBackBufferSystem}        | manages the back buffer, used so that we can pixi can pixels from the screen  |\n * | {@link GlContextSystem}           | This manages the WebGL context and its extensions                             |\n * | {@link GlBufferSystem}            | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link GlTextureSystem}           | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link GlRenderTargetSystem}      | This manages what we render too. For example the screen, or another texture   |\n * | {@link GlGeometrySystem}          | This manages geometry, used for drawing meshes via the GPU                    |\n * | {@link GlUniformGroupSystem}      | This manages uniform groups. Syncing shader properties with the GPU           |\n * | {@link GlShaderSystem}            | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link GlEncoderSystem}           | This manages encoders, a WebGPU Paradigm, use it to draw a mesh + shader      |\n * | {@link GlStateSystem}             | This manages the state of the WebGL context. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link GlStencilSystem}           | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link GlColorMaskSystem}         | This manages the color mask. Used for color masking                           |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @category rendering\n * @property {GlUboSystem} ubo - UboSystem instance.\n * @property {GlBackBufferSystem} backBuffer - BackBufferSystem instance.\n * @property {GlContextSystem} context - ContextSystem instance.\n * @property {GlBufferSystem} buffer - BufferSystem instance.\n * @property {GlTextureSystem} texture - TextureSystem instance.\n * @property {GlRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {GlGeometrySystem} geometry - GeometrySystem instance.\n * @property {GlUniformGroupSystem} uniformGroup - UniformGroupSystem instance.\n * @property {GlShaderSystem} shader - ShaderSystem instance.\n * @property {GlEncoderSystem} encoder - EncoderSystem instance.\n * @property {GlStateSystem} state - StateSystem instance.\n * @property {GlStencilSystem} stencil - StencilSystem instance.\n * @property {GlColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @extends AbstractRenderer\n * @standard\n */\nexport class WebGLRenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGLPipes, WebGLOptions, T>\n    implements WebGLSystems\n{\n    public gl: GlRenderingContext;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgl',\n            type: RendererType.WEBGL,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the browser environment.\n * @category environment\n * @internal\n */\nexport const browserExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'browser',\n        priority: -1,\n    },\n    test: () => true,\n    load: async () =>\n    {\n        await import('./browserAll');\n    },\n};\n", "import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the webworker environment.\n * @category environment\n * @internal\n */\nexport const webworkerExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'webworker',\n        priority: 0,\n    },\n    test: () => typeof self !== 'undefined' && self.WorkerGlobalScope !== undefined,\n    load: async () =>\n    {\n        await import('./webworkerAll');\n    },\n};\n", "import { DOMAdapter } from '../../environment/adapter';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer';\n\nlet _isWebGLSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGL support in the current environment.\n *\n * Results are cached after first call for better performance.\n * @example\n * ```ts\n * // Basic WebGL support check\n * if (isWebGLSupported()) {\n *     console.log('WebGL is available');\n * }\n * ```\n * @param failIfMajorPerformanceCaveat - Whether to fail if there is a major performance caveat\n * @returns True if WebGL is supported\n * @category utils\n * @standard\n */\nexport function isWebGLSupported(\n    failIfMajorPerformanceCaveat?: boolean\n): boolean\n{\n    if (_isWebGLSupported !== undefined) return _isWebGLSupported;\n\n    _isWebGLSupported = ((): boolean =>\n    {\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat:\n                failIfMajorPerformanceCaveat\n                ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat,\n        };\n\n        try\n        {\n            if (!DOMAdapter.get().getWebGLRenderingContext())\n            {\n                return false;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas();\n            let gl = canvas.getContext('webgl', contextOptions);\n\n            const success = !!gl?.getContextAttributes()?.stencil;\n\n            if (gl)\n            {\n                const loseContext = gl.getExtension('WEBGL_lose_context');\n\n                if (loseContext)\n                {\n                    loseContext.loseContext();\n                }\n            }\n\n            gl = null;\n\n            return success;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGLSupported;\n}\n", "import { DOMAdapter } from '../../environment/adapter';\n\nlet _isWebGPUSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGPU support in the current environment.\n * Results are cached after first call for better performance.\n * @example\n * ```ts\n * // Basic WebGPU support check\n * const hasWebGPU = await isWebGPUSupported();\n * console.log('WebGPU available:', hasWebGPU);\n * ```\n * @param options - The options for requesting a GPU adapter\n * @returns Promise that resolves to true if WebGPU is supported\n * @category utils\n * @standard\n */\nexport async function isWebGPUSupported(options: GPURequestAdapterOptions = {}): Promise<boolean>\n{\n    if (_isWebGPUSupported !== undefined) return _isWebGPUSupported;\n\n    _isWebGPUSupported = await (async (): Promise<boolean> =>\n    {\n        const gpu = DOMAdapter.get().getNavigator().gpu;\n\n        if (!gpu)\n        {\n            return false;\n        }\n\n        try\n        {\n            const adapter = await gpu.requestAdapter(options) as GPUAdapter;\n\n            // TODO and one of these!\n            await adapter.requestDevice();\n\n            return true;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGPUSupported;\n}\n", "import { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer, RendererOptions } from './types';\n\n/**\n * Options for {@link autoDetectRenderer}.\n * @category rendering\n * @advanced\n */\nexport interface AutoDetectOptions extends RendererOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @category rendering\n * @standard\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n", "import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer';\nimport { Container } from '../scene/container/Container';\nimport { ApplicationInitHook } from '../utils/global/globalHooks';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { AutoDetectOptions } from '../rendering/renderers/autoDetectRenderer';\nimport type { RendererDestroyOptions } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { DestroyOptions } from '../scene/container/destroyTypes';\n\n/**\n * Interface for creating Application plugins. Any plugin that's usable for Application must implement these methods.\n *\n * To create a plugin:\n * 1. Create a class that implements this interface\n * 2. Add the required static extension property\n * 3. Register the plugin using extensions.add()\n * @example\n * ```ts\n * import { ApplicationPlugin, ExtensionType, extensions } from 'pixi.js';\n *\n * class MyPlugin {\n *    // Required: Declare the extension type\n *    public static extension = ExtensionType.Application;\n *\n *    // Required: Implement init method\n *    public static init(options: Partial<ApplicationOptions>): void {\n *        // Add properties/methods to the Application instance (this)\n *        Object.defineProperty(this, 'myFeature', {\n *            value: () => console.log('My feature!'),\n *        });\n *\n *        // Use options if needed\n *        console.log('Plugin initialized with:', options);\n *    }\n *\n *    // Required: Implement destroy method\n *    public static destroy(): void {\n *        // Clean up any resources\n *        console.log('Plugin destroyed');\n *    }\n * }\n *\n * // Register the plugin\n * extensions.add(MyPlugin);\n *\n * // Usage in application\n * const app = new Application();\n * await app.init();\n * app.myFeature(); // Output: \"My feature!\"\n * ```\n * > [!IMPORTANT]\n * > - Plugins are initialized in the order they are added\n * > - Plugins are destroyed in reverse order\n * > - The `this` context in both methods refers to the Application instance\n * @see {@link ExtensionType} For different types of extensions\n * @see {@link extensions} For the extension registration system\n * @see {@link ApplicationOptions} For available application options\n * @category app\n * @advanced\n */\nexport interface ApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application `init()` options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<ApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to the {@link Application#init} method.\n * These options configure how your PixiJS application behaves.\n * @category app\n * @standard\n * @example\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * // Initialize with common options\n * await app.init({\n *    // Rendering options\n *    width: 800,                    // Canvas width\n *    height: 600,                   // Canvas height\n *    backgroundColor: 0x1099bb,     // Background color\n *    antialias: true,              // Enable antialiasing\n *    resolution: window.devicePixelRatio, // Screen resolution\n *\n *    // Performance options\n *    autoStart: true,              // Auto-starts the render loop\n *    sharedTicker: true,           // Use shared ticker for better performance\n *\n *    // Automatic resize options\n *    resizeTo: window,             // Auto-resize to window\n *    autoDensity: true,           // Adjust for device pixel ratio\n *\n *    // Advanced options\n *    preference: 'webgl',         // Renderer preference ('webgl' or 'webgpu')\n *    powerPreference: 'high-performance' // GPU power preference\n * });\n * ```\n * @see {@link WebGLOptions} For resize-related options\n * @see {@link WebGPUOptions} For resize-related options\n * @see {@link TickerPlugin} For ticker-related options\n * @see {@link ResizePlugin} For resize-related options\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { }\n\n// eslint-disable-next-line max-len\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Application extends PixiMixins.Application { }\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * The Application class is the main entry point for creating a PixiJS application. It handles the setup of all core\n * components needed to start rendering and managing your game or interactive experience.\n *\n * Key features:\n * - Automatically creates and manages the renderer\n * - Provides a stage (root container) for your display objects\n * - Handles canvas creation and management\n * - Supports plugins for extending functionality\n *   - {@link ResizePlugin} for automatic resizing\n *   - {@link TickerPlugin} for managing frame updates\n *   - {@link CullerPlugin} for culling off-screen objects\n * @example\n * ```js\n * import { Assets, Application, Sprite } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n *\n * // Initialize with options\n * await app.init({\n *     width: 800,           // Canvas width\n *     height: 600,          // Canvas height\n *     backgroundColor: 0x1099bb, // Background color\n *     antialias: true,     // Enable antialiasing\n *     resolution: 1,       // Resolution / device pixel ratio\n *     preference: 'webgl', // or 'webgpu' // Renderer preference\n * });\n *\n * // Add the canvas to your webpage\n * document.body.appendChild(app.canvas);\n *\n * // Start adding content to your application\n * const texture - await Assets.load('your-image.png');\n * const sprite = new Sprite(texture);\n * app.stage.addChild(sprite);\n * ```\n * > [!IMPORTANT] From PixiJS v8.0.0, the application must be initialized using the async `init()` method\n * > rather than passing options to the constructor.\n * @category app\n * @standard\n * @see {@link ApplicationOptions} For all available initialization options\n * @see {@link Container} For information about the stage container\n * @see {@link Renderer} For details about the rendering system\n */\nexport class Application<R extends Renderer = Renderer>\n{\n    /**\n     * Collection of installed plugins.\n     * @internal\n     */\n    public static _plugins: ApplicationPlugin[] = [];\n\n    /**\n     * The root display container for your application.\n     * All visual elements should be added to this container or its children.\n     * @example\n     * ```js\n     * // Create a sprite and add it to the stage\n     * const sprite = Sprite.from('image.png');\n     * app.stage.addChild(sprite);\n     *\n     * // Create a container for grouping objects\n     * const container = new Container();\n     * app.stage.addChild(container);\n     * ```\n     */\n    public stage: Container = new Container();\n\n    /**\n     * The renderer instance that handles all drawing operations.\n     *\n     * Unless specified, it will automatically create a WebGL renderer if available.\n     * If WebGPU is available and the `preference` is set to `webgpu`, it will create a WebGPU renderer.\n     * @example\n     * ```js\n     * // Create a new application\n     * const app = new Application();\n     * await app.init({\n     *     width: 800,\n     *     height: 600,\n     *     preference: 'webgl', // or 'webgpu'\n     * });\n     *\n     * // Access renderer properties\n     * console.log(app.renderer.width, app.renderer.height);\n     * ```\n     */\n    public renderer: R;\n\n    /** Create new Application instance */\n    constructor();\n\n    /** @deprecated since 8.0.0 */\n    constructor(options?: Partial<ApplicationOptions>);\n\n    constructor(...args: [Partial<ApplicationOptions>] | [])\n    {\n        // #if _DEBUG\n        if (args[0] !== undefined)\n        {\n            deprecation(v8_0_0, 'Application constructor options are deprecated, please use Application.init() instead.');\n        }\n        // #endif\n    }\n\n    /**\n     * Initializes the PixiJS application with the specified options.\n     *\n     * This method must be called after creating a new Application instance.\n     * @param options - Configuration options for the application and renderer\n     * @returns A promise that resolves when initialization is complete\n     * @example\n     * ```js\n     * const app = new Application();\n     *\n     * // Initialize with custom options\n     * await app.init({\n     *     width: 800,\n     *     height: 600,\n     *     backgroundColor: 0x1099bb,\n     *     preference: 'webgl', // or 'webgpu'\n     * });\n     * ```\n     */\n    public async init(options?: Partial<ApplicationOptions>)\n    {\n        // The default options\n        options = { ...options };\n\n        this.renderer = await autoDetectRenderer(options as ApplicationOptions) as R;\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /**\n     * Renders the current stage to the screen.\n     *\n     * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call\n     * this method directly as rendering is handled automatically.\n     *\n     * Only use this method if you've disabled the {@link TickerPlugin} or need custom\n     * render timing control.\n     * @example\n     * ```js\n     * // Example 1: Default setup (TickerPlugin handles rendering)\n     * const app = new Application();\n     * await app.init();\n     * // No need to call render() - TickerPlugin handles it\n     *\n     * // Example 2: Custom rendering loop (if TickerPlugin is disabled)\n     * const app = new Application();\n     * await app.init({ autoStart: false }); // Disable automatic rendering\n     *\n     * function animate() {\n     *     app.render();\n     *     requestAnimationFrame(animate);\n     * }\n     * animate();\n     * ```\n     */\n    public render(): void\n    {\n        this.renderer.render({ container: this.stage });\n    }\n\n    /**\n     * Reference to the renderer's canvas element. This is the HTML element\n     * that displays your application's graphics.\n     * @readonly\n     * @type {HTMLCanvasElement}\n     * @example\n     * ```js\n     * // Create a new application\n     * const app = new Application();\n     * // Initialize the application\n     * await app.init({...});\n     * // Add canvas to the page\n     * document.body.appendChild(app.canvas);\n     *\n     * // Access the canvas directly\n     * console.log(app.canvas); // HTMLCanvasElement\n     * ```\n     */\n    get canvas(): R['canvas']\n    {\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @type {HTMLCanvasElement}\n     * @deprecated since 8.0.0\n     * @see {@link Application#canvas}\n     */\n    get view(): R['canvas']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.');\n        // #endif\n\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. This represents the visible area of your application.\n     *\n     * It's commonly used for:\n     * - Setting filter areas for full-screen effects\n     * - Defining hit areas for screen-wide interaction\n     * - Determining the visible bounds of your application\n     * @readonly\n     * @example\n     * ```js\n     * // Use as filter area for a full-screen effect\n     * const blurFilter = new BlurFilter();\n     * sprite.filterArea = app.screen;\n     *\n     * // Use as hit area for screen-wide interaction\n     * const screenSprite = new Sprite();\n     * screenSprite.hitArea = app.screen;\n     *\n     * // Get screen dimensions\n     * console.log(app.screen.width, app.screen.height);\n     * ```\n     * @see {@link Rectangle} For all available properties and methods\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroys the application and all of its resources.\n     *\n     * This method should be called when you want to completely\n     * clean up the application and free all associated memory.\n     * @param rendererDestroyOptions - Options for destroying the renderer:\n     *  - `false` or `undefined`: Preserves the canvas element (default)\n     *  - `true`: Removes the canvas element\n     *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal\n     * @param options - Options for destroying the application:\n     *  - `false` or `undefined`: Basic cleanup (default)\n     *  - `true`: Complete cleanup including children\n     *  - Detailed options object:\n     *    - `children`: Remove children\n     *    - `texture`: Destroy textures\n     *    - `textureSource`: Destroy texture sources\n     *    - `context`: Destroy WebGL context\n     * @example\n     * ```js\n     * // Basic cleanup\n     * app.destroy();\n     *\n     * // Remove canvas and do complete cleanup\n     * app.destroy(true, true);\n     *\n     * // Remove canvas with explicit options\n     * app.destroy({ removeView: true }, true);\n     *\n     * // Detailed cleanup with specific options\n     * app.destroy(\n     *     { removeView: true },\n     *     {\n     *         children: true,\n     *         texture: true,\n     *         textureSource: true,\n     *         context: true\n     *     }\n     * );\n     * ```\n     * > [!WARNING] After calling destroy, the application instance should no longer be used.\n     * > All properties will be null and further operations will throw errors.\n     */\n    public destroy(rendererDestroyOptions: RendererDestroyOptions = false, options: DestroyOptions = false): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(options);\n        this.stage = null;\n\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n", "import { groupD8 } from '../../maths/matrix/groupD8';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { BitmapFontManager } from './BitmapFontManager';\n\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\nimport type { BitmapFontData } from './AbstractBitmapFont';\nimport type { BitmapFontInstallOptions } from './BitmapFontManager';\n\n/**\n * Options for creating a BitmapFont. Used when loading or creating bitmap fonts from existing textures and data.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     // Font data containing character metrics and layout info\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *             // ... other characters\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         // Optional distance field info for MSDF/SDF fonts\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     // Array of textures containing the font glyphs\n *     textures: [\n *         Texture.from('font.png')\n *     ]\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontOptions\n{\n    /**\n     * The bitmap font data containing character metrics, layout information,\n     * and font properties. This includes character positions, dimensions,\n     * kerning data, and general font settings.\n     */\n    data: BitmapFontData;\n\n    /**\n     * Array of textures containing the font glyphs. Each texture corresponds\n     * to a page in the font data. For simple fonts this is typically just\n     * one texture, but complex fonts may split glyphs across multiple textures.\n     */\n    textures: Texture[];\n}\n\n/**\n * A BitmapFont object represents a particular font face, size, and style.\n * This class handles both pre-loaded bitmap fonts and dynamically generated ones.\n * @example\n * ```ts\n * import { BitmapFont, Texture } from 'pixi.js';\n *\n * // Create a bitmap font from loaded textures and data\n * const font = new BitmapFont({\n *     data: {\n *         pages: [{ id: 0, file: 'font.png' }],\n *         chars: {\n *             '65': { // 'A'\n *                 id: 65,\n *                 page: 0,\n *                 x: 0,\n *                 y: 0,\n *                 width: 32,\n *                 height: 32,\n *                 xOffset: 0,\n *                 yOffset: 0,\n *                 xAdvance: 32,\n *                 letter: 'A'\n *             }\n *         },\n *         fontSize: 32,\n *         lineHeight: 36,\n *         baseLineOffset: 26,\n *         fontFamily: 'MyFont',\n *         distanceField: {\n *             type: 'msdf',\n *             range: 4\n *         }\n *     },\n *     textures: [Texture.from('font.png')]\n * });\n *\n * // Install a font for global use\n * BitmapFont.install({\n *     name: 'MyCustomFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ffffff',\n *         stroke: { color: '#000000', width: 2 }\n *     }\n * });\n *\n * // Uninstall when no longer needed\n * BitmapFont.uninstall('MyCustomFont');\n * ```\n * @category text\n * @standard\n */\nexport class BitmapFont extends AbstractBitmapFont<BitmapFont>\n{\n    /**\n     * The URL from which the font was loaded, if applicable.\n     * This is useful for tracking font sources and reloading.\n     * @example\n     * ```ts\n     * console.log(font.url); // 'fonts/myFont.fnt'\n     * ```\n     */\n    public url?: string;\n\n    constructor(options: BitmapFontOptions, url?: string)\n    {\n        super();\n\n        const { textures, data } = options;\n\n        Object.keys(data.pages).forEach((key: string) =>\n        {\n            const pageData = data.pages[parseInt(key, 10)];\n\n            const texture = textures[pageData.id];\n\n            this.pages.push({ texture });\n        });\n\n        Object.keys(data.chars).forEach((key: string) =>\n        {\n            const charData = data.chars[key];\n            const {\n                frame: textureFrame,\n                source: textureSource,\n                rotate: textureRotate,\n            } = textures[charData.page];\n\n            // Transform character coordinates based on texture rotation\n            const frame = groupD8.transformRectCoords(\n                charData,\n                textureFrame,\n                textureRotate,\n                new Rectangle()\n            );\n\n            const texture = new Texture({\n                frame,\n                orig: new Rectangle(0, 0, charData.width, charData.height),\n                source: textureSource,\n                rotate: textureRotate,\n            });\n\n            this.chars[key] = {\n                id: key.codePointAt(0),\n                xOffset: charData.xOffset,\n                yOffset: charData.yOffset,\n                xAdvance: charData.xAdvance,\n                kerning: charData.kerning ?? {},\n                texture,\n            };\n        });\n\n        this.baseRenderedFontSize = data.fontSize;\n\n        (this.baseMeasurementFontSize as number) = data.fontSize;\n        (this.fontMetrics as FontMetrics) = {\n            ascent: 0,\n            descent: 0,\n            fontSize: data.fontSize,\n        };\n        (this.baseLineOffset as number) = data.baseLineOffset;\n        (this.lineHeight as number) = data.lineHeight;\n        (this.fontFamily as string) = data.fontFamily;\n        (this.distanceField as { type: string, range: number }) = data.distanceField ?? {\n            type: 'none',\n            range: 0,\n        };\n\n        this.url = url;\n    }\n\n    /** Destroys the BitmapFont object. */\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { texture } = this.pages[i];\n\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n\n    /**\n     * Generates and installs a bitmap font with the specified options.\n     * The font will be cached and available for use in BitmapText objects.\n     * @param options - Setup options for font generation\n     * @returns Installed font instance\n     * @example\n     * ```ts\n     * // Install a basic font\n     * BitmapFont.install({\n     *     name: 'Title',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: '#ffffff'\n     *     }\n     * });\n     *\n     * // Install with advanced options\n     * BitmapFont.install({\n     *     name: 'Custom',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 24,\n     *         fill: '#00ff00',\n     *         stroke: { color: '#000000', width: 2 }\n     *     },\n     *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],\n     *     resolution: 2,\n     *     padding: 4,\n     *     textureStyle: {\n     *         scaleMode: 'nearest'\n     *     }\n     * });\n     * ```\n     */\n    public static install(options: BitmapFontInstallOptions)\n    {\n        BitmapFontManager.install(options);\n    }\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * This frees up memory and resources associated with the font.\n     * @param name - The name of the bitmap font to uninstall\n     * @example\n     * ```ts\n     * // Remove a font when it's no longer needed\n     * BitmapFont.uninstall('MyCustomFont');\n     *\n     * // Clear multiple fonts\n     * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);\n     * ```\n     */\n    public static uninstall(name: string)\n    {\n        BitmapFontManager.uninstall(name);\n    }\n}\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/**\n * Internal data format used to convert to BitmapFontData.\n * @private\n */\nexport interface BitmapFontRawData\n{\n    info: {\n        face: string;\n        size: string;\n    }[];\n    common: { lineHeight: string, base: string }[];\n    page: {\n        id: string;\n        file: string;\n    }[];\n    chars: {\n        count: number;\n    }[];\n    char: {\n        id: string\n        page: string\n        xoffset: string\n        yoffset: string\n        xadvance: string,\n        x: string\n        y: string\n        width: string\n        height: string\n        letter?: string\n        char?: string\n    }[];\n    kernings?: {\n        count: number;\n    }[];\n    kerning?: {\n        first: string;\n        second: string;\n        amount: string;\n    }[];\n    distanceField?: {\n        fieldType: 'sdf' | 'msdf' | 'none';\n        distanceRange: string;\n    }[]\n}\n\n/** @internal */\nexport const bitmapFontTextParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        return typeof data === 'string' && data.startsWith('info face=');\n    },\n\n    parse(txt: string): BitmapFontData\n    {\n        // Retrieve data item\n        const items = txt.match(/^[a-z]+\\s+.+$/gm);\n        const rawData: BitmapFontRawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n            distanceField: [],\n        };\n\n        for (const i in items)\n        {\n            // Extract item name\n            const name = items[i].match(/^[a-z]+/gm)[0] as keyof BitmapFontRawData;\n\n            // Extract item attribute list as string ex.: \"width=10\"\n            const attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n\n            // Convert attribute list into an object\n            const itemData: any = {};\n\n            for (const i in attributeList)\n            {\n                // Split key-value pairs\n                const split = attributeList[i].split('=');\n                const key = split[0];\n\n                // Remove eventual quotes from value\n                const strValue = split[1].replace(/\"/gm, '');\n\n                // Try to convert value into float\n                const floatValue = parseFloat(strValue);\n\n                // Use string value case float value is NaN\n                const value = isNaN(floatValue) ? strValue : floatValue;\n\n                itemData[key] = value;\n            }\n\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n\n        const font: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const [info] = rawData.info;\n        const [common] = rawData.common;\n        const [distanceField] = rawData.distanceField ?? [];\n\n        if (distanceField)\n        {\n            font.distanceField = {\n                range: parseInt(distanceField.distanceRange, 10),\n                type: distanceField.fieldType\n            };\n        }\n\n        font.fontSize = parseInt(info.size, 10);\n        font.fontFamily = info.face;\n        font.lineHeight = parseInt(common.lineHeight, 10);\n\n        const page = rawData.page;\n\n        for (let i = 0; i < page.length; i++)\n        {\n            font.pages.push({\n                id: parseInt(page[i].id, 10) || 0,\n                file: page[i].file,\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        font.baseLineOffset = font.lineHeight - parseInt(common.base, 10);\n\n        const char = rawData.char;\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.id, 10);\n\n            let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            font.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.page, 10) || 0,\n                x: parseInt(charNode.x, 10),\n                y: parseInt(charNode.y, 10),\n                width: parseInt(charNode.width, 10),\n                height: parseInt(charNode.height, 10),\n                xOffset: parseInt(charNode.xoffset, 10),\n                yOffset: parseInt(charNode.yoffset, 10),\n                xAdvance: parseInt(charNode.xadvance, 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        const kerning = rawData.kerning || [];\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].first, 10);\n            const second = parseInt(kerning[i].second, 10);\n            const amount = parseInt(kerning[i].amount, 10);\n\n            font.chars[map[second]].kerning[map[first]] = amount;\n        }\n\n        return font;\n    }\n};\n", "import type { BitmapFontData, RawCharData } from '../AbstractBitmapFont';\n\n/** @internal */\nexport const bitmapFontXMLParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        const xml = data as Document;\n\n        return typeof xml !== 'string'\n            && 'getElementsByTagName' in xml\n            && xml.getElementsByTagName('page').length\n            && xml.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    },\n\n    parse(xml: Document): BitmapFontData\n    {\n        const data: BitmapFontData = {\n            chars: {},\n            pages: [],\n            lineHeight: 0,\n            fontSize: 0,\n            fontFamily: '',\n            distanceField: null,\n            baseLineOffset: 0,\n        };\n\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const distanceField = xml.getElementsByTagName('distanceField')[0];\n\n        if (distanceField)\n        {\n            data.distanceField = {\n                type: distanceField.getAttribute('fieldType') as 'sdf' | 'msdf' | 'none',\n                range: parseInt(distanceField.getAttribute('distanceRange'), 10),\n            };\n        }\n\n        // pages and chars:\n        const page = xml.getElementsByTagName('page');\n        const char = xml.getElementsByTagName('char');\n        const kerning = xml.getElementsByTagName('kerning');\n\n        data.fontSize = parseInt(info.getAttribute('size'), 10);\n        data.fontFamily = info.getAttribute('face');\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);\n\n        for (let i = 0; i < page.length; i++)\n        {\n            data.pages.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n\n        const map: Record<string, string> = {};\n\n        data.baseLineOffset = data.lineHeight - parseInt(common.getAttribute('base'), 10);\n\n        for (let i = 0; i < char.length; i++)\n        {\n            const charNode = char[i];\n            const id = parseInt(charNode.getAttribute('id'), 10);\n\n            let letter = charNode.getAttribute('letter') ?? charNode.getAttribute('char') ?? String.fromCharCode(id);\n\n            if (letter === 'space')letter = ' ';\n\n            map[id] = letter;\n\n            data.chars[letter] = {\n                id,\n                // texture deets..\n                page: parseInt(charNode.getAttribute('page'), 10) || 0,\n                x: parseInt(charNode.getAttribute('x'), 10),\n                y: parseInt(charNode.getAttribute('y'), 10),\n                width: parseInt(charNode.getAttribute('width'), 10),\n                height: parseInt(charNode.getAttribute('height'), 10),\n\n                // render deets..\n                xOffset: parseInt(charNode.getAttribute('xoffset'), 10),\n                yOffset: parseInt(charNode.getAttribute('yoffset'), 10), // + baseLineOffset,\n                xAdvance: parseInt(charNode.getAttribute('xadvance'), 10),\n                kerning: {},\n            } as RawCharData;\n        }\n\n        for (let i = 0; i < kerning.length; i++)\n        {\n            const first = parseInt(kerning[i].getAttribute('first'), 10);\n            const second = parseInt(kerning[i].getAttribute('second'), 10);\n            const amount = parseInt(kerning[i].getAttribute('amount'), 10);\n\n            data.chars[map[second]].kerning[map[first]] = amount;// * 10000;\n        }\n\n        return data;\n    }\n};\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { bitmapFontXMLParser } from './bitmapFontXMLParser';\n\nimport type { BitmapFontData } from '../AbstractBitmapFont';\n\n/** @internal */\nexport const bitmapFontXMLStringParser = {\n    test(data: string | XMLDocument | BitmapFontData): boolean\n    {\n        if (typeof data === 'string' && data.includes('<font>'))\n        {\n            return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));\n        }\n\n        return false;\n    },\n\n    parse(data: string): BitmapFontData\n    {\n        return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));\n    }\n};\n", "import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { CacheParser } from '../../../assets/cache/CacheParser';\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParserAdvanced } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/**\n * simple loader plugin for loading in bitmap fonts!\n * @category assets\n * @internal\n */\nexport const bitmapFontCachePlugin = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheBitmapFont',\n    },\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n            out[`${key}-bitmap`] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n} satisfies CacheParser<BitmapFont>;\n\n/**\n * Loader plugin for loading bitmap fonts.\n * It supports both XML and text formats, and can handle distance field fonts.\n * @category assets\n * @advanced\n */\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadBitmapFont',\n    id: 'bitmap-font',\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        // if we have a distance field - we can assume this is a signed distance field font\n        // and we should use force linear filtering and no alpha premultiply\n        const textureOptions = (bitmapFontData.distanceField) ? {\n            scaleMode: 'linear',\n            alphaMode: 'premultiply-alpha-on-upload',\n            autoGenerateMipmaps: false,\n            resolution: 1,\n        } : {};\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push({\n                src: imagePath,\n                data: textureOptions\n            });\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url.src]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} satisfies LoaderParserAdvanced<string, BitmapFont, BitmapFont>;\n", "import type { Loader } from './loader/Loader';\nimport type { ResolvedAsset } from './types';\n\n/**\n * The BackgroundLoader handles loading assets passively in the background to prepare them for future use.\n * It loads one asset at a time to minimize impact on application performance.\n *\n * Key features:\n * - Sequential loading of assets\n * - Automatic pause when high-priority loads occur\n * - Configurable concurrency\n * @example\n * ```ts\n * import { Assets } from 'pixi.js';\n *\n * // Background load level assets while in menu\n * Assets.backgroundLoad([\n *     'level1/background.png',\n *     'level1/sprites.json',\n *     'level1/music.mp3'\n * ]);\n *\n * // Assets will be instantly available when needed\n * const assets = await Assets.load([\n *     'level1/background.png',\n *     'level1/sprites.json'\n * ]);\n *\n * // Background load bundles\n * Assets.backgroundLoadBundle('level2');\n *\n * // Later, instant access\n * const level2 = await Assets.loadBundle('level2');\n * ```\n * > [!NOTE] You typically do not need to use this class directly. Use the main {@link Assets.backgroundLoad} API instead.\n * @remarks\n * - Background loading is automatically paused when `Assets.load()` is called\n * - Assets are loaded sequentially to minimize performance impact\n * - Assets are cached as they complete loading\n * - No progress tracking is available for background loading\n * @see {@link Assets.backgroundLoad} For the main background loading API\n * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n * @category assets\n * @advanced\n */\nexport class BackgroundLoader\n{\n    /** Whether or not the loader should continue loading. */\n    private _isActive: boolean;\n\n    /** Assets to load. */\n    private readonly _assetList: ResolvedAsset[];\n\n    /** Whether or not the loader is loading. */\n    private _isLoading: boolean;\n\n    /** Number of assets to load at a time. */\n    private readonly _maxConcurrent: number;\n\n    /**\n     * Should the loader log to the console.\n     * @advanced\n     */\n    public verbose: boolean;\n    private readonly _loader: Loader;\n\n    /**\n     * @param loader\n     * @param verbose - should the loader log to the console\n     */\n    constructor(loader: Loader, verbose = false)\n    {\n        this._loader = loader;\n        this._assetList = [];\n        this._isLoading = false;\n        this._maxConcurrent = 1;\n        this.verbose = verbose;\n    }\n\n    /**\n     * Adds assets to the background loading queue. Assets are loaded one at a time to minimize\n     * performance impact.\n     * @param assetUrls - Array of resolved assets to load in the background\n     * @example\n     * ```ts\n     * // Add assets to background load queue\n     * backgroundLoader.add([\n     *     { src: 'images/level1/bg.png' },\n     *     { src: 'images/level1/characters.json' }\n     * ]);\n     *\n     * // Assets will load sequentially in the background\n     * // The loader automatically pauses when high-priority loads occur\n     * // e.g. Assets.load() is called\n     * ```\n     * @remarks\n     * - Assets are loaded one at a time to minimize performance impact\n     * - Loading automatically pauses when Assets.load() is called\n     * - No progress tracking is available for background loading\n     * - Assets are cached as they complete loading\n     * @internal\n     */\n    public add(assetUrls: ResolvedAsset[]): void\n    {\n        assetUrls.forEach((a) =>\n        {\n            this._assetList.push(a);\n        });\n\n        if (this.verbose)\n        {\n            // eslint-disable-next-line no-console\n            console.log('[BackgroundLoader] assets: ', this._assetList);\n        }\n\n        if (this._isActive && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n\n    /**\n     * Loads the next set of assets. Will try to load as many assets as it can at the same time.\n     *\n     * The max assets it will try to load at one time will be 4.\n     */\n    private async _next(): Promise<void>\n    {\n        if (this._assetList.length && this._isActive)\n        {\n            this._isLoading = true;\n\n            const toLoad = [];\n\n            const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);\n\n            for (let i = 0; i < toLoadAmount; i++)\n            {\n                toLoad.push(this._assetList.pop());\n            }\n\n            await this._loader.load(toLoad);\n\n            this._isLoading = false;\n\n            void this._next();\n        }\n    }\n\n    /**\n     * Controls the active state of the background loader. When active, the loader will\n     * continue processing its queue. When inactive, loading is paused.\n     * @returns Whether the background loader is currently active\n     * @example\n     * ```ts\n     * // Pause background loading\n     * backgroundLoader.active = false;\n     *\n     * // Resume background loading\n     * backgroundLoader.active = true;\n     *\n     * // Check current state\n     * console.log(backgroundLoader.active); // true/false\n     *\n     * // Common use case: Pause during intensive operations\n     * backgroundLoader.active = false;  // Pause background loading\n     * ... // Perform high-priority tasks\n     * backgroundLoader.active = true;   // Resume background loading\n     * ```\n     * @remarks\n     * - Setting to true resumes loading immediately\n     * - Setting to false pauses after current asset completes\n     * - Background loading is automatically paused during `Assets.load()`\n     * - Assets already being loaded will complete even when set to false\n     */\n    public get active(): boolean\n    {\n        return this._isActive;\n    }\n\n    set active(value: boolean)\n    {\n        if (this._isActive === value) return;\n\n        this._isActive = value;\n\n        if (value && !this._isLoading)\n        {\n            void this._next();\n        }\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nimport type { CacheParser } from '../CacheParser';\n\n/**\n * Returns an object of textures from an array of textures to be cached\n * @category assets\n * @internal\n */\nexport const cacheTextureArray: CacheParser<Texture[]> = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheTextureArray',\n    },\n\n    test: (asset: any[]) => Array.isArray(asset) && asset.every((t) => t instanceof Texture),\n\n    getCacheableAssets: (keys: string[], asset: Texture[]) =>\n    {\n        const out: Record<string, Texture> = {};\n\n        keys.forEach((key: string) =>\n        {\n            asset.forEach((item: Texture, i: number) =>\n            {\n                out[key + (i === 0 ? '' : i + 1)] = item;\n            });\n        });\n\n        return out;\n    }\n};\n", "/**\n * @param imageData\n * @internal\n */\nexport async function testImageFormat(imageData: string): Promise<boolean>\n{\n    // Some browsers currently do not support createImageBitmap with Blob, so new Image() is preferred when exist.\n    // See https://caniuse.com/createimagebitmap for more information.\n\n    if ('Image' in globalThis)\n    {\n        return new Promise<boolean>((resolve) =>\n        {\n            // eslint-disable-next-line no-restricted-globals\n            const image = new Image();\n\n            image.onload = () =>\n            {\n                resolve(true);\n            };\n            image.onerror = () =>\n            {\n                resolve(false);\n            };\n            image.src = imageData;\n        });\n    }\n\n    if ('createImageBitmap' in globalThis && 'fetch' in globalThis)\n    {\n        try\n        {\n            const blob = await (await fetch(imageData)).blob();\n\n            await createImageBitmap(blob);\n        }\n        catch (_e)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the AVIF image format.\n * @category assets\n * @internal\n */\nexport const detectAvif: FormatDetectionParser = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 1,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        // eslint-disable-next-line max-len\n        'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A='\n    ),\n    add: async (formats) => [...formats, 'avif'],\n    remove: async (formats) => formats.filter((f) => f !== 'avif'),\n};\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { FormatDetectionParser } from '../types';\n\nconst imageFormats = ['png', 'jpg', 'jpeg'];\n\n/**\n * Adds some default image formats to the detection parser\n * @category assets\n * @internal\n */\nexport const detectDefaults = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: -1,\n    },\n    test: (): Promise<boolean> => Promise.resolve(true),\n    add: async (formats) => [...formats, ...imageFormats],\n    remove: async (formats) => formats.filter((f) => !imageFormats.includes(f)),\n} as FormatDetectionParser;\n", "/* eslint-disable no-restricted-globals */\nconst inWorker = 'WorkerGlobalScope' in globalThis\n    && globalThis instanceof (globalThis as any).WorkerGlobalScope;\n\n/**\n * @param mimeType\n * @internal\n */\nexport function testVideoFormat(mimeType: string): boolean\n{\n    if (inWorker)\n    {\n        return false;\n    }\n\n    const video = document.createElement('video');\n\n    return video.canPlayType(mimeType) !== '';\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the MP4 video format.\n * @category assets\n * @internal\n */\nexport const detectMp4 = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/mp4'),\n    add: async (formats) => [...formats, 'mp4', 'm4v'],\n    remove: async (formats) => formats.filter((f) => f !== 'mp4' && f !== 'm4v'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the OGV video format.\n * @category assets\n * @internal\n */\nexport const detectOgv = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/ogg'),\n    add: async (formats) => [...formats, 'ogv'],\n    remove: async (formats) => formats.filter((f) => f !== 'ogv'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testVideoFormat } from '../utils/testVideoFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebM video format.\n * @category assets\n * @internal\n */\nexport const detectWebm = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testVideoFormat('video/webm'),\n    add: async (formats) => [...formats, 'webm'],\n    remove: async (formats) => formats.filter((f) => f !== 'webm'),\n} as FormatDetectionParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { testImageFormat } from '../utils/testImageFormat';\n\nimport type { FormatDetectionParser } from '../types';\n\n/**\n * Detects if the browser supports the WebP image format.\n * @category assets\n * @internal\n */\nexport const detectWebp = {\n    extension: {\n        type: ExtensionType.DetectionParser,\n        priority: 0,\n    },\n    test: async (): Promise<boolean> => testImageFormat(\n        'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA='\n    ),\n    add: async (formats) => [...formats, 'webp'],\n    remove: async (formats) => formats.filter((f) => f !== 'webp'),\n} as FormatDetectionParser;\n", "import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { type ProgressCallback } from '../Assets';\nimport { convertToList } from '../utils/convertToList';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type { ResolvedAsset } from '../types';\nimport type { LoaderParser } from './parsers/LoaderParser';\nimport type { PromiseAndParser } from './types';\n\n/**\n * Options for loading assets with the Loader\n * @example\n * ```ts\n * await Assets.load(['file1.png', 'file2.png'], {\n *   onProgress: (progress) => console.log(`Progress: ${progress * 100}%`),\n *   onError: (error, url) => console.error(`Error loading ${url}: ${error.message}`),\n *   strategy: 'retry', // 'throw' | 'skip' | 'retry'\n *   retryCount: 5, // Number of retry attempts if strategy is 'retry'\n *   retryDelay: 500, // Delay in ms between retries\n * });\n * ```\n * @category assets\n * @standard\n */\nexport interface LoadOptions\n{\n    /**\n     * Callback for progress updates during loading\n     * @param progress - A number between 0 and 1 indicating the load progress\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   onProgress: (progress) => {\n     *     console.log(`Loading progress: ${progress * 100}%`);\n     *   },\n     * };\n     * await Assets.load('image.png', options);\n     * ```\n     */\n    onProgress?: (progress: number) => void;\n    /**\n     * Callback for handling errors during loading\n     * @param error - The error that occurred\n     * @param url - The URL of the asset that failed to load\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   onError: (error, url) => {\n     *     console.error(`Failed to load ${url}: ${error.message}`);\n     *   },\n     * };\n     * await Assets.load('missing-file.png', options);\n     * ```\n     */\n    onError?: (error: Error, url: string | ResolvedAsset) => void;\n    /**\n     * Strategy to handle load failures\n     * - 'throw': Immediately throw an error and stop loading (default)\n     * - 'skip': Skip the failed asset and continue loading others\n     * - 'retry': Retry loading the asset a specified number of times\n     * @default 'throw'\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   strategy: 'skip',\n     * };\n     * await Assets.load('sometimes-fails.png', options);\n     * ```\n     */\n    strategy?: 'throw' | 'skip' | 'retry';\n    /**\n     * Number of retry attempts if strategy is 'retry'\n     * @default 3\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   strategy: 'retry',\n     *   retryCount: 5, // Retry up to 5 times\n     * };\n     * await Assets.load('unstable-asset.png', options);\n     * ```\n     */\n    retryCount?: number;\n    /**\n     * Delay in milliseconds between retry attempts\n     * @default 250\n     * @example\n     * ```ts\n     * const options: LoadOptions = {\n     *   strategy: 'retry',\n     *   retryDelay: 1000, // Wait 1 second between retries\n     * };\n     * await Assets.load('sometimes-fails.png', options);\n     * ```\n     */\n    retryDelay?: number;\n}\n\n/**\n * The Loader is responsible for loading all assets, such as images, spritesheets, audio files, etc.\n * It does not do anything clever with URLs - it just loads stuff!\n * Behind the scenes all things are cached using promises. This means it's impossible to load an asset more than once.\n * Through the use of LoaderParsers, the loader can understand how to load any kind of file!\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the second major system of PixiJS' main Assets class\n * @category assets\n * @advanced\n */\nexport class Loader\n{\n    /**\n     * Default options for loading assets\n     * @example\n     * ```ts\n     * // Change default load options globally\n     * Loader.defaultOptions = {\n     *   strategy: 'skip', // Change default strategy to 'skip'\n     *   retryCount: 5,   // Change default retry count to 5\n     *   retryDelay: 500, // Change default retry delay to 500ms\n     * };\n     * ```\n     */\n    public static defaultOptions: LoadOptions = {\n        onProgress: undefined,\n        onError: undefined,\n        strategy: 'throw',\n        retryCount: 3,\n        retryDelay: 250,\n    };\n    /**\n     * Options for loading assets with the loader.\n     * These options will be used as defaults for all load calls made with this loader instance.\n     * They can be overridden by passing options directly to the load method.\n     * @example\n     * ```ts\n     * // Create a loader with custom default options\n     * const loader = new Loader();\n     * loader.loadOptions = {\n     *   strategy: 'skip', // Default strategy to 'skip'\n     *   retryCount: 5,   // Default retry count to 5\n     *   retryDelay: 500, // Default retry delay to 500ms\n     * };\n     *\n     * // This load call will use the loader's default options\n     * await loader.load('image1.png');\n     */\n    public loadOptions: LoadOptions = { ...Loader.defaultOptions };\n    private readonly _parsers: LoaderParser[] = [];\n    private _parserHash: Record<string, LoaderParser>;\n\n    private _parsersValidated = false;\n\n    /**\n     * All loader parsers registered\n     * @type {assets.LoaderParser[]}\n     */\n    public parsers = new Proxy(this._parsers, {\n        set: (target, key, value) =>\n        {\n            this._parsersValidated = false;\n\n            target[key as any as number] = value;\n\n            return true;\n        }\n    });\n\n    /** Cache loading promises that ae currently active */\n    public promiseCache: Record<string, PromiseAndParser> = {};\n\n    /** function used for testing */\n    public reset(): void\n    {\n        this._parsersValidated = false;\n        this.promiseCache = {};\n    }\n\n    /**\n     * Used internally to generate a promise for the asset to be loaded.\n     * @param url - The URL to be loaded\n     * @param data - any custom additional information relevant to the asset being loaded\n     * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object\n     */\n    private _getLoadPromiseAndParser(url: string, data?: ResolvedAsset): PromiseAndParser\n    {\n        const result: PromiseAndParser = {\n            promise: null,\n            parser: null\n        };\n\n        result.promise = (async () =>\n        {\n            let asset = null;\n\n            let parser: LoaderParser = null;\n\n            // first check to see if the user has specified a parser\n            if (data.parser || data.loadParser)\n            {\n                // they have? lovely, lets use it\n                parser = this._parserHash[data.parser || data.loadParser];\n\n                // #if _DEBUG\n                if (data.loadParser)\n                {\n                    warn(\n                        `[Assets] \"loadParser\" is deprecated, use \"parser\" instead for ${url}`\n                    );\n                }\n                // #endif\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    warn(\n                        `[Assets] specified load parser \"${data.parser || data.loadParser}\" not found while loading ${url}`\n                    );\n                    // #endif\n                }\n            }\n\n            // no parser specified, so lets try and find one using the tests\n            if (!parser)\n            {\n                for (let i = 0; i < this.parsers.length; i++)\n                {\n                    const parserX = this.parsers[i];\n\n                    if (parserX.load && parserX.test?.(url, data, this))\n                    {\n                        parser = parserX;\n                        break;\n                    }\n                }\n\n                if (!parser)\n                {\n                    // #if _DEBUG\n                    // eslint-disable-next-line max-len\n                    warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);\n                    // #endif\n\n                    return null;\n                }\n            }\n\n            asset = await parser.load(url, data, this);\n            result.parser = parser;\n\n            for (let i = 0; i < this.parsers.length; i++)\n            {\n                const parser = this.parsers[i];\n\n                if (parser.parse)\n                {\n                    if (parser.parse && await parser.testParse?.(asset, data, this))\n                    {\n                        // transform the asset..\n                        asset = await parser.parse(asset, data, this) || asset;\n\n                        result.parser = parser;\n                    }\n                }\n            }\n\n            return asset;\n        })();\n\n        return result;\n    }\n\n    /**\n     * Loads one or more assets using the parsers added to the Loader.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     * console.log(asset);\n     *\n     * // Multiple assets:\n     * const assets = await Loader.load(['cool.png', 'cooler.png']);\n     * console.log(assets);\n     * @param assetsToLoadIn - urls that you want to load, or a single one!\n     * @param onProgress - For multiple asset loading only, an optional function that is called\n     * when progress on asset loading is made. The function is passed a single parameter, `progress`,\n     * which represents the percentage (0.0 - 1.0) of the assets loaded. Do not use this function\n     * to detect when assets are complete and available, instead use the Promise returned by this function.\n     */\n    public async load<T = any>(\n        assetsToLoadIn: string | ResolvedAsset,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T>;\n    public async load<T = any>(\n        assetsToLoadIn: string[] | ResolvedAsset[],\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        assetsToLoadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n        onProgressOrOptions?: ProgressCallback | LoadOptions,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._parsersValidated)\n        {\n            this._validateParsers();\n        }\n\n        const options: LoadOptions = typeof onProgressOrOptions === 'function'\n            ? { ...Loader.defaultOptions, ...this.loadOptions, onProgress: onProgressOrOptions }\n            : { ...Loader.defaultOptions, ...this.loadOptions, ...(onProgressOrOptions || {}) };\n        const { onProgress, onError, strategy, retryCount, retryDelay } = options;\n\n        let count = 0;\n\n        const assets: Record<string, Promise<any>> = {};\n\n        const singleAsset = isSingleItem(assetsToLoadIn);\n\n        const assetsToLoad = convertToList<ResolvedAsset>(assetsToLoadIn, (item) => ({\n            alias: [item],\n            src: item,\n            data: {}\n        }));\n\n        const total = assetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);\n\n        const promises: Promise<void>[] = assetsToLoad.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            if (assets[asset.src]) return;\n\n            await this._loadAssetWithRetry(url, asset, { onProgress, onError, strategy, retryCount, retryDelay }, assets);\n\n            count += (asset.progressSize || 1);\n            if (onProgress) onProgress(count / total);\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? assets[assetsToLoad[0].src] : assets;\n    }\n\n    /**\n     * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.\n     * The parser that created the asset, will be the one that unloads it.\n     * @example\n     * // Single asset:\n     * const asset = await Loader.load('cool.png');\n     *\n     * await Loader.unload('cool.png');\n     *\n     * console.log(asset.destroyed); // true\n     * @param assetsToUnloadIn - urls that you want to unload, or a single one!\n     */\n    public async unload(\n        assetsToUnloadIn: string | string[] | ResolvedAsset | ResolvedAsset[],\n    ): Promise<void>\n    {\n        const assetsToUnload = convertToList<ResolvedAsset>(assetsToUnloadIn, (item) => ({\n            alias: [item],\n            src: item,\n        }));\n\n        const promises: Promise<void>[] = assetsToUnload.map(async (asset: ResolvedAsset) =>\n        {\n            const url = path.toAbsolute(asset.src);\n\n            const loadPromise = this.promiseCache[url];\n\n            if (loadPromise)\n            {\n                const loadedAsset = await loadPromise.promise;\n\n                delete this.promiseCache[url];\n\n                await loadPromise.parser?.unload?.(loadedAsset, asset, this);\n            }\n        });\n\n        await Promise.all(promises);\n    }\n\n    /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */\n    private _validateParsers()\n    {\n        this._parsersValidated = true;\n\n        this._parserHash = this._parsers\n            .filter((parser) => parser.name || parser.id)\n            .reduce((hash, parser) =>\n            {\n                if (!parser.name && !parser.id)\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] parser should have an id`);\n                    // #endif\n                }\n                else if (hash[parser.name] || hash[parser.id])\n                {\n                    // #if _DEBUG\n                    warn(`[Assets] parser id conflict \"${parser.id}\"`);\n                    // #endif\n                }\n\n                // add both name and id to the hash\n                hash[parser.name] = parser;\n                if (parser.id) hash[parser.id] = parser;\n\n                return hash;\n            }, {} as Record<string, LoaderParser>);\n    }\n\n    private async _loadAssetWithRetry(\n        url: string,\n        asset: ResolvedAsset,\n        options: LoadOptions,\n        assets: Record<string, Promise<any>>\n    )\n    {\n        let attempt = 0;\n        const { onError, strategy, retryCount, retryDelay } = options;\n        const wait = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\n        while (true)\n        {\n            try\n            {\n                if (!this.promiseCache[url])\n                {\n                    this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);\n                }\n\n                assets[asset.src] = await this.promiseCache[url].promise;\n\n                return;\n            }\n            catch (e)\n            {\n                // clear cache for a new attempt\n                delete this.promiseCache[url];\n                delete assets[asset.src];\n\n                attempt++;\n\n                const isLast = strategy !== 'retry' || attempt > retryCount;\n\n                if (strategy === 'retry' && !isLast)\n                {\n                    if (onError) onError(e as Error, asset);\n                    await wait(retryDelay);\n                    continue;\n                }\n\n                if (strategy === 'skip')\n                {\n                    if (onError) onError(e as Error, asset);\n\n                    return;\n                }\n\n                // strategy 'throw' or exhausted 'retry'\n                if (onError) onError(e as Error, asset);\n                throw new Error(`[Loader.load] Failed to load ${url}.\\n${e}`);\n            }\n        }\n    }\n}\n", "/**\n * @param url\n * @param mimes\n * @internal\n */\nexport function checkDataUrl(url: string, mimes: string | string[]): boolean\n{\n    if (Array.isArray(mimes))\n    {\n        for (const mime of mimes)\n        {\n            if (url.startsWith(`data:${mime}`)) return true;\n        }\n\n        return false;\n    }\n\n    return url.startsWith(`data:${mimes}`);\n}\n", "import { path } from '../../utils/path';\n\n/**\n * @param url\n * @param extension\n * @internal\n */\nexport function checkExtension(url: string, extension: string | string[]): boolean\n{\n    const tempURL = url.split('?')[0];\n    const ext = path.extname(tempURL).toLowerCase();\n\n    if (Array.isArray(extension))\n    {\n        return extension.includes(ext);\n    }\n\n    return ext === extension;\n}\n\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validJSONExtension = '.json';\nconst validJSONMIME = 'application/json';\n\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadJson = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadJson',\n    id: 'json',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);\n    },\n\n    async load<T>(url: string): Promise<T>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const json = await response.json();\n\n        return json as T;\n    },\n} satisfies LoaderParser<string>;\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { LoaderParser } from './LoaderParser';\n\nconst validTXTExtension = '.txt';\nconst validTXTMIME = 'text/plain';\n\n/**\n * A simple loader plugin for loading text data\n * @category assets\n * @advanced\n */\nexport const loadTxt = {\n\n    /** used for deprecation purposes */\n    name: 'loadTxt',\n    id: 'text',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadTxt',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);\n    },\n\n    async load(url: string): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        const txt = await response.text();\n\n        return txt;\n    },\n} satisfies LoaderParser<string>;\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { warn } from '../../../utils/logging/warn';\nimport { path } from '../../../utils/path';\nimport { Cache } from '../../cache/Cache';\nimport { checkDataUrl } from '../../utils/checkDataUrl';\nimport { checkExtension } from '../../utils/checkExtension';\nimport { LoaderParserPriority } from './LoaderParser';\n\nimport type { ResolvedAsset } from '../../types';\nimport type { LoaderParser } from './LoaderParser';\n\nconst validWeights = [\n    'normal', 'bold',\n    '100', '200', '300', '400', '500', '600', '700', '800', '900',\n];\nconst validFontExtensions = ['.ttf', '.otf', '.woff', '.woff2'];\nconst validFontMIMEs = [\n    'font/ttf',\n    'font/otf',\n    'font/woff',\n    'font/woff2',\n];\n\n/**\n * Cache for font faces\n * @internal\n */\nexport interface FontFaceCache\n{\n    entries: {url: string, faces: FontFace[]}[]\n}\n\n/**\n * Data for loading a font\n * @category assets\n * @advanced\n */\nexport type LoadFontData = {\n    /** Font family name */\n    family: string;\n    /** A set of optional descriptors passed as an object. It can contain any of the descriptors available for @font-face: */\n    display: string;\n    /**\n     * The featureSettings property of the FontFace interface retrieves or sets infrequently used\n     * font features that are not available from a font's variant properties.\n     */\n    featureSettings: string;\n    /** The stretch property of the FontFace interface retrieves or sets how the font stretches. */\n    stretch: string;\n    /** The style property of the FontFace interface retrieves or sets the font's style. */\n    style: string;\n    /**\n     * The unicodeRange property of the FontFace interface retrieves or sets the range of\n     * unicode code points encompassing the font.\n     */\n    unicodeRange: string;\n    /** The variant property of the FontFace interface programmatically retrieves or sets font variant values. */\n    variant: string;\n    /** The weight property of the FontFace interface retrieves or sets the weight of the font. */\n    weights: string[];\n};\n\n/**\n * RegExp for matching CSS <ident-token>. It doesn't consider escape and non-ASCII characters, but enough for us.\n * @see {@link https://www.w3.org/TR/css-syntax-3/#ident-token-diagram}\n */\nconst CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;\n\n/**\n * Return font face name from a file name\n * Ex.: 'fonts/titan-one.woff' turns into 'Titan One'\n * @param url - File url\n * @category assets\n * @internal\n */\nexport function getFontFamilyName(url: string): string\n{\n    const ext = path.extname(url);\n    const name = path.basename(url, ext);\n\n    // Replace dashes by white spaces\n    const nameWithSpaces = name.replace(/(-|_)/g, ' ');\n\n    // Upper case first character of each word\n    const nameTokens = nameWithSpaces.toLowerCase()\n        .split(' ')\n        .map((word) => word.charAt(0).toUpperCase() + word.slice(1));\n\n    let valid = nameTokens.length > 0;\n\n    for (const token of nameTokens)\n    {\n        if (!token.match(CSS_IDENT_TOKEN_REGEX))\n        {\n            valid = false;\n            break;\n        }\n    }\n\n    let fontFamilyName = nameTokens.join(' ');\n\n    if (!valid)\n    {\n        fontFamilyName = `\"${fontFamilyName.replace(/[\\\\\"]/g, '\\\\$&')}\"`;\n    }\n\n    return fontFamilyName;\n}\n\n// See RFC 3986 Chapter 2. Characters\nconst validURICharactersRegex = /^[0-9A-Za-z%:/?#\\[\\]@!\\$&'()\\*\\+,;=\\-._~]*$/;\n\n/**\n * Encode URI only when it contains invalid characters.\n * @param uri - URI to encode.\n */\nfunction encodeURIWhenNeeded(uri: string)\n{\n    if (validURICharactersRegex.test(uri))\n    {\n        return uri;\n    }\n\n    return encodeURI(uri);\n}\n\n/**\n * A loader plugin for handling web fonts\n * @example\n * import { Assets } from 'pixi.js';\n *\n * Assets.load({\n *   alias: 'font',\n *   src: 'fonts/titan-one.woff',\n *   data: {\n *     family: 'Titan One',\n *     weights: ['normal', 'bold'],\n *   }\n * })\n * @category assets\n * @advanced\n */\nexport const loadWebFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadWebFont',\n    id: 'web-font',\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);\n    },\n\n    async load(url: string, options?: ResolvedAsset<LoadFontData>): Promise<FontFace | FontFace[]>\n    {\n        const fonts = DOMAdapter.get().getFontFaceSet();\n\n        if (fonts)\n        {\n            const fontFaces: FontFace[] = [];\n            const name = options.data?.family ?? getFontFamilyName(url);\n            const weights = options.data?.weights?.filter((weight) => validWeights.includes(weight)) ?? ['normal'];\n            const data = options.data ?? {};\n\n            for (let i = 0; i < weights.length; i++)\n            {\n                const weight = weights[i];\n\n                const font = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {\n                    ...data,\n                    weight,\n                });\n\n                await font.load();\n\n                fonts.add(font);\n\n                fontFaces.push(font);\n            }\n\n            if (Cache.has(`${name}-and-url`))\n            {\n                const cached = Cache.get<FontFaceCache>(`${name}-and-url`);\n\n                // If the URL is already cached, we just add the new font faces to the existing cache\n                cached.entries.push({ url, faces: fontFaces });\n            }\n            else\n            {\n                Cache.set<FontFaceCache>(`${name}-and-url`, {\n                    entries: [{ url, faces: fontFaces }],\n                });\n            }\n\n            return fontFaces.length === 1 ? fontFaces[0] : fontFaces;\n        }\n\n        // #if _DEBUG\n        warn('[loadWebFont] FontFace API is not supported. Skipping loading font');\n        // #endif\n\n        return null;\n    },\n\n    unload(font: FontFace | FontFace[]): void\n    {\n        const fonts = Array.isArray(font) ? font : [font];\n\n        // you can only load 1 family at a time, so we can use the first one\n        const fontFamily = fonts[0].family;\n        const cached = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n\n        // find the entry that contains the font faces we want to remove\n        const entry = cached.entries.find((f) => f.faces.some((t) => fonts.indexOf(t) !== -1));\n\n        // remove the font faces from the cache\n        entry.faces = entry.faces.filter((f) => fonts.indexOf(f) === -1);\n\n        // if faces are empty, remove the entry\n        if (entry.faces.length === 0)\n        {\n            cached.entries = cached.entries.filter((f) => f !== entry);\n        }\n\n        // finally remove the font faces from the FontFaceSet\n        fonts.forEach((t) =>\n        {\n            DOMAdapter.get().getFontFaceSet().delete(t);\n        });\n\n        // Clean up cache if no entries remain\n        if (cached.entries.length === 0)\n        {\n            Cache.remove(`${fontFamily}-and-url`);\n        }\n    }\n} satisfies LoaderParser<FontFace | FontFace[]>;\n", "import { Resolver } from '../../assets/resolver/Resolver';\n\n/**\n * get the resolution / device pixel ratio of an asset by looking for the prefix\n * used by spritesheets and image urls\n * @category utils\n * @internal\n * @param {string} url - the image path\n * @param {number} [defaultValue=1] - the defaultValue if no filename prefix is set.\n * @returns {number} resolution / device pixel ratio of an asset\n */\nexport function getResolutionOfUrl(url: string, defaultValue = 1): number\n{\n    const resolution = Resolver.RETINA_PREFIX?.exec(url);\n\n    if (resolution)\n    {\n        return parseFloat(resolution[1]);\n    }\n\n    return defaultValue;\n}\n", "import { Texture } from '../../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../../utils/logging/warn';\nimport { Cache } from '../../../../cache/Cache';\n\nimport type { TextureSource } from '../../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Loader } from '../../../Loader';\n\n/**\n * Creates a texture from a source and adds it to the cache.\n * @param source - source of the texture\n * @param loader - loader\n * @param url - url of the texture\n * @ignore\n */\nexport function createTexture(source: TextureSource, loader: Loader, url: string)\n{\n    source.label = url;\n    source._sourceOrigin = url;\n\n    const texture = new Texture({\n        source,\n        label: url,\n    });\n\n    const unload = () =>\n    {\n        delete loader.promiseCache[url];\n\n        if (Cache.has(url))\n        {\n            Cache.remove(url);\n        }\n    };\n\n    // remove the promise from the loader and the url from the cache when the texture is destroyed\n    texture.source.once('destroy', () =>\n    {\n        if (loader.promiseCache[url])\n        {\n            // #if _DEBUG\n            warn('[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! '\n           + 'Use Assets.unload() instead of destroying the TextureSource.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    texture.once('destroy', () =>\n    {\n        if (!source.destroyed)\n        {\n            // #if _DEBUG\n            warn('[Assets] A Texture managed by Assets was destroyed instead of unloaded! '\n             + 'Use Assets.unload() instead of destroying the Texture.');\n            // #endif\n\n            unload();\n        }\n    });\n\n    return texture;\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { GraphicsContext } from '../../../../scene/graphics/shared/GraphicsContext';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { type LoaderParser, LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\n\n/**\n * Configuration for the {@link loadSvg} plugin.\n * @see loadSvg\n * @category assets\n * @advanced\n */\nexport interface LoadSVGConfig\n{\n    /**\n     * The crossOrigin value to use for loading the SVG as an image.\n     * @default 'anonymous'\n     */\n    crossOrigin: ImageLike['crossOrigin'];\n    /**\n     * When set to `true`, loading and decoding images will happen with `new Image()`,\n     * @default false\n     */\n    parseAsGraphicsContext: boolean;\n}\n\n/**\n * Regular expression for SVG XML document.\n * @example &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!-- image/svg --&gt;&lt;svg\n * @readonly\n */\nconst validSVGExtension = '.svg';\nconst validSVGMIME = 'image/svg+xml';\n\n/**\n * A simple loader plugin for loading json data\n * @category assets\n * @advanced\n */\nexport const loadSvg: LoaderParser<Texture | GraphicsContext, TextureSourceOptions & LoadSVGConfig, LoadSVGConfig> = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Low,\n        name: 'loadSVG',\n    },\n\n    /** used for deprecation purposes */\n    name: 'loadSVG',\n    id: 'svg',\n\n    config: {\n        crossOrigin: 'anonymous',\n        parseAsGraphicsContext: false,\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);\n    },\n\n    async load(\n        url: string,\n        asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n        loader: Loader\n    ): Promise<Texture | GraphicsContext>\n    {\n        if (asset.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext)\n        {\n            return loadAsGraphics(url);\n        }\n\n        return loadAsTexture(url, asset, loader, this.config.crossOrigin);\n    },\n\n    unload(asset: Texture | GraphicsContext): void\n    {\n        asset.destroy(true);\n    }\n\n};\n\nasync function loadAsTexture(\n    url: string,\n    asset: ResolvedAsset<TextureSourceOptions & LoadSVGConfig>,\n    loader: Loader,\n    crossOrigin: ImageLike['crossOrigin']\n): Promise<Texture>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const image = DOMAdapter.get().createImage();\n\n    image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await response.text())}`;\n    image.crossOrigin = crossOrigin;\n    await image.decode();\n\n    // convert to canvas...\n    const width = asset.data?.width ?? image.width;\n    const height = asset.data?.height ?? image.height;\n    const resolution = asset.data?.resolution || getResolutionOfUrl(url);\n\n    // Ensure canvas dimensions are integers to prevent edge trimming\n    const canvasWidth = Math.ceil(width * resolution);\n    const canvasHeight = Math.ceil(height * resolution);\n\n    const canvas = DOMAdapter.get().createCanvas(canvasWidth, canvasHeight);\n    const context = canvas.getContext('2d');\n\n    // Improve rendering quality for decimal resolutions\n    context.imageSmoothingEnabled = true;\n    context.imageSmoothingQuality = 'high';\n\n    // Draw image with exact scaled dimensions to prevent trimming\n    context.drawImage(image as CanvasImageSource, 0, 0, width * resolution, height * resolution);\n\n    const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};\n    const base = new ImageSource({\n        resource: canvas,\n        alphaMode: 'premultiply-alpha-on-upload',\n        resolution,\n        ...rest,\n    });\n\n    return createTexture(base, loader, url);\n}\n\nasync function loadAsGraphics(url: string): Promise<GraphicsContext>\n{\n    const response = await DOMAdapter.get().fetch(url);\n    const svgSource = await response.text();\n\n    const context = new GraphicsContext();\n\n    context.svg(svgSource);\n\n    return context;\n}\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    const WHITE_PNG = \\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=\\\";\\n    async function checkImageBitmap() {\\n      try {\\n        if (typeof createImageBitmap !== \\\"function\\\")\\n          return false;\\n        const response = await fetch(WHITE_PNG);\\n        const imageBlob = await response.blob();\\n        const imageBitmap = await createImageBitmap(imageBlob);\\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\\n      } catch (_e) {\\n        return false;\\n      }\\n    }\\n    void checkImageBitmap().then((result) => {\\n      self.postMessage(result);\\n    });\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=checkImageBitmap.worker.mjs.map\n", "const WORKER_CODE = \"(function () {\\n    'use strict';\\n\\n    async function loadImageBitmap(url, alphaMode) {\\n      const response = await fetch(url);\\n      if (!response.ok) {\\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\\n      }\\n      const imageBlob = await response.blob();\\n      return alphaMode === \\\"premultiplied-alpha\\\" ? createImageBitmap(imageBlob, { premultiplyAlpha: \\\"none\\\" }) : createImageBitmap(imageBlob);\\n    }\\n    self.onmessage = async (event) => {\\n      try {\\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\\n        self.postMessage({\\n          data: imageBitmap,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        }, [imageBitmap]);\\n      } catch (e) {\\n        self.postMessage({\\n          error: e,\\n          uuid: event.data.uuid,\\n          id: event.data.id\\n        });\\n      }\\n    };\\n\\n})();\\n\";\nlet WORKER_URL = null;\nclass WorkerInstance\n{\n    constructor()\n    {\n        if (!WORKER_URL)\n        {\n            WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: 'application/javascript' }));\n        }\n        this.worker = new Worker(WORKER_URL);\n    }\n}\nWorkerInstance.revokeObjectURL = function revokeObjectURL()\n{\n    if (WORKER_URL)\n    {\n        URL.revokeObjectURL(WORKER_URL);\n        WORKER_URL = null;\n    }\n};\n\nexport { WorkerInstance as default };\n//# sourceMappingURL=loadImageBitmap.worker.mjs.map\n", "import CheckImageBitmapWorker from 'worker:./checkImageBitmap.worker.ts';\nimport LoadImageBitmapWorker from 'worker:./loadImageBitmap.worker.ts';\n\nimport type { TextureSourceOptions } from '../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { ResolvedAsset } from '../../types';\n\nlet UUID = 0;\nlet MAX_WORKERS: number;\n\ntype LoadImageBitmapResult = {\n    data?: ImageBitmap,\n    error?: Error,\n    uuid: number,\n    id: string,\n};\n\n/** @internal */\nclass WorkerManagerClass\n{\n    /**\n     * Hash map storing resolve/reject functions for pending worker requests.\n     * Keyed by UUID to match responses with their corresponding promises.\n     */\n    private _resolveHash: {\n        [key: string]: {\n            resolve: (...param: any[]) => void;\n            reject: (...param: any[]) => void;\n        }\n    };\n    /** Pool of available workers ready for use */\n    private readonly _workerPool: Worker[];\n    /** Queue of pending work items waiting for available workers */\n    private readonly _queue: {\n        id: string;\n        arguments: any[];\n        resolve: (...param: any[]) => void;\n        reject: (...param: any[]) => void;\n    }[];\n\n    /** Whether the worker manager has been initialized */\n    private _initialized = false;\n\n    /** Current number of created workers (used to enforce MAX_WORKERS limit) */\n    private _createdWorkers = 0;\n    /** Cached promise for ImageBitmap support check */\n    private _isImageBitmapSupported?: Promise<boolean>;\n\n    constructor()\n    {\n        this._workerPool = [];\n        this._queue = [];\n\n        this._resolveHash = {};\n    }\n\n    /**\n     * Checks if ImageBitmap is supported in the current environment.\n     *\n     * This method uses a dedicated worker to test ImageBitmap support\n     * and caches the result for subsequent calls.\n     * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise\n     */\n    public isImageBitmapSupported(): Promise<boolean>\n    {\n        if (this._isImageBitmapSupported !== undefined) return this._isImageBitmapSupported;\n\n        this._isImageBitmapSupported = new Promise((resolve) =>\n        {\n            const { worker } = new CheckImageBitmapWorker();\n\n            worker.addEventListener('message', (event: MessageEvent<boolean>) =>\n            {\n                worker.terminate();\n                CheckImageBitmapWorker.revokeObjectURL();\n                resolve(event.data);\n            });\n        });\n\n        return this._isImageBitmapSupported;\n    }\n\n    /**\n     * Loads an image as an ImageBitmap using a web worker.\n     * @param src - The source URL or path of the image to load\n     * @param asset - Optional resolved asset containing additional texture source options\n     * @returns Promise that resolves to the loaded ImageBitmap\n     * @example\n     * ```typescript\n     * const bitmap = await WorkerManager.loadImageBitmap('image.png');\n     * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);\n     * ```\n     */\n    public loadImageBitmap(src: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n    {\n        return this._run('loadImageBitmap', [src, asset?.data?.alphaMode]) as Promise<ImageBitmap>;\n    }\n\n    /**\n     * Initializes the worker pool if not already initialized.\n     * Currently a no-op but reserved for future initialization logic.\n     */\n    private async _initWorkers()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n    }\n\n    /**\n     * Gets an available worker from the pool or creates a new one if needed.\n     *\n     * Workers are created up to the MAX_WORKERS limit (based on navigator.hardwareConcurrency).\n     * Each worker is configured with a message handler for processing results.\n     * @returns Available worker or undefined if pool is at capacity and no workers are free\n     */\n    private _getWorker(): Worker\n    {\n        if (MAX_WORKERS === undefined)\n        {\n            MAX_WORKERS = navigator.hardwareConcurrency || 4;\n        }\n        let worker = this._workerPool.pop();\n\n        if (!worker && this._createdWorkers < MAX_WORKERS)\n        {\n            // only create as many as MAX_WORKERS allows..\n            this._createdWorkers++;\n            worker = new LoadImageBitmapWorker().worker;\n\n            worker.addEventListener('message', (event: MessageEvent) =>\n            {\n                this._complete(event.data);\n\n                this._returnWorker(event.target as Worker);\n                this._next();\n            });\n        }\n\n        return worker;\n    }\n\n    /**\n     * Returns a worker to the pool after completing a task.\n     * @param worker - The worker to return to the pool\n     */\n    private _returnWorker(worker: Worker)\n    {\n        this._workerPool.push(worker);\n    }\n\n    /**\n     * Handles completion of a worker task by resolving or rejecting the corresponding promise.\n     * @param data - Result data from the worker containing uuid, data, and optional error\n     */\n    private _complete(data: LoadImageBitmapResult): void\n    {\n        if (data.error !== undefined)\n        {\n            this._resolveHash[data.uuid].reject(data.error);\n        }\n        else\n        {\n            this._resolveHash[data.uuid].resolve(data.data);\n        }\n\n        this._resolveHash[data.uuid] = null;\n    }\n\n    /**\n     * Executes a task using the worker pool system.\n     *\n     * Queues the task and processes it when a worker becomes available.\n     * @param id - Identifier for the type of task to run\n     * @param args - Arguments to pass to the worker\n     * @returns Promise that resolves with the worker's result\n     */\n    private async _run(id: string, args: any[]): Promise<any>\n    {\n        await this._initWorkers();\n        // push into the queue...\n\n        const promise = new Promise((resolve, reject) =>\n        {\n            this._queue.push({ id, arguments: args, resolve, reject });\n        });\n\n        this._next();\n\n        return promise;\n    }\n\n    /**\n     * Processes the next item in the queue if workers are available.\n     *\n     * This method is called after worker initialization and when workers\n     * complete tasks to continue processing the queue.\n     */\n    private _next(): void\n    {\n        // nothing to do\n        if (!this._queue.length) return;\n\n        const worker = this._getWorker();\n\n        // no workers available...\n        if (!worker)\n        {\n            return;\n        }\n\n        const toDo = this._queue.pop();\n\n        const id = toDo.id;\n\n        this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };\n\n        worker.postMessage({\n            data: toDo.arguments,\n            uuid: UUID++,\n            id,\n        });\n    }\n\n    /**\n     * Resets the worker manager, terminating all workers and clearing the queue.\n     *\n     * This method:\n     * - Terminates all active workers\n     * - Rejects all pending promises with an error\n     * - Clears all internal state\n     * - Resets initialization flags\n     *\n     * This should be called when the worker manager is no longer needed\n     * to prevent memory leaks and ensure proper cleanup.\n     * @example\n     * ```typescript\n     * // Clean up when shutting down\n     * WorkerManager.reset();\n     * ```\n     */\n    public reset(): void\n    {\n        // Terminate all workers\n        this._workerPool.forEach((worker) => worker.terminate());\n        this._workerPool.length = 0;\n\n        // Reject pending promises\n        Object.values(this._resolveHash).forEach(({ reject }) =>\n        {\n            reject?.(new Error('WorkerManager destroyed'));\n        });\n        this._resolveHash = {};\n        this._queue.length = 0;\n\n        this._initialized = false;\n        this._createdWorkers = 0;\n    }\n}\n\n/**\n * Manages a pool of web workers for loading ImageBitmap objects asynchronously.\n *\n * This class provides a thread-safe way to load images using web workers,\n * automatically managing worker creation, pooling, and cleanup. It supports\n * checking ImageBitmap support and queuing multiple load requests.\n *\n * > [!IMPORTANT] You should not need to use this class directly\n * > However, you can call `WorkerManager.reset()` to clean up all workers when they are no longer needed.\n * @category Assets\n * @advanced\n */\nconst WorkerManager = new WorkerManagerClass();\n\nexport {\n    WorkerManager,\n};\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { ImageSource } from '../../../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { WorkerManager } from '../../workers/WorkerManager';\nimport { LoaderParserPriority } from '../LoaderParser';\nimport { createTexture } from './utils/createTexture';\n\nimport type { TextureSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/TextureSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst validImageExtensions = ['.jpeg', '.jpg', '.png', '.webp', '.avif'];\nconst validImageMIMEs = [\n    'image/jpeg',\n    'image/png',\n    'image/webp',\n    'image/avif',\n];\n\n/**\n * Configuration for the [loadTextures]{@link loadTextures} plugin.\n * @see loadTextures\n * @category assets\n * @advanced\n */\nexport interface LoadTextureConfig\n{\n    /**\n     * When set to `true`, loading and decoding images will happen with Worker thread,\n     * if available on the browser. This is much more performant as network requests\n     * and decoding can be expensive on the CPU. However, not all environments support\n     * Workers, in some cases it can be helpful to disable by setting to `false`.\n     * @default true\n     */\n    preferWorkers: boolean;\n    /**\n     * When set to `true`, loading and decoding images will happen with `createImageBitmap`,\n     * otherwise it will use `new Image()`.\n     * @default true\n     */\n    preferCreateImageBitmap: boolean;\n    /**\n     * The crossOrigin value to use for images when `preferCreateImageBitmap` is `false`.\n     * @default 'anonymous'\n     */\n    crossOrigin: ImageLike['crossOrigin'];\n}\n\n/**\n * Returns a promise that resolves an ImageBitmaps.\n * This function is designed to be used by a worker.\n * Part of WorkerManager!\n * @param url - The image to load an image bitmap for\n * @ignore\n */\nexport async function loadImageBitmap(url: string, asset?: ResolvedAsset<TextureSourceOptions<any>>): Promise<ImageBitmap>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    if (!response.ok)\n    {\n        throw new Error(`[loadImageBitmap] Failed to fetch ${url}: `\n            + `${response.status} ${response.statusText}`);\n    }\n\n    const imageBlob = await response.blob();\n\n    return asset?.data?.alphaMode === 'premultiplied-alpha'\n        ? createImageBitmap(imageBlob, { premultiplyAlpha: 'none' })\n        : createImageBitmap(imageBlob);\n}\n\n/**\n * A simple plugin to load our textures!\n * This makes use of imageBitmaps where available.\n * We load the `ImageBitmap` on a different thread using workers if possible.\n * We can then use the `ImageBitmap` as a source for a Pixi texture\n *\n * You can customize the behavior of this loader by setting the `config` property.\n * Which can be found [here]{@link LoadTextureConfig}\n * ```js\n * // Set the config\n * import { loadTextures } from 'pixi.js';\n *\n * loadTextures.config = {\n *    // If true we will use a worker to load the ImageBitmap\n *    preferWorkers: true,\n *    // If false we will use new Image() instead of createImageBitmap,\n *    // we'll also disable the use of workers as it requires createImageBitmap\n *    preferCreateImageBitmap: true,\n *    crossOrigin: 'anonymous',\n * };\n * ```\n * @category assets\n * @advanced\n */\nexport const loadTextures: LoaderParser<Texture, TextureSourceOptions, LoadTextureConfig> = {\n\n    /** used for deprecation purposes */\n    name: 'loadTextures',\n    id: 'texture',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.High,\n        name: 'loadTextures',\n    },\n\n    config: {\n        preferWorkers: true,\n        preferCreateImageBitmap: true,\n        crossOrigin: 'anonymous',\n    },\n\n    test(url: string): boolean\n    {\n        return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);\n    },\n\n    async load(url: string, asset: ResolvedAsset<TextureSourceOptions>, loader: Loader): Promise<Texture>\n    {\n        let src: any = null;\n\n        if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap)\n        {\n            if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported())\n            {\n                src = await WorkerManager.loadImageBitmap(url, asset);\n            }\n            else\n            {\n                src = await loadImageBitmap(url, asset);\n            }\n        }\n        else\n        {\n            src = await new Promise((resolve, reject) =>\n            {\n                src = DOMAdapter.get().createImage();\n                src.crossOrigin = this.config.crossOrigin;\n\n                src.src = url;\n                if (src.complete)\n                {\n                    resolve(src);\n                }\n                else\n                {\n                    src.onload = (): void =>\n                    {\n                        resolve(src);\n                    };\n                    src.onerror = reject;\n                }\n            });\n        }\n\n        const base = new ImageSource({\n            resource: src,\n            alphaMode: 'premultiply-alpha-on-upload',\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            ...asset.data,\n        });\n\n        return createTexture(base, loader, url);\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n};\n", "/* eslint-disable no-restricted-globals */\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { VideoSource } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport { detectVideoAlphaMode } from '../../../../utils/browser/detectVideoAlphaMode';\nimport { getResolutionOfUrl } from '../../../../utils/network/getResolutionOfUrl';\nimport { testVideoFormat } from '../../../detections/utils/testVideoFormat';\nimport { checkDataUrl } from '../../../utils/checkDataUrl';\nimport { checkExtension } from '../../../utils/checkExtension';\nimport { createTexture } from './utils/createTexture';\n\nimport type { VideoSourceOptions } from '../../../../rendering/renderers/shared/texture/sources/VideoSource';\nimport type { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport type { ResolvedAsset } from '../../../types';\nimport type { Loader } from '../../Loader';\nimport type { LoaderParser } from '../LoaderParser';\n\nconst potentialVideoExtensions = ['.mp4', '.m4v', '.webm', '.ogg', '.ogv', '.h264', '.avi', '.mov'];\nlet validVideoExtensions: string[];\nlet validVideoMIMEs: string[];\n\n/**\n * Set cross origin based detecting the url and the crossorigin\n * @param element - Element to apply crossOrigin\n * @param url - URL to check\n * @param crossorigin - Cross origin value to use\n * @category assets\n * @advanced\n */\nexport function crossOrigin(element: ImageLike | HTMLVideoElement, url: string, crossorigin?: boolean | string): void\n{\n    if (crossorigin === undefined && !url.startsWith('data:'))\n    {\n        element.crossOrigin = determineCrossOrigin(url);\n    }\n    else if (crossorigin !== false)\n    {\n        element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    }\n}\n\n/**\n * Preload a video element\n * @param element - Video element to preload\n * @internal\n */\nexport function preloadVideo(element: HTMLVideoElement): Promise<void>\n{\n    return new Promise((resolve, reject) =>\n    {\n        element.addEventListener('canplaythrough', loaded);\n        element.addEventListener('error', error);\n\n        element.load();\n\n        function loaded(): void\n        {\n            cleanup();\n            resolve();\n        }\n\n        function error(err: ErrorEvent): void\n        {\n            cleanup();\n            reject(err);\n        }\n\n        function cleanup(): void\n        {\n            element.removeEventListener('canplaythrough', loaded);\n            element.removeEventListener('error', error);\n        }\n    });\n}\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n * Nipped from the resource loader!\n * @ignore\n * @param url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @returns The crossOrigin value to use (or empty string for none).\n * @category assets\n */\nexport function determineCrossOrigin(url: string, loc: Location = globalThis.location): string\n{\n    // data: and javascript: urls are considered same-origin\n    if (url.startsWith('data:'))\n    {\n        return '';\n    }\n\n    // default is window.location\n    loc ||= globalThis.location;\n\n    const parsedUrl = new URL(url, document.baseURI);\n\n    // if cross origin\n    if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol)\n    {\n        return 'anonymous';\n    }\n\n    return '';\n}\n\ntype LoadVideoData = VideoSourceOptions & {\n    mime?: string;\n};\n\n/**\n * Get the supported video extensions and MIME types based on the browser's capabilities.\n * This function checks the potential video extensions against the browser's supported formats.\n * @returns An object containing valid video extensions and MIME types.\n * @internal\n */\nfunction getBrowserSupportedVideoExtensions()\n{\n    const supportedExtensions: string[] = [];\n    const supportedMimes: string[] = [];\n\n    for (const ext of potentialVideoExtensions)\n    {\n        const mimeType = VideoSource.MIME_TYPES[ext.substring(1)] || `video/${ext.substring(1)}`;\n\n        if (testVideoFormat(mimeType))\n        {\n            supportedExtensions.push(ext);\n            if (!supportedMimes.includes(mimeType))\n            {\n                supportedMimes.push(mimeType);\n            }\n        }\n    }\n\n    return {\n        validVideoExtensions: supportedExtensions,\n        validVideoMime: supportedMimes\n    };\n}\n\n/**\n * A simple plugin to load video textures.\n *\n * You can pass VideoSource options to the loader via the .data property of the asset descriptor\n * when using Assets.load().\n * ```js\n * // Set the data\n * const texture = await Assets.load({\n *     src: './assets/city.mp4',\n *     data: {\n *         preload: true,\n *         autoPlay: true,\n *     },\n * });\n * ```\n * @category assets\n * @advanced\n */\nexport const loadVideoTextures = {\n\n    /** used for deprecation purposes */\n    name: 'loadVideo',\n    id: 'video',\n\n    extension: {\n        type: ExtensionType.LoadParser,\n        name: 'loadVideo',\n    },\n\n    test(url: string): boolean\n    {\n        if (!validVideoExtensions || !validVideoMIMEs)\n        {\n            const { validVideoExtensions: ve, validVideoMime: vm } = getBrowserSupportedVideoExtensions();\n\n            validVideoExtensions = ve;\n            validVideoMIMEs = vm;\n        }\n        const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);\n        const isValidExtension = checkExtension(url, validVideoExtensions);\n\n        return isValidDataUrl || isValidExtension;\n    },\n\n    async load(url: string, asset: ResolvedAsset<LoadVideoData>, loader: Loader): Promise<Texture>\n    {\n        // --- Merge default and provided options ---\n        const options: LoadVideoData = {\n            ...VideoSource.defaultOptions,\n            resolution: asset.data?.resolution || getResolutionOfUrl(url),\n            alphaMode: asset.data?.alphaMode || await detectVideoAlphaMode(),\n            ...asset.data,\n        };\n\n        // --- Create and configure HTMLVideoElement ---\n        const videoElement = document.createElement('video');\n\n        // Set attributes based on options\n        const attributeMap = {\n            preload: options.autoLoad !== false ? 'auto' : undefined,\n            'webkit-playsinline': options.playsinline !== false ? '' : undefined,\n            playsinline: options.playsinline !== false ? '' : undefined,\n            muted: options.muted === true ? '' : undefined,\n            loop: options.loop === true ? '' : undefined,\n            autoplay: options.autoPlay !== false ? '' : undefined\n        };\n\n        Object.keys(attributeMap).forEach((key) =>\n        {\n            const value = attributeMap[key as keyof typeof attributeMap];\n\n            if (value !== undefined) videoElement.setAttribute(key, value);\n        });\n\n        if (options.muted === true)\n        {\n            videoElement.muted = true;\n        }\n\n        crossOrigin(videoElement, url, options.crossorigin); // Assume crossOrigin is globally available\n\n        // --- Set up source and MIME type ---\n        const sourceElement = document.createElement('source');\n\n        // Determine MIME type\n        let mime: string | undefined;\n\n        if (options.mime)\n        {\n            mime = options.mime;\n        }\n        else if (url.startsWith('data:'))\n        {\n            mime = url.slice(5, url.indexOf(';'));\n        }\n        else if (!url.startsWith('blob:'))\n        {\n            const ext = url.split('?')[0].slice(url.lastIndexOf('.') + 1).toLowerCase();\n\n            mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;\n        }\n\n        sourceElement.src = url;\n\n        if (mime)\n        {\n            sourceElement.type = mime;\n        }\n\n        // this promise will make sure that video is ready to play - as in we have a valid width, height and it can be\n        // uploaded to the GPU. Our textures are kind of dumb now, and don't want to handle resizing right now.\n        return new Promise((resolve) =>\n        {\n            const onCanPlay = async () =>\n            {\n                const base = new VideoSource({ ...options, resource: videoElement });\n\n                videoElement.removeEventListener('canplay', onCanPlay);\n\n                if (asset.data.preload)\n                {\n                    await preloadVideo(videoElement);\n                }\n\n                resolve(createTexture(base, loader, url));\n            };\n\n            if (options.preload && !options.autoPlay)\n            {\n                videoElement.load();\n            }\n\n            videoElement.addEventListener('canplay', onCanPlay);\n            videoElement.appendChild(sourceElement);\n        });\n    },\n\n    unload(texture: Texture): void\n    {\n        texture.destroy(true);\n    }\n} satisfies LoaderParser<Texture, LoadVideoData>;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { loadTextures } from '../../loader/parsers/textures/loadTextures';\nimport { Resolver } from '../Resolver';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a texture url\n * @category assets\n * @internal\n */\nexport const resolveTextureUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        name: 'resolveTexture',\n    },\n    test: loadTextures.test,\n    parse: (value: string) =>\n        ({\n            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n            format: value.split('.').pop(),\n            src: value,\n        }),\n} satisfies ResolveURLParser;\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Resolver } from '../Resolver';\nimport { resolveTextureUrl } from './resolveTextureUrl';\n\nimport type { ResolveURLParser } from '../types';\n\n/**\n * A parser that will resolve a json urls resolution for spritesheets\n * e.g. `assets/spritesheet@1x.json`\n * @category assets\n * @internal\n */\nexport const resolveJsonUrl = {\n    extension: {\n        type: ExtensionType.ResolveParser,\n        priority: -2,\n        name: 'resolveJson',\n    },\n    test: (value: string): boolean =>\n        Resolver.RETINA_PREFIX.test(value) && value.endsWith('.json'),\n    parse: resolveTextureUrl.parse,\n} satisfies ResolveURLParser;\n", "/* eslint-disable max-len */\nimport { extensions, ExtensionType } from '../extensions/Extensions';\nimport { bitmapFontCachePlugin, loadBitmapFont } from '../scene/text-bitmap/asset/loadBitmapFont';\nimport { warn } from '../utils/logging/warn';\nimport { BackgroundLoader } from './BackgroundLoader';\nimport { Cache } from './cache/Cache';\nimport { cacheTextureArray } from './cache/parsers/cacheTextureArray';\nimport { detectAvif } from './detections/parsers/detectAvif';\nimport { detectDefaults } from './detections/parsers/detectDefaults';\nimport { detectMp4 } from './detections/parsers/detectMp4';\nimport { detectOgv } from './detections/parsers/detectOgv';\nimport { detectWebm } from './detections/parsers/detectWebm';\nimport { detectWebp } from './detections/parsers/detectWebp';\nimport { Loader, type LoadOptions } from './loader/Loader';\nimport { loadJson } from './loader/parsers/loadJson';\nimport { loadTxt } from './loader/parsers/loadTxt';\nimport { loadWebFont } from './loader/parsers/loadWebFont';\nimport { loadSvg } from './loader/parsers/textures/loadSVG';\nimport { type LoadTextureConfig, loadTextures } from './loader/parsers/textures/loadTextures';\nimport { loadVideoTextures } from './loader/parsers/textures/loadVideoTextures';\nimport { resolveJsonUrl } from './resolver/parsers/resolveJsonUrl';\nimport { resolveTextureUrl } from './resolver/parsers/resolveTextureUrl';\nimport { Resolver } from './resolver/Resolver';\nimport { convertToList } from './utils/convertToList';\nimport { isSingleItem } from './utils/isSingleItem';\n\nimport type { AssetExtension } from './AssetExtension';\nimport type { FormatDetectionParser } from './detections/types';\nimport type { LoadSVGConfig } from './loader/parsers/textures/loadSVG';\nimport type { BundleIdentifierOptions } from './resolver/Resolver';\nimport type { ArrayOr, AssetsBundle, AssetsManifest, ResolvedAsset, UnresolvedAsset } from './types';\n\n/**\n * Callback function for tracking asset loading progress. The function is called repeatedly\n * during the loading process with a progress value between 0.0 and 1.0.\n * @param progress - The loading progress from 0.0 (started) to 1.0 (complete)\n * @returns void\n * @example\n * ```ts\n * // Basic progress logging\n * const onProgress = (progress: number) => {\n *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n * };\n *\n * // Update loading bar\n * const onProgress = (progress: number) => {\n *     loadingBar.width = progress * 100;\n *     loadingText.text = `${Math.round(progress * 100)}%`;\n * };\n *\n * // Load assets with progress tracking\n * await Assets.load(['sprite1.png', 'sprite2.png'], onProgress);\n *\n * // Load bundle with progress tracking\n * await Assets.loadBundle('levelAssets', (progress) => {\n *     // Progress is normalized (0.0 - 1.0)\n *     updateLoadingScreen(progress);\n * });\n * ```\n * > [!IMPORTANT] Do not rely on the progress callback to determine when all assets are loaded.\n * > Use the returned promise from `Assets.load()` or `Assets.loadBundle()` to know when loading is complete.\n * @category assets\n * @standard\n */\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * Extensible preferences that can be used, for instance, when configuring loaders.\n * @since 7.2.0\n * @advanced\n * @category assets\n */\nexport interface AssetsPreferences extends LoadTextureConfig, LoadSVGConfig, PixiMixins.AssetsPreferences {}\n\n/**\n * Options for initializing the Assets class. These options configure how assets are loaded,\n * resolved, and managed in your PixiJS application.\n * @category assets\n * @standard\n */\nexport interface AssetInitOptions\n{\n    /**\n     * Base path prepended to all asset URLs. Useful for CDN hosting.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/'\n     * });\n     *\n     * // Now you can load assets like this:\n     * // Will load from: https://my-cdn.com/assets/images/sprite.png\n     * const texture = await Assets.load('images/sprite.png');\n     * ```\n     */\n    basePath?: string;\n\n    /**\n     * URL parameters to append to all asset URLs.\n     * Useful for cache-busting or version control.\n     * @example\n     * ```ts\n     * // As a string\n     * await Assets.init({\n     *     defaultSearchParams: 'version=1.0.0'\n     * });\n     *\n     * // As an object\n     * await Assets.init({\n     *     defaultSearchParams: {\n     *         version: '1.0.0',\n     *         t: Date.now()\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    defaultSearchParams?: string | Record<string, any>;\n\n    /**\n     * A manifest defining all your application's assets.\n     * Can be a URL to a JSON file or a manifest object.\n     * @example\n     * ```ts\n     * // Using a manifest object\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}'\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Using a URL to manifest\n     * await Assets.init({\n     *     manifest: 'assets/manifest.json'\n     * });\n     *\n     * // loading a bundle from the manifest\n     * await Assets.loadBundle('game-screen');\n     *\n     * // load individual assets from the manifest\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     */\n    manifest?: string | AssetsManifest;\n    /**\n     * Configure texture loading preferences.\n     * Useful for optimizing asset delivery based on device capabilities.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     texturePreference: {\n     *         // Prefer high-res textures on retina displays\n     *         resolution: window.devicePixelRatio,\n     *\n     *         // Prefer modern formats, fallback to traditional\n     *         format: ['avif', 'webp', 'png']\n     *     }\n     * });\n     * ```\n     */\n    texturePreference?: {\n        /** Preferred texture resolution(s). Can be a single number or array of resolutions in order of preference. */\n        resolution?: number | number[];\n\n        /** Preferred texture formats in order of preference. Default: ['avif', 'webp', 'png', 'jpg', 'jpeg'] */\n        format?: ArrayOr<string>;\n    };\n\n    /**\n     * Skip browser format detection for faster initialization.\n     * Only use if you know exactly what formats your target browsers support.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     skipDetections: true,\n     *     texturePreference: {\n     *         format: ['webp', 'png'] // Must explicitly set formats\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    skipDetections?: boolean;\n\n    /**\n     * Override how bundle IDs are generated and resolved.\n     *\n     * This allows you to customize how assets are grouped and accessed via bundles and allow for\n     * multiple bundles to share the same asset keys.\n     * @advanced\n     * @example\n     * ```ts\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'bunny1',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny.png',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'bunny2',\n     *             assets: [\n     *                 {\n     *                     alias: ['character', 'character2'],\n     *                     src: 'textures/bunny-2.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * const bundleIdentifier: BundleIdentifierOptions = {\n     *     connector: ':',\n     * };\n     *\n     * await Assets.init({ manifest, basePath, bundleIdentifier });\n     *\n     * const resources = await Assets.loadBundle('bunny1');\n     * const resources2 = await Assets.loadBundle('bunny2');\n     *\n     * console.log(resources.character === resources2.character); // false\n     * ```\n     */\n    bundleIdentifier?: BundleIdentifierOptions;\n\n    /**\n     * Optional preferences for asset loading behavior.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *         parseAsGraphicsContext: false\n     *     }\n     * });\n     * ```\n     */\n    preferences?: Partial<AssetsPreferences>;\n\n    /**\n     * Options for defining the loading behavior of assets.\n     * @example\n     * ```ts\n     * await Assets.init({\n     *    loadOptions: {\n     *       onProgress: (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`),\n     *       onError: (error, asset) => console.error(`Error loading ${asset.src}: ${error.message}`),\n     *       strategy: 'retry',\n     *       retryCount: 5,\n     *       retryDelay: 500,\n     *   }\n     * });\n     * ```\n     * @remarks\n     * - `onProgress` callback receives values from 0.0 to 1.0\n     * - `onError` callback is invoked for individual asset load failures\n     * - `strategy` can be 'throw' (default), 'retry', or 'skip'\n     * - `retryCount` sets how many times to retry failed assets (default 3)\n     * - `retryDelay` sets the delay between retries in milliseconds (default 250ms)\n     * @see {@link LoadOptions} For all available load options\n     */\n    loadOptions?: Partial<LoadOptions>;\n}\n\n/** @internal */\nexport class AssetsClass\n{\n    /**\n     * The URL resolver for assets. Maps various asset keys and URLs to their final loadable form.\n     * @advanced\n     */\n    public resolver: Resolver;\n    /**\n     *  The loader responsible for loading all assets. Handles different file types\n     * and transformations.\n     * @advanced\n     */\n    public loader: Loader;\n    /**\n     * The global cache for all loaded assets. Manages storage and retrieval of\n     * processed assets.\n     * @example\n     * ```ts\n     * // Check if an asset is cached\n     * if (Assets.cache.has('myTexture')) {\n     *     const texture = Assets.cache.get('myTexture');\n     * }\n     * ```\n     * @see {@link Cache} For detailed cache documentation\n     */\n    public cache: typeof Cache;\n\n    /** takes care of loading assets in the background */\n    private readonly _backgroundLoader: BackgroundLoader;\n\n    private readonly _detections: FormatDetectionParser[] = [];\n\n    private _initialized = false;\n\n    constructor()\n    {\n        this.resolver = new Resolver();\n        this.loader = new Loader();\n        this.cache = Cache;\n\n        this._backgroundLoader = new BackgroundLoader(this.loader);\n        this._backgroundLoader.active = true;\n\n        this.reset();\n    }\n\n    /**\n     * Initializes the Assets class with configuration options. While not required,\n     * calling this before loading assets is recommended to set up default behaviors.\n     * @param options - Configuration options for the Assets system\n     * @example\n     * ```ts\n     * // Basic initialization (optional as Assets.load will call this automatically)\n     * await Assets.init();\n     *\n     * // With CDN configuration\n     * await Assets.init({\n     *     basePath: 'https://my-cdn.com/assets/',\n     *     defaultSearchParams: { version: '1.0.0' }\n     * });\n     *\n     * // With manifest and preferences\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [{\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'hero',\n     *                     src: 'hero.{png,webp}',\n     *                     data: { scaleMode: SCALE_MODES.NEAREST }\n     *                 },\n     *                 {\n     *                     alias: 'map',\n     *                     src: 'map.json'\n     *                 }\n     *             ]\n     *         }]\n     *     },\n     *     // Optimize for device capabilities\n     *     texturePreference: {\n     *         resolution: window.devicePixelRatio,\n     *         format: ['webp', 'png']\n     *     },\n     *     // Set global preferences\n     *     preferences: {\n     *         crossOrigin: 'anonymous',\n     *     }\n     * });\n     *\n     * // Load assets after initialization\n     * const heroTexture = await Assets.load('hero');\n     * ```\n     * @remarks\n     * - Can be called only once; subsequent calls will be ignored with a warning\n     * - Format detection runs automatically unless `skipDetections` is true\n     * - The manifest can be a URL to a JSON file or an inline object\n     * @see {@link AssetInitOptions} For all available initialization options\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async init(options: AssetInitOptions = {}): Promise<void>\n    {\n        if (this._initialized)\n        {\n            // #if _DEBUG\n            warn('[Assets]AssetManager already initialized, did you load before calling this Assets.init()?');\n            // #endif\n\n            return;\n        }\n\n        this._initialized = true;\n\n        if (options.defaultSearchParams)\n        {\n            this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n        }\n\n        if (options.basePath)\n        {\n            this.resolver.basePath = options.basePath;\n        }\n\n        if (options.bundleIdentifier)\n        {\n            this.resolver.setBundleIdentifier(options.bundleIdentifier);\n        }\n\n        if (options.manifest)\n        {\n            let manifest = options.manifest;\n\n            if (typeof manifest === 'string')\n            {\n                manifest = await this.load<AssetsManifest>(manifest);\n            }\n\n            this.resolver.addManifest(manifest);\n        }\n\n        const resolutionPref = options.texturePreference?.resolution ?? 1;\n        const resolution = (typeof resolutionPref === 'number') ? [resolutionPref] : resolutionPref;\n\n        const formats = await this._detectFormats({\n            preferredFormats: options.texturePreference?.format,\n            skipDetections: options.skipDetections,\n            detections: this._detections\n        });\n\n        this.resolver.prefer({\n            params: {\n                format: formats,\n                resolution,\n            },\n        });\n\n        if (options.preferences)\n        {\n            this.setPreferences(options.preferences);\n        }\n\n        // set load options on the loader\n        if (options.loadOptions)\n        {\n            this.loader.loadOptions = {\n                ...this.loader.loadOptions,\n                ...options.loadOptions\n            };\n        }\n    }\n\n    /**\n     * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,\n     * allowing you to load assets using friendly names instead of direct URLs.\n     * @param assets - The unresolved assets to add to the resolver\n     * @example\n     * ```ts\n     * // Basic usage - single asset\n     * Assets.add({\n     *     alias: 'myTexture',\n     *     src: 'assets/texture.png'\n     * });\n     * const texture = await Assets.load('myTexture');\n     *\n     * // Multiple aliases for the same asset\n     * Assets.add({\n     *     alias: ['hero', 'player'],\n     *     src: 'hero.png'\n     * });\n     * const hero1 = await Assets.load('hero');\n     * const hero2 = await Assets.load('player'); // Same texture\n     *\n     * // Multiple format support\n     * Assets.add({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     * Assets.add({\n     *     alias: 'character',\n     *     src: ['character.webp', 'character.png'], // Explicitly specify formats\n     * });\n     *\n     * // With texture options\n     * Assets.add({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: { scaleMode: 'nearest' }\n     * });\n     *\n     * // Multiple assets at once\n     * Assets.add([\n     *     { alias: 'bg', src: 'background.png' },\n     *     { alias: 'music', src: 'music.mp3' },\n     *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }\n     * ]);\n     * ```\n     * @remarks\n     * - Assets are resolved when loaded, not when added\n     * - Multiple formats use the best available format for the browser\n     * - Adding with same alias overwrites previous definition\n     * - The `data` property is passed to the asset loader\n     * @see {@link Resolver} For details on asset resolution\n     * @see {@link LoaderParser} For asset-specific data options\n     * @advanced\n     */\n    public add(assets: (ArrayOr<UnresolvedAsset>)): void\n    {\n        this.resolver.add(assets);\n    }\n\n    /**\n     * Loads one or more assets and returns a promise that resolves with the loaded content.\n     * Assets are cached, so subsequent loads will return the same instance of the asset without re-fetching.\n     * @param urls - Single URL/alias or array of URLs/aliases to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with loaded asset(s)\n     * @example\n     * ```ts\n     * // Load a single asset\n     * const texture = await Assets.load('images/sprite.png');\n     *\n     * // Load using an alias\n     * const heroTexture = await Assets.load({ alias: 'hero', src: 'images/hero.png' });\n     *\n     * // Load multiple assets\n     * const assets = await Assets.load([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'fonts/game.fnt'\n     * ]);\n     * console.log(assets['images/background.png']); // Access by URL\n     *\n     * // Load with progress tracking\n     * const textures = await Assets.load(['sprite1.png', 'sprite2.png'],\n     *     (progress) => console.log(`Loading: ${Math.round(progress * 100)}%`)\n     * );\n     *\n     * // Load with format preference\n     * const characterTexture = await Assets.load({\n     *     alias: 'character',\n     *     src: 'character.{webp,png}' // Will choose best format\n     * });\n     *\n     * // Load with custom options\n     * const spriteTexture = await Assets.load({\n     *     alias: 'sprite',\n     *     src: 'sprite.png',\n     *     data: {\n     *         scaleMode: SCALE_MODES.NEAREST,\n     *         mipmap: MIPMAP_MODES.ON\n     *     }\n     * });\n     *\n     * // Load with a specific loader, can be useful if your asset does not have an extension\n     * const image = await Assets.load({\n     *    alias: 'imageWithoutExtension',\n     *    src: 'images/imageWithoutExtension',\n     *    parser: 'texture' // Use the JSON loader\n     * });\n     * ```\n     * @remarks\n     * - Assets are cached automatically to prevent duplicate loading\n     * - URLs are resolved to the best format for the current browser\n     * - Asset types are detected automatically based on file extension\n     * - Progress callback receives values from 0.0 to 1.0\n     * - You can define with loader to use for an asset by specifying the `parser` property, which is useful for assets that do not have a file extension.\n     * @throws {Error} If the asset cannot be loaded or parsed\n     * @see {@link Assets.add} For registering assets with aliases\n     * @see {@link Assets.backgroundLoad} For loading assets in the background\n     * @see {@link Assets.unload} For releasing loaded assets\n     */\n    public async load<T = any>(\n        urls: string | UnresolvedAsset,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T>;\n    public async load<T = any>(\n        urls: string[] | UnresolvedAsset[],\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>;\n    public async load<T = any>(\n        urls: ArrayOr<string> | ArrayOr<UnresolvedAsset>,\n        onProgress?: ProgressCallback | LoadOptions,\n    ): Promise<T | Record<string, T>>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const singleAsset = isSingleItem(urls);\n\n        const urlArray: string[] = convertToList<UnresolvedAsset | string>(urls)\n            .map((url) =>\n            {\n                if (typeof url !== 'string')\n                {\n                    const aliases = this.resolver.getAlias(url);\n\n                    if (aliases.some((alias) => !this.resolver.hasKey(alias)))\n                    {\n                        this.add(url);\n                    }\n\n                    return Array.isArray(aliases) ? aliases[0] : aliases;\n                }\n\n                // if it hasn't been added, add it now\n                if (!this.resolver.hasKey(url)) this.add({ alias: url, src: url });\n\n                return url;\n            }) as string[];\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        // remap to the keys used..\n        const out: Record<string, T> = await this._mapLoadToResolve<T>(resolveResults, onProgress);\n\n        return singleAsset ? out[urlArray[0] as string] : out;\n    }\n\n    /**\n     * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing\n     * assets into logical groups, such as game levels or UI screens.\n     * @param bundleId - Unique identifier for the bundle\n     * @param assets - Assets to include in the bundle\n     * @example\n     * ```ts\n     * // Add a bundle using array format\n     * Assets.addBundle('animals', [\n     *     { alias: 'bunny', src: 'bunny.png' },\n     *     { alias: 'chicken', src: 'chicken.png' },\n     *     { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     *\n     * // Add a bundle using object format\n     * Assets.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * // Add a bundle with advanced options\n     * Assets.addBundle('ui', [\n     *     {\n     *         alias: 'button',\n     *         src: 'button.{webp,png}',\n     *         data: { scaleMode: 'nearest' }\n     *     },\n     *     {\n     *         alias: ['logo', 'brand'],  // Multiple aliases\n     *         src: 'logo.svg',\n     *         data: { resolution: 2 }\n     *     }\n     * ]);\n     *\n     * // Load the bundle\n     * await Assets.loadBundle('animals');\n     *\n     * // Use the loaded assets\n     * const bunny = Sprite.from('bunny');\n     * const chicken = Sprite.from('chicken');\n     * ```\n     * @remarks\n     * - Bundle IDs must be unique\n     * - Assets in bundles are not loaded until `loadBundle` is called\n     * - Bundles can be background loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be loaded individually using their aliases\n     * @see {@link Assets.loadBundle} For loading bundles\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        this.resolver.addBundle(bundleId, assets);\n    }\n\n    /**\n     * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets\n     * that can be loaded together.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load\n     * @param onProgress - Optional callback for load progress (0.0 to 1.0)\n     * @returns Promise that resolves with the loaded bundle assets\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}', // use an array of individual assets\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * // Initialize with manifest\n     * await Assets.init({ manifest });\n     *\n     * // Or add bundles programmatically\n     * Assets.addBundle('load-screen', [...]);\n     * Assets.loadBundle('load-screen');\n     *\n     * // Load a single bundle\n     * await Assets.loadBundle('load-screen');\n     * const bg = Sprite.from('background'); // Uses alias from bundle\n     *\n     * // Load multiple bundles\n     * await Assets.loadBundle([\n     *     'load-screen',\n     *     'game-screen'\n     * ]);\n     *\n     * // Load with progress tracking\n     * await Assets.loadBundle('game-screen', (progress) => {\n     *     console.log(`Loading: ${Math.round(progress * 100)}%`);\n     * });\n     * ```\n     * @remarks\n     * - Bundle assets are cached automatically\n     * - Bundles can be pre-loaded using `backgroundLoadBundle`\n     * - Assets in bundles can be accessed by their aliases\n     * - Progress callback receives values from 0.0 to 1.0\n     * @throws {Error} If the bundle ID doesn't exist in the manifest\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.backgroundLoadBundle} For background loading bundles\n     * @see {@link Assets.unloadBundle} For unloading bundles\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async loadBundle(bundleIds: ArrayOr<string>, onProgress?: ProgressCallback): Promise<any>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        let singleAsset = false;\n\n        if (typeof bundleIds === 'string')\n        {\n            singleAsset = true;\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const out: Record<string, Record<string, any>> = {};\n\n        const keys = Object.keys(resolveResults);\n        let total = 0;\n        const counts: number[] = [];\n        const _onProgress = () =>\n        {\n            onProgress?.(counts.reduce((a, b) => a + b, 0) / total);\n        };\n        const promises = keys.map((bundleId, i) =>\n        {\n            const resolveResult = resolveResults[bundleId];\n            const values = Object.values(resolveResult);\n            const totalAssetsToLoad = [...new Set(values.flat())] as ResolvedAsset[];\n\n            const progressSize = totalAssetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);\n\n            counts.push(0);\n            total += progressSize;\n\n            return this._mapLoadToResolve(resolveResult, (e) =>\n            {\n                counts[i] = e * progressSize;\n                _onProgress();\n            })\n                .then((resolveResult) =>\n                {\n                    out[bundleId] = resolveResult;\n                });\n        });\n\n        await Promise.all(promises);\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Initiates background loading of assets. This allows assets to be loaded passively while other operations\n     * continue, making them instantly available when needed later.\n     *\n     * Background loading is useful for:\n     * - Preloading game levels while in a menu\n     * - Loading non-critical assets during gameplay\n     * - Reducing visible loading screens\n     * @param urls - Single URL/alias or array of URLs/aliases to load in the background\n     * @example\n     * ```ts\n     * // Basic background loading\n     * Assets.backgroundLoad('images/level2-assets.png');\n     *\n     * // Background load multiple assets\n     * Assets.backgroundLoad([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png',\n     *     'images/background.png'\n     * ]);\n     *\n     * // Later, when you need the assets\n     * const textures = await Assets.load([\n     *     'images/sprite1.png',\n     *     'images/sprite2.png'\n     * ]); // Resolves immediately if background loading completed\n     * ```\n     * @remarks\n     * - Background loading happens one asset at a time to avoid blocking the main thread\n     * - Loading can be interrupted safely by calling `Assets.load()`\n     * - Assets are cached as they complete loading\n     * - No progress tracking is available for background loading\n     */\n    public async backgroundLoad(urls: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof urls === 'string')\n        {\n            urls = [urls];\n        }\n\n        const resolveResults = this.resolver.resolve(urls);\n\n        this._backgroundLoader.add(Object.values(resolveResults));\n    }\n\n    /**\n     * Initiates background loading of asset bundles. Similar to backgroundLoad but works with\n     * predefined bundles of assets.\n     *\n     * Perfect for:\n     * - Preloading level bundles during gameplay\n     * - Loading UI assets during splash screens\n     * - Preparing assets for upcoming game states\n     * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background\n     * @example\n     * ```ts\n     * // Define bundles in your manifest\n     * await Assets.init({\n     *     manifest: {\n     *         bundles: [\n     *             {\n     *               name: 'home',\n     *               assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/home-bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'logo',\n     *                     src: 'images/logo.png',\n     *                 }\n     *              ]\n     *            },\n     *            {\n     *             name: 'level-1',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'images/level1/bg.png',\n     *                 },\n     *                 {\n     *                     alias: 'sprites',\n     *                     src: 'images/level1/sprites.json'\n     *                 }\n     *             ]\n     *         }]\n     *     }\n     * });\n     *\n     * // Load the home screen assets right away\n     * await Assets.loadBundle('home');\n     * showHomeScreen();\n     *\n     * // Start background loading while showing home screen\n     * Assets.backgroundLoadBundle('level-1');\n     *\n     * // When player starts level, load completes faster\n     * await Assets.loadBundle('level-1');\n     * hideHomeScreen();\n     * startLevel();\n     * ```\n     * @remarks\n     * - Bundle assets are loaded one at a time\n     * - Loading can be interrupted safely by calling `Assets.loadBundle()`\n     * - Assets are cached as they complete loading\n     * - Requires bundles to be registered via manifest or `addBundle`\n     * @see {@link Assets.addBundle} For adding bundles programmatically\n     * @see {@link Assets.loadBundle} For immediate bundle loading\n     * @see {@link AssetsManifest} For manifest format details\n     */\n    public async backgroundLoadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        if (typeof bundleIds === 'string')\n        {\n            bundleIds = [bundleIds];\n        }\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        Object.values(resolveResults).forEach((resolveResult) =>\n        {\n            this._backgroundLoader.add(Object.values(resolveResult));\n        });\n    }\n\n    /**\n     * Only intended for development purposes.\n     * This will wipe the resolver and caches.\n     * You will need to reinitialize the Asset\n     * @internal\n     */\n    public reset(): void\n    {\n        this.resolver.reset();\n        this.loader.reset();\n        this.cache.reset();\n\n        this._initialized = false;\n    }\n\n    /**\n     * Instantly gets an asset already loaded from the cache. Returns undefined if the asset hasn't been loaded yet.\n     * @param keys - The key or keys for the assets to retrieve\n     * @returns The cached asset(s) or undefined if not loaded\n     * @example\n     * ```ts\n     * // Get a single cached asset\n     * const texture = Assets.get('hero');\n     * if (texture) {\n     *     const sprite = new Sprite(texture);\n     * }\n     *\n     * // Get multiple cached assets\n     * const textures = Assets.get([\n     *     'hero',\n     *     'background',\n     *     'enemy'\n     * ]);\n     *\n     * // Safe pattern with loading fallback\n     * let texture = Assets.get('hero');\n     * if (!texture) {\n     *     texture = await Assets.load('hero');\n     * }\n     *\n     * // Working with bundles\n     * await Assets.loadBundle('game-ui');\n     * const uiAssets = Assets.get([\n     *     'button',\n     *     'panel',\n     *     'icons'\n     * ]);\n     * ```\n     * @remarks\n     * - Returns undefined if asset isn't loaded\n     * - No automatic loading - use `Assets.load()` for that\n     * - Cached assets are shared instances\n     * - Faster than `load()` for already cached assets\n     *\n     * > [!TIP]\n     * > When in doubt, use `Assets.load()` instead. It will return cached\n     * > assets instantly if they're already loaded.\n     * @see {@link Assets.load} For loading assets that aren't cached\n     * @see {@link Assets.cache} For direct cache access\n     */\n    public get<T = any>(keys: string): T;\n    public get<T = any>(keys: string[]): Record<string, T>;\n    public get<T = any>(keys: ArrayOr<string>): T | Record<string, T>\n    {\n        if (typeof keys === 'string')\n        {\n            return Cache.get(keys);\n        }\n\n        const assets: Record<string, T> = {};\n\n        for (let i = 0; i < keys.length; i++)\n        {\n            assets[i] = Cache.get(keys[i]);\n        }\n\n        return assets;\n    }\n\n    /**\n     * helper function to map resolved assets back to loaded assets\n     * @param resolveResults - the resolve results from the resolver\n     * @param progressOrLoadOptions - the progress callback or load options\n     */\n    private async _mapLoadToResolve<T>(\n        resolveResults: ResolvedAsset | Record<string, ResolvedAsset>,\n        progressOrLoadOptions?: ProgressCallback | LoadOptions,\n    ): Promise<Record<string, T>>\n    {\n        const resolveArray = [...new Set(Object.values(resolveResults))] as ResolvedAsset[];\n\n        // pause background loader...\n        this._backgroundLoader.active = false;\n\n        const loadedAssets = await this.loader.load<T>(resolveArray, progressOrLoadOptions);\n\n        // resume background loader...\n        this._backgroundLoader.active = true;\n\n        // remap to the keys used..\n\n        const out: Record<string, T> = {};\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            const asset = loadedAssets[resolveResult.src];\n\n            const keys = [resolveResult.src];\n\n            if (resolveResult.alias)\n            {\n                keys.push(...resolveResult.alias);\n            }\n\n            keys.forEach((key) =>\n            {\n                out[key] = asset;\n            });\n\n            Cache.set(keys, asset);\n        });\n\n        return out;\n    }\n\n    /**\n     * Unloads assets and releases them from memory. This method ensures proper cleanup of\n     * loaded assets when they're no longer needed.\n     * @param urls - Single URL/alias or array of URLs/aliases to unload\n     * @example\n     * ```ts\n     * // Unload a single asset\n     * await Assets.unload('images/sprite.png');\n     *\n     * // Unload using an alias\n     * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias\n     *\n     * // Unload multiple assets\n     * await Assets.unload([\n     *     'images/background.png',\n     *     'images/character.png',\n     *     'hero'\n     * ]);\n     *\n     * // Unload and handle creation of new instances\n     * await Assets.unload('hero');\n     * const newHero = await Assets.load('hero'); // Will load fresh from source\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > Make sure assets aren't being used before unloading:\n     * > - Remove sprites using the texture\n     * > - Clear any references to the asset\n     * > - Textures will be destroyed and can't be used after unloading\n     * @throws {Error} If the asset is not found in cache\n     */\n    public async unload(\n        urls: ArrayOr<string> | ResolvedAsset | ResolvedAsset[]\n    ): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        const urlArray = convertToList<string | ResolvedAsset>(urls)\n            .map((url) =>\n                ((typeof url !== 'string') ? url.src : url));\n\n        // check cache first...\n        const resolveResults = this.resolver.resolve(urlArray);\n\n        await this._unloadFromResolved(resolveResults);\n    }\n\n    /**\n     * Unloads all assets in a bundle. Use this to free memory when a bundle's assets\n     * are no longer needed, such as when switching game levels.\n     * @param bundleIds - Single bundle ID or array of bundle IDs to unload\n     * @example\n     * ```ts\n     * // Define and load a bundle\n     * Assets.addBundle('level-1', {\n     *     background: 'level1/bg.png',\n     *     sprites: 'level1/sprites.json',\n     *     music: 'level1/music.mp3'\n     * });\n     *\n     * // Load the bundle\n     * const level1 = await Assets.loadBundle('level-1');\n     *\n     * // Use the assets\n     * const background = Sprite.from(level1.background);\n     *\n     * // When done with the level, unload everything\n     * await Assets.unloadBundle('level-1');\n     * // background sprite is now invalid!\n     *\n     * // Unload multiple bundles\n     * await Assets.unloadBundle([\n     *     'level-1',\n     *     'level-2',\n     *     'ui-elements'\n     * ]);\n     * ```\n     * @remarks\n     * > [!WARNING]\n     * > - All assets in the bundle will be destroyed\n     * > - Bundle needs to be reloaded to use assets again\n     * > - Make sure no sprites or other objects are using the assets\n     * @throws {Error} If the bundle is not found\n     * @see {@link Assets.addBundle} For adding bundles\n     * @see {@link Assets.loadBundle} For loading bundles\n     */\n    public async unloadBundle(bundleIds: ArrayOr<string>): Promise<void>\n    {\n        if (!this._initialized)\n        {\n            await this.init();\n        }\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const resolveResults = this.resolver.resolveBundle(bundleIds);\n\n        const promises = Object.keys(resolveResults).map((bundleId) =>\n            this._unloadFromResolved(resolveResults[bundleId]));\n\n        await Promise.all(promises);\n    }\n\n    private async _unloadFromResolved(resolveResult: ResolvedAsset | Record<string, ResolvedAsset>)\n    {\n        const resolveArray = Object.values(resolveResult);\n\n        resolveArray.forEach((resolveResult) =>\n        {\n            Cache.remove(resolveResult.src);\n        });\n\n        await this.loader.unload(resolveArray);\n    }\n\n    /**\n     * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n     * the users preferred formats order.\n     * @param options - the options to use when detecting formats\n     * @param options.preferredFormats - the preferred formats to use\n     * @param options.skipDetections - if we should skip the detections altogether\n     * @param options.detections - the detections to use\n     * @returns - the detected formats\n     */\n    private async _detectFormats(options: {\n        preferredFormats: string | string[],\n        skipDetections: boolean,\n        detections: FormatDetectionParser[]\n    }): Promise<string[]>\n    {\n        let formats: string[] = [];\n\n        // set preferred formats\n        if (options.preferredFormats)\n        {\n            formats = Array.isArray(options.preferredFormats)\n                ? options.preferredFormats : [options.preferredFormats];\n        }\n\n        // we should add any formats that are supported by the browser\n        for (const detection of options.detections)\n        {\n            if (options.skipDetections || await detection.test())\n            {\n                formats = await detection.add(formats);\n            }\n            else if (!options.skipDetections)\n            {\n                formats = await detection.remove(formats);\n            }\n        }\n\n        // remove any duplicates\n        formats = formats.filter((format, index) => formats.indexOf(format) === index);\n\n        return formats;\n    }\n\n    /**\n     * All the detection parsers currently added to the Assets class.\n     * @advanced\n     */\n    public get detections(): FormatDetectionParser[]\n    {\n        return this._detections;\n    }\n\n    /**\n     * Sets global preferences for asset loading behavior. This method configures how assets\n     * are loaded and processed across all parsers.\n     * @param preferences - Asset loading preferences\n     * @example\n     * ```ts\n     * // Basic preferences\n     * Assets.setPreferences({\n     *     crossOrigin: 'anonymous',\n     *     parseAsGraphicsContext: false\n     * });\n     * ```\n     * @remarks\n     * Preferences are applied to all compatible parsers and affect future asset loading.\n     * Common preferences include:\n     * - `crossOrigin`: CORS setting for loaded assets\n     * - `preferWorkers`: Whether to use web workers for loading textures\n     * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.\n     * @see {@link AssetsPreferences} For all available preferences\n     */\n    public setPreferences(preferences: Partial<AssetsPreferences>): void\n    {\n        // Find matching config keys in loaders with preferences\n        // and set the values\n        this.loader.parsers.forEach((parser) =>\n        {\n            if (!parser.config) return;\n\n            (Object.keys(parser.config) as (keyof AssetsPreferences)[])\n                .filter((key) => key in preferences)\n                .forEach((key) =>\n                {\n                    parser.config[key] = preferences[key];\n                });\n        });\n    }\n}\n\n/**\n * The global Assets class is a singleton that manages loading, caching, and unloading of all resources\n * in your PixiJS application.\n *\n * Key responsibilities:\n * - **URL Resolution**: Maps URLs/keys to browser-compatible resources\n * - **Resource Loading**: Handles loading and transformation of assets\n * - **Asset Caching**: Manages a global cache to prevent duplicate loads\n * - **Memory Management**: Provides unloading capabilities to free memory\n *\n * Advanced Features:\n * - **Asset Bundles**: Group and manage related assets together\n * - **Background Loading**: Load assets before they're needed over time\n * - **Format Detection**: Automatically select optimal asset formats\n *\n * Supported Asset Types:\n * | Type                | Extensions                                                       | Loaders                                                               |\n * | ------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |\n * | Textures            | `.png`, `.jpg`, `.gif`, `.webp`, `.avif`, `.svg`                 | {@link loadTextures}, {@link loadSvg}                                 |\n * | Video Textures      | `.mp4`, `.m4v`, `.webm`, `.ogg`, `.ogv`, `.h264`, `.avi`, `.mov` | {@link loadVideoTextures}                                             |\n * | Sprite Sheets       | `.json`                                                          | {@link spritesheetAsset}                                              |\n * | Bitmap Fonts        | `.fnt`, `.xml`, `.txt`                                           | {@link loadBitmapFont}                                                |\n * | Web Fonts           | `.ttf`, `.otf`, `.woff`, `.woff2`                                | {@link loadWebFont}                                                   |\n * | JSON                | `.json`                                                          | {@link loadJson}                                                      |\n * | Text                | `.txt`                                                           | {@link loadTxt}                                                       |\n * | Compressed Textures | `.basis`, `.dds`, `.ktx`, `.ktx2`                                | {@link loadBasis}, {@link loadDDS}, {@link loadKTX}, {@link loadKTX2} |\n * > [!NOTE] Some loaders allow for custom configuration, please refer to the specific loader documentation for details.\n * @example\n * ```typescript\n * import { Assets } from 'pixi.js';\n *\n * // Initialize with options (optional). You can call Assets.load directly without init.\n * await Assets.init({\n *     // Base path for all asset URLs\n *     basePath: 'https://my-cdn.com/assets/',\n *     // Manifest object that defines all assets\n *     manifest: {\n *        bundles: [{ name: 'gameAssets', assets: [] }, ...],\n *     }, *\n *     // Preferred texture settings\n *     texturePreference: {\n *         resolution: window.devicePixelRatio,\n *         format: ['avif', 'webp', 'png']\n *     }\n * });\n *\n * // Basic loading\n * const texture = await Assets.load('images/sprite.png');\n *\n * // Load multiple assets\n * const assets = await Assets.load([\n *     'images/bg.png',\n *     'images/character.png',\n *     'fonts/game.fnt'\n * ]);\n *\n * // Using aliases + multiple formats\n * await Assets.load({ alias: 'hero', src: 'images/hero.{webp,png}' });\n * const sprite = Sprite.from('hero'); // Uses the best available format\n *\n * // background loading\n * Assets.backgroundLoad(['images/level1.json', 'images/level2.json']); // Loads in the background one at a time\n *\n * // Load a bundle of assets from the manifest\n * const levelAssets = await Assets.loadBundle('gameAssets');\n * // Background loading of a bundle. This will load assets in the background one at a time.\n * // Can be interrupted at any time by calling Assets.loadBundle('gameAssets') again.\n * Assets.backgroundLoadBundle('resultsAssets');\n *\n * // Memory management\n * await Assets.unload('hero');\n * await Assets.unloadBundle('levelOne');\n * ```\n * @remarks\n * - Assets are cached automatically and only loaded once\n * - Background loading helps eliminate loading screens\n * - Format detection ensures optimal asset delivery\n * - Bundle management simplifies resource organization\n *\n * > [!IMPORTANT]\n * > When unloading assets, ensure they aren't being used elsewhere\n * > in your application to prevent missing texture references.\n * @see {@link AssetInitOptions} For initialization options\n * @see {@link AssetsPreferences} For advanced preferences\n * @see {@link BackgroundLoader} For background loading capabilities\n * @see {@link AssetsManifest} For manifest-based asset management\n * @see {@link Loader} For the underlying loading system\n * @see {@link Cache} For the caching system\n * @see {@link Resolver} For URL resolution details\n * @category assets\n * @class\n * @standard\n */\nexport const Assets = new AssetsClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.LoadParser, Assets.loader.parsers)\n    .handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers)\n    .handleByList(ExtensionType.CacheParser, Assets.cache.parsers)\n    .handleByList(ExtensionType.DetectionParser, Assets.detections);\nextensions.add(\n    cacheTextureArray,\n\n    detectDefaults,\n    detectAvif,\n    detectWebp,\n    detectMp4,\n    detectOgv,\n    detectWebm,\n\n    loadJson,\n    loadTxt,\n    loadWebFont,\n    loadSvg,\n    loadTextures,\n    loadVideoTextures,\n    loadBitmapFont,\n\n    bitmapFontCachePlugin,\n\n    resolveTextureUrl,\n    resolveJsonUrl\n);\n\nconst assetKeyMap = {\n    loader: ExtensionType.LoadParser,\n    resolver: ExtensionType.ResolveParser,\n    cache: ExtensionType.CacheParser,\n    detection: ExtensionType.DetectionParser,\n};\n\ntype AssetType = keyof typeof assetKeyMap;\n\n// Split the Asset extension into it's various parts\n// these are handled in the Assets.ts file\nextensions.handle(ExtensionType.Asset, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.entries(assetKeyMap)\n        .filter(([key]) => !!ref[key as AssetType])\n        .forEach(([key, type]) => extensions.add(Object.assign(\n            ref[key as AssetType],\n            // Allow the function to optionally define it's own\n            // ExtensionMetadata, the use cases here is priority for LoaderParsers\n            { extension: ref[key as AssetType].extension ?? type },\n        )));\n}, (extension) =>\n{\n    const ref = extension.ref as AssetExtension;\n\n    Object.keys(assetKeyMap)\n        .filter((key) => !!ref[key as AssetType])\n        .forEach((key) => extensions.remove(ref[key as AssetType]));\n});\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HTMLTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @example\n * ```ts\n * const text: TextString = 'Hello Pixi!';\n * const text2: TextString = 12345;\n * const text3: TextString = { toString: () => 'Hello Pixi!' };\n * ```\n * @category text\n * @standard\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * This is used to allow for any text style to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyle, HTMLTextStyle } from 'pixi.js';\n * const style: AnyTextStyle = new TextStyle({ fontSize: 24 });\n * const htmlStyle: AnyTextStyle = new HTMLTextStyle({ fontSize: '24px' });\n * ```\n * @category text\n * @standard\n * @see TextStyle\n * @see HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * This is used to allow for any text style options to be passed to a text object.\n * @example\n * ```ts\n * import { TextStyleOptions, HTMLTextStyleOptions } from 'pixi.js';\n * const styleOptions: AnyTextStyleOptions = { fontSize: 24 } as TextStyleOptions;\n * const htmlStyleOptions: AnyTextStyleOptions = { fontSize: '24px' } as HTMLTextStyleOptions;\n * ```\n * @category text\n * @standard\n * @see TextStyleOptions\n * @see HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for creating text objects in PixiJS. This interface defines the common properties\n * used across different text rendering implementations (Canvas, HTML, and Bitmap).\n * @example\n * ```ts\n * // Create basic text with minimal options\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010\n *     }\n * });\n *\n * // Create text with advanced styling\n * const styledText = new Text({\n *     text: 'Styled Text',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: new FillGradient({\n *             end: { x: 1, y: 1 },\n *             stops: [\n *                 { color: 0xff0000, offset: 0 }, // Red at start\n *                 { color: 0x0000ff, offset: 1 }, // Blue at end\n *             ]\n *         }),\n *         stroke: { color: '#4a1850', width: 5 },\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6\n *         },\n *         align: 'center'\n *     },\n *     anchor: 0.5,\n *     resolution: window.devicePixelRatio\n * });\n *\n * // Create multiline text with word wrap\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will wrap onto multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30\n *     },\n *     resolution: 2,\n *     roundPixels: true\n * });\n * ```\n * @category text\n * @standard\n * @noInheritDoc\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends PixiMixins.TextOptions, ViewContainerOptions\n{\n    /**\n     * The anchor point of the text that controls the origin point for positioning and rotation.\n     * Can be a number (same value for x/y) or a PointData object.\n     * - (0,0) is top-left\n     * - (0.5,0.5) is center\n     * - (1,1) is bottom-right\n     * ```ts\n     * // Set anchor to center\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n     * });\n     * // Set anchor to top-left\n     * const text2 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 0, y: 0 } // Top-left corner\n     * });\n     * // Set anchor to bottom-right\n     * const text3 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 1, y: 1 } // Bottom-right corner\n     * });\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    anchor?: PointData | number;\n    /**\n     * The text content to display. Use '\\n' for line breaks.\n     * Accepts strings, numbers, or objects with toString() method.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     * });\n     * const multilineText = new Text({\n     *     text: 'Line 1\\nLine 2\\nLine 3',\n     * });\n     * const numberText = new Text({\n     *     text: 12345, // Will be converted to '12345'\n     * });\n     * const objectText = new Text({\n     *     text: { toString: () => 'Object Text' }, // Custom toString\n     * });\n     * ```\n     * @default ''\n     */\n    text?: TextString;\n    /**\n     * The resolution/device pixel ratio for rendering.\n     * Higher values result in sharper text at the cost of performance.\n     * Set to null for auto-resolution based on device.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     resolution: 2 // High DPI for sharper text\n     * });\n     * const autoResText = new Text({\n     *     text: 'Auto Resolution',\n     *     resolution: null // Use device's pixel ratio\n     * });\n     * ```\n     * @default null\n     */\n    resolution?: number;\n    /**\n     * The style configuration for the text.\n     * Can be a TextStyle instance or a configuration object.\n     * Supports canvas text styles, HTML text styles, and bitmap text styles.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Styled Text',\n     *     style: {\n     *         fontSize: 24,\n     *         fill: 0xff1010, // Red color\n     *         fontFamily: 'Arial',\n     *         align: 'center', // Center alignment\n     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n     *         dropShadow: {\n     *             color: '#000000', // Black shadow\n     *             blur: 4, // Shadow blur\n     *             distance: 6 // Shadow distance\n     *         }\n     *     }\n     * });\n     * const htmlText = new HTMLText({\n     *     text: 'HTML Styled Text',\n     *     style: {\n     *         fontSize: '20px',\n     *         fill: 'blue',\n     *         fontFamily: 'Verdana',\n     *     }\n     * });\n     * const bitmapText = new BitmapText({\n     *     text: 'Bitmap Styled Text',\n     *     style: {\n     *         fontName: 'Arial',\n     *         fontSize: 32,\n     *     }\n     * })\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /**\n     * Whether to round the x/y position to whole pixels.\n     * Enabling can prevent anti-aliasing of text edges but may cause slight position shifting.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Rounded Text',\n     *     roundPixels: true // Rounds position to whole pixels\n     * });\n     * @default false\n     */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see Text\n * @see BitmapText\n * @see HTMLText\n * @category text\n * @advanced\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n    TEXT_OPTIONS extends TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS> = TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n    GPU_DATA extends { destroy: () => void } = any\n> extends ViewContainer<GPU_DATA> implements View\n{\n    /** @internal */\n    public batched = true;\n    /** @internal */\n    public _anchor: ObservablePoint;\n\n    /** @internal */\n    public _resolution: number = null;\n    /** @internal */\n    public _autoResolution: boolean = true;\n\n    /** @internal */\n    public _style: TEXT_STYLE;\n    /** @internal */\n    public _didTextUpdate = true;\n\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TEXT_OPTIONS,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    /**\n     * The anchor point of the text that controls the origin point for positioning and rotation.\n     * Can be a number (same value for x/y) or a PointData object.\n     * - (0,0) is top-left\n     * - (0.5,0.5) is center\n     * - (1,1) is bottom-right\n     * ```ts\n     * // Set anchor to center\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }\n     * });\n     * // Set anchor to top-left\n     * const text2 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 0, y: 0 } // Top-left corner\n     * });\n     * // Set anchor to bottom-right\n     * const text3 = new Text({\n     *     text: 'Hello Pixi!',\n     *     anchor: { x: 1, y: 1 } // Bottom-right corner\n     * });\n     * ```\n     * @default { x: 0, y: 0 }\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     * The text content to display. Use '\\n' for line breaks.\n     * Accepts strings, numbers, or objects with toString() method.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     * });\n     * const multilineText = new Text({\n     *     text: 'Line 1\\nLine 2\\nLine 3',\n     * });\n     * const numberText = new Text({\n     *     text: 12345, // Will be converted to '12345'\n     * });\n     * const objectText = new Text({\n     *     text: { toString: () => 'Object Text' }, // Custom toString\n     * });\n     *\n     * // Update text dynamically\n     * text.text = 'Updated Text'; // Re-renders with new text\n     * text.text = 67890; // Updates to '67890'\n     * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method\n     * // Clear text\n     * text.text = ''; // Clears the text\n     * ```\n     * @default ''\n     */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    /**\n     * The resolution/device pixel ratio for rendering.\n     * Higher values result in sharper text at the cost of performance.\n     * Set to null for auto-resolution based on device.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     resolution: 2 // High DPI for sharper text\n     * });\n     * const autoResText = new Text({\n     *     text: 'Auto Resolution',\n     *     resolution: null // Use device's pixel ratio\n     * });\n     * ```\n     * @default null\n     */\n    set resolution(value: number)\n    {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * The style configuration for the text.\n     * Can be a TextStyle instance or a configuration object.\n     * Supports canvas text styles, HTML text styles, and bitmap text styles.\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Styled Text',\n     *     style: {\n     *         fontSize: 24,\n     *         fill: 0xff1010, // Red color\n     *         fontFamily: 'Arial',\n     *         align: 'center', // Center alignment\n     *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke\n     *         dropShadow: {\n     *             color: '#000000', // Black shadow\n     *             blur: 4, // Shadow blur\n     *             distance: 6 // Shadow distance\n     *         }\n     *     }\n     * });\n     * const htmlText = new HTMLText({\n     *     text: 'HTML Styled Text',\n     *     style: {\n     *         fontSize: '20px',\n     *         fill: 'blue',\n     *         fontFamily: 'Verdana',\n     *     }\n     * });\n     * const bitmapText = new BitmapText({\n     *     text: 'Bitmap Styled Text',\n     *     style: {\n     *         fontName: 'Arial',\n     *         fontSize: 32,\n     *     }\n     * })\n     *\n     * // Update style dynamically\n     * text.style = {\n     *     fontSize: 30, // Change font size\n     *     fill: 0x00ff00, // Change color to green\n     *     align: 'right', // Change alignment to right\n     *     stroke: { color: '#000000', width: 2 }, // Add black stroke\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style ||= {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set width directly\n     * texture.width = 200;\n     * console.log(texture.scale.x); // Scale adjusted to match width\n     *\n     * // For better performance when setting both width and height\n     * texture.setSize(300, 400); // Avoids recalculating bounds twice\n     * ```\n     */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set.\n     * @example\n     * ```ts\n     * // Set height directly\n     * texture.height = 200;\n     * console.log(texture.scale.y); // Scale adjusted to match height\n     *\n     * // For better performance when setting both width and height\n     * texture.setSize(300, 400); // Avoids recalculating bounds twice\n     * ```\n     */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.\n     * This is faster than getting width and height separately as it only calculates the bounds once.\n     * @example\n     * ```ts\n     * // Basic size retrieval\n     * const text = new Text({\n     *     text: 'Hello Pixi!',\n     *     style: { fontSize: 24 }\n     * });\n     * const size = text.getSize();\n     * console.log(`Size: ${size.width}x${size.height}`);\n     *\n     * // Reuse existing size object\n     * const reuseSize = { width: 0, height: 0 };\n     * text.getSize(reuseSize);\n     * ```\n     * @param out - Optional object to store the size in, to avoid allocating a new object\n     * @returns The size of the Sprite\n     * @see {@link Text#width} For getting just the width\n     * @see {@link Text#height} For getting just the height\n     * @see {@link Text#setSize} For setting both width and height\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting width and height separately as it only recalculates bounds once.\n     * @example\n     * ```ts\n     * // Basic size setting\n     * const text = new Text({\n     *    text: 'Hello Pixi!',\n     *    style: { fontSize: 24 }\n     * });\n     * text.setSize(100, 200); // Width: 100, Height: 200\n     *\n     * // Set uniform size\n     * text.setSize(100); // Sets both width and height to 100\n     *\n     * // Set size with object\n     * text.setSize({\n     *     width: 200,\n     *     height: 300\n     * });\n     * ```\n     * @param value - This can be either a number or a {@link Size} object\n     * @param height - The height to set. Defaults to the value of `width` if not provided\n     * @see {@link Text#width} For setting width only\n     * @see {@link Text#height} For setting height only\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this.bounds.width);\n        height !== undefined && this._setHeight(height, this.bounds.height);\n    }\n\n    /**\n     * Checks if the object contains the given point in local coordinates.\n     * Uses the text's bounds for hit testing.\n     * @example\n     * ```ts\n     * // Basic point check\n     * const localPoint = { x: 50, y: 25 };\n     * const contains = text.containsPoint(localPoint);\n     * console.log('Point is inside:', contains);\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is within the text's bounds\n     * @see {@link Container#toLocal} For converting global coordinates to local\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    /** @internal */\n    public override onViewUpdate()\n    {\n        if (!this.didViewUpdate) this._didTextUpdate = true;\n        super.onViewUpdate();\n    }\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @example\n     * // Destroys the text and its style\n     * text.destroy({ style: true, texture: true, textureSource: true });\n     * text.destroy(true);\n     * text.destroy() // Destroys the text, but not its style\n     */\n    public override destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n\n    /**\n     * Returns a unique key for this instance.\n     * This key is used for caching.\n     * @returns {string} Unique key for the instance\n     */\n    public get styleKey(): string\n    {\n        return `${this._text}:${this._style.styleKey}:${this._resolution}`;\n    }\n}\n\n/**\n * Helper function to ensure consistent handling of text options across different text classes.\n * This function handles both the new options object format and the deprecated parameter format.\n * @example\n * // New recommended way:\n * const options = ensureTextOptions([{\n *     text: \"Hello\",\n *     style: { fontSize: 20 }\n * }], \"Text\");\n *\n * // Deprecated way (will show warning in debug):\n * const options = ensureTextOptions([\"Hello\", { fontSize: 20 }], \"Text\");\n * @param args - Arguments passed to text constructor\n * @param name - Name of the text class (used in deprecation warning)\n * @returns Normalized text options object\n * @template TEXT_OPTIONS - The type of the text options\n * @internal\n */\nexport function ensureTextOptions<\n    TEXT_OPTIONS extends TextOptions\n>(\n    args: any[],\n    name: string\n): TEXT_OPTIONS\n{\n    let options = (args[0] ?? {}) as TEXT_OPTIONS;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as unknown as TEXT_OPTIONS;\n    }\n\n    return options;\n}\n", "import { TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { AbstractText, ensureTextOptions } from './AbstractText';\nimport { type BatchableText } from './canvas/BatchableText';\nimport { CanvasTextGenerator } from './canvas/CanvasTextGenerator';\nimport { CanvasTextMetrics } from './canvas/CanvasTextMetrics';\nimport { TextStyle } from './TextStyle';\n\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { TextOptions, TextString } from './AbstractText';\nimport type { TextStyleOptions } from './TextStyle';\n\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Text extends PixiMixins.Text, AbstractText<\n    TextStyle,\n    TextStyleOptions,\n    CanvasTextOptions,\n    BatchableText\n> {}\n\n/**\n * Constructor options used for `Text` instances. These options extend TextOptions with\n * canvas-specific features like texture styling.\n * @example\n * ```ts\n * // Create basic canvas text\n * const text = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontSize: 24,\n *         fill: 0xff1010,\n *     }\n * });\n *\n * // Create text with custom texture style\n * const customText = new Text({\n *     text: 'Custom Text',\n *     style: {\n *         fontSize: 32,\n *         fill: 0x4a4a4a\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n * ```\n * @extends TextOptions\n * @category text\n * @standard\n */\nexport interface CanvasTextOptions extends TextOptions\n{\n    /**\n     * Optional texture style to use for the text texture. This allows fine control over\n     * how the text is rendered to a texture before being displayed.\n     *\n     * The texture style can affect:\n     * - Scale mode (nearest/linear)\n     * - Resolution\n     * - Format (rgb/rgba)\n     * - Alpha handling\n     * @example\n     * ```ts\n     * const text = new Text({\n     *     text: 'Crisp Text',\n     *     textureStyle: {\n     *         scaleMode: 'nearest', // Pixel-perfect scaling\n     *     }\n     * });\n     * ```\n     * @advanced\n     */\n    textureStyle?: TextureStyle | TextureStyleOptions;\n}\n\n/**\n * A powerful text rendering class that creates one or multiple lines of text using the Canvas API.\n * Provides rich text styling capabilities with runtime modifications.\n *\n * Key features:\n * - Dynamic text content and styling\n * - Multi-line text support\n * - Word wrapping\n * - Custom texture styling\n * - High-quality text rendering\n * @example\n * ```ts\n * import { Text } from 'pixi.js';\n *\n * // Basic text creation\n * const basicText = new Text({\n *     text: 'Hello Pixi!',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: 0xff1010,\n *         align: 'center',\n *     }\n * });\n *\n * // Rich text with multiple styles\n * const richText = new Text({\n *     text: 'Styled\\nMultiline\\nText',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 36,\n *         fill: 'red',\n *         stroke: { color: '#4a1850', width: 5 },\n *         align: 'center',\n *         lineHeight: 45,\n *         dropShadow: {\n *             color: '#000000',\n *             blur: 4,\n *             distance: 6,\n *         }\n *     },\n *     anchor: 0.5,\n * });\n *\n * // Text with custom texture settings\n * const crispText = new Text({\n *     text: 'High Quality Text',\n *     style: {\n *         fontSize: 24,\n *         fill: 0x4a4a4a,\n *     },\n *     textureStyle: {\n *         scaleMode: 'nearest',\n *     }\n * });\n *\n * // Word-wrapped text\n * const wrappedText = new Text({\n *     text: 'This is a long piece of text that will automatically wrap to multiple lines',\n *     style: {\n *         fontSize: 20,\n *         wordWrap: true,\n *         wordWrapWidth: 200,\n *         lineHeight: 30,\n *     }\n * });\n * ```\n *\n * Performance Considerations:\n * - Each text instance creates its own texture\n * - Texture is regenerated when text or style changes\n * - Use BitmapText for better performance with static text\n * - Consider texture style options for quality vs performance tradeoffs\n * @category text\n * @standard\n * @see {@link TextStyle} For detailed style options\n * @see {@link BitmapText} For better performance with static text\n * @see {@link HTMLText} For HTML/CSS-based text rendering\n */\nexport class Text\n    extends AbstractText<TextStyle, TextStyleOptions, CanvasTextOptions, BatchableText>\n    implements View\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'text';\n\n    /**\n     * Optional texture style to use for the text.\n     * > [!NOTE] Text is not updated when this property is updated,\n     * > you must update the text manually by calling `text.onViewUpdate()`\n     * @advanced\n     */\n    public textureStyle?: TextureStyle;\n\n    /**\n     * @param {CanvasTextOptions} options - The options of the text.\n     */\n    constructor(options?: CanvasTextOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(text?: TextString, options?: Partial<TextStyle>);\n    constructor(...args: [CanvasTextOptions?] | [TextString, Partial<TextStyle>])\n    {\n        const options = ensureTextOptions<CanvasTextOptions>(args, 'Text');\n\n        super(options, TextStyle);\n\n        if (options.textureStyle)\n        {\n            this.textureStyle = options.textureStyle instanceof TextureStyle\n                ? options.textureStyle\n                : new TextureStyle(options.textureStyle);\n        }\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const bounds = this._bounds;\n        const anchor = this._anchor;\n\n        let width = 0;\n        let height = 0;\n\n        if (this._style.trim)\n        {\n            const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n                text: this.text,\n                style: this._style,\n                resolution: 1,\n            });\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            width = frame.width;\n            height = frame.height;\n        }\n        else\n        {\n            const canvasMeasurement = CanvasTextMetrics.measureText(\n                this._text,\n                this._style\n            );\n\n            width = canvasMeasurement.width;\n            height = canvasMeasurement.height;\n        }\n\n        bounds.minX = (-anchor._x * width);\n        bounds.maxX = bounds.minX + width;\n        bounds.minY = (-anchor._y * height);\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { browserExt } from './environment-browser/browserExt';\nimport { webworkerExt } from './environment-webworker/webworkerExt';\nimport { extensions } from './extensions/Extensions';\nimport './rendering/init';\nimport './spritesheet/init';\n\nexport * from './accessibility';\nexport * from './advanced-blend-modes';\nexport * from './app';\nexport * from './assets';\nexport * from './color';\nexport * from './compressed-textures';\nexport * from './culling';\nexport * from './dom';\nexport * from './environment';\nexport * from './environment-browser';\nexport * from './environment-webworker';\nexport * from './events';\nexport * from './extensions';\nexport * from './filters';\nexport * from './maths';\nexport * from './prepare';\nexport * from './rendering';\nexport * from './scene';\nexport * from './spritesheet';\nexport * from './ticker';\nexport * from './utils';\n\nextensions.add(browserExt, webworkerExt);\n", "import * as PIXI from 'pixi.js';\n\nexport function openFullscreen() {\n  let elem = document.documentElement;\n  if (elem.requestFullscreen) {\n    elem.requestFullscreen();\n  } else if ((elem as any).webkitRequestFullscreen) {\n    /* Safari */\n    (elem as any).webkitRequestFullscreen();\n  } else if ((elem as any).msRequestFullscreen) {\n    /* IE11 */\n    (elem as any).msRequestFullscreen();\n  }\n}\n\nexport function closeFullscreen() {\n  if (document.exitFullscreen) {\n    document.exitFullscreen();\n  } else if ((document as any).webkitExitFullscreen) {\n    /* Safari */\n    (document as any).webkitExitFullscreen();\n  } else if ((document as any).msExitFullscreen) {\n    /* IE11 */\n    (document as any).msExitFullscreen();\n  }\n}\n\nexport const pixi_large_text = new PIXI.TextStyle({\n  fontFamily: 'Arial',\n  fontSize: 64,\n  fill: 0x000000, // White color\n  align: 'center'\n});\n\nexport const pixi_huge_text = new PIXI.TextStyle({\n  fontFamily: 'Arial',\n  fontSize: 86,\n  fill: 0x000000, // White color\n  align: 'center'\n});\n\nexport function delay(time_ms: number, callback: Function | null = null) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      try {\n        if (callback) {\n          resolve(callback());\n        } else {\n          resolve(null);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    }, time_ms);\n  });\n}\n\nexport function delay_ms(time_ms: number) {\n  return () => delay(time_ms)\n}\n\nexport function linspace(\n  start: number,\n  stop: number,\n  num: number = 50,\n  endpoint: boolean = true,\n): Array<number> {\n  num = Math.round(num);\n  let delta = 0;\n  if (endpoint) {\n    delta = (stop - start) / (num - 1);\n  } else {\n    delta = (stop - start) / num;\n  }\n  let result = new Array<number>(num);\n  result[0] = start;\n  for (let i = 1; i < num; i++) {\n    result[i] = result[i - 1] + delta;\n  }\n  return result;\n}\n\nexport function arange(\n  start: number = 0,\n  stop: number = 10,\n  step: number = 1,\n): Array<number> {\n  const size = Math.floor((stop - start) / step);\n  let result = new Array<number>(size);\n  result[0] = start;\n  for (let i = 1; i < size; i++) {\n    result[i] = result[i - 1] + step;\n  }\n  return result;\n}\n\nexport function shuffle(arr_in: any[], inplace: boolean = false) {\n  let arr: any[];\n  if (inplace) {\n    arr = arr_in;\n  } else {\n    arr = JSON.parse(JSON.stringify(arr_in));\n  }\n  for (let i = arr.length - 1; i >= 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n  return arr;\n}\n\nexport function any(arr: number[]) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > 0) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function getRandomFloat(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nexport function epochTimestamp() {\n  return performance.timeOrigin + performance.now()\n}\n\nexport function download(\n  filename: string,\n  content: string,\n  mimeType: string = \"application/json\",\n) {\n  const a = document.createElement(\"a\");\n  const blob = new Blob([content], { type: mimeType });\n  const url = URL.createObjectURL(blob);\n  a.setAttribute(\"href\", url);\n  a.setAttribute(\"download\", filename);\n  a.click();\n}", "import { VisStimConfig, StimulusSetInfo, StimEvent } from \"./interfaces\";\nimport {\n  openFullscreen, pixi_large_text, shuffle, any, epochTimestamp,\n  pixi_huge_text, getRandomFloat, download, closeFullscreen\n} from \"./helpers\";\nimport * as PIXI from 'pixi.js';\n\nconst app = new PIXI.Application();\n\nconst defaultConfig: VisStimConfig = {\n  start_baseline_s: 180,\n  start_fixation_ms: 1500,\n  num_repeat: 3,\n  show_time_ms: 5000,\n  end_white_ms: 1500,\n  end_baseline_s: 180,\n  jitter_ms: 500,\n};\n\nconst DATA_SERVER_PORT = 3200;\nconst VISUAL_STIM_PATH = \"rorschach_inkblot_vs_genometry\"\nconst WS_URL = `ws://127.0.0.1:${DATA_SERVER_PORT}/${VISUAL_STIM_PATH}/ws`;\nlet socket: WebSocket | undefined;\nconst MAX_RECONNECT = 5;\nlet reconnect_count = 0;\nlet reconnect_timeout: number;\n\nexport function getDefaultStartConfig(): VisStimConfig {\n  return { ...defaultConfig };\n}\n\nexport function startConfigFromUrl() {\n  const params: URLSearchParams = new URLSearchParams(window.location.search);\n  return updateConfig(params);\n}\n\nexport function updateConfig(\n  params: URLSearchParams,\n  input_config: VisStimConfig = defaultConfig,\n) {\n  let config = { ...input_config };\n  for (const key of Object.keys(config)) {\n    const param_val = params.get(key);\n    if (param_val) {\n      if (typeof config[key] === \"number\") config[key] = parseFloat(param_val);\n    }\n  }\n  return config;\n}\n\nexport function updateSearchURL(start_config: VisStimConfig) {\n  const curr_url_search_string = window.location.search;\n  const url_params: URLSearchParams = new URLSearchParams(\n    curr_url_search_string,\n  );\n  for (const [key, val] of Object.entries(start_config)) {\n    url_params.set(key, val);\n  }\n  if (url_params.toString() !== curr_url_search_string) {\n    const new_url = `${window.location.protocol}//${window.location.host}${window.location.pathname}?${url_params.toString()}`;\n    window.history.pushState({ path: new_url }, \"\", new_url);\n  }\n}\n\nasync function setupPixiApp(parentElement: HTMLElement) {\n  await app.init({\n    resizeTo: window,\n    background: 0xffffff,\n    autoDensity: true,\n  });\n  // const container = document.getElementById('app-container');\n  if (typeof parentElement === \"undefined\") {\n    parentElement = document.createElement(\"div\");\n    document.body.appendChild(parentElement);\n  }\n\n  if (parentElement) {\n    parentElement.appendChild(app.canvas as HTMLCanvasElement);\n  } else {\n    console.error(\"Could not find the 'app-container' element.\");\n  }\n  return app.canvas\n}\n\nexport async function prepVisStimCtrlPanel(\n  start_config: VisStimConfig,\n  parentElement?: HTMLElement,\n) {\n  updateSearchURL(start_config);\n  // console.log(start_config);\n\n  const control_panel_div = document.createElement(\"div\");\n  control_panel_div.classList.add(\"control-panel-div\");\n  if (typeof parentElement === \"undefined\") {\n    parentElement = document.createElement(\"div\");\n    document.body.appendChild(parentElement);\n  }\n\n  parentElement.appendChild(control_panel_div);\n  await setupPixiApp(parentElement)\n  app.canvas.classList.add(\"hide\");\n\n  const timing_form = createDiv(\"timing_form\", control_panel_div, [\n    \"flat-form\",\n  ]);\n  control_panel_div.appendChild(timing_form);\n\n\n  const start_baseline_input_id = \"start_baseline_time_s\";\n  const start_baseline_label = createLabel(\n    \"start_baseline_time_span\",\n    timing_form,\n    start_baseline_input_id,\n    [\"form-label\", \"label-lg\"],\n    \"Start Baseline(s):\",\n  );\n\n  const start_baseline_input = createNumInput(\n    start_baseline_input_id,\n    timing_form,\n    [\"form-input\", \"input-lg\"],\n    5,\n    300,\n    1,\n    start_config.start_baseline_s,\n  );\n  start_baseline_input.setAttribute(\"style\", \"width:4em;margin-right: 10px;margin-left:5px;\");\n\n  const end_baseline_input_id = \"end_baseline_time_s\";\n  const end_baseline_label = createLabel(\n    \"end_baseline_time_span\",\n    timing_form,\n    end_baseline_input_id,\n    [\"form-label\", \"label-lg\"],\n    \"End Baseline(s):\",\n  );\n\n  const end_baseline_input = createNumInput(\n    end_baseline_input_id,\n    timing_form,\n    [\"form-input\", \"input-lg\"],\n    5,\n    300,\n    1,\n    start_config.end_baseline_s,\n  );\n  end_baseline_input.setAttribute(\"style\", \"width:4em;margin-right: 10px;margin-left:5px;\");\n\n  const start_fixation_input_id = \"start_fixation_time_ms\";\n  const start_fixation_label = createLabel(\n    \"start_fixation_time_span\",\n    timing_form,\n    start_fixation_input_id,\n    [\"form-label\", \"label-lg\"],\n    \"Start Fixation (ms):\",\n  );\n\n  const start_fixation_input = createNumInput(\n    start_fixation_input_id,\n    timing_form,\n    [\"form-input\", \"input-lg\"],\n    1000,\n    10000,\n    1,\n    start_config.start_fixation_ms,\n  );\n  start_fixation_input.setAttribute(\"style\", \"width: 4.5em;margin-right: 10px;margin-left:5px;\");\n\n  const end_white_input_id = \"end_white_time_ms\";\n  const end_white_label = createLabel(\n    \"end_white_time_span\",\n    timing_form,\n    end_white_input_id,\n    [\"form-label\", \"label-lg\"],\n    \"End White (ms):\",\n  );\n\n  const end_white_input = createNumInput(\n    end_white_input_id,\n    timing_form,\n    [\"form-input\", \"input-lg\"],\n    1000,\n    10000,\n    1,\n    start_config.end_white_ms,\n  );\n  end_white_input.setAttribute(\"style\", \"width: 4.5em;margin-right: 10px;margin-left:5px;\");\n\n  const jitter_input_id = \"jitter_time_ms\";\n  const jitter_label = createLabel(\n    \"jitter_time_span\",\n    timing_form,\n    jitter_input_id,\n    [\"form-label\", \"label-lg\"],\n    \"Jitter time (ms):\",\n  );\n\n  const jitter_input = createNumInput(\n    jitter_input_id,\n    timing_form,\n    [\"form-input\", \"input-lg\"],\n    0,\n    1000,\n    1,\n    start_config.jitter_ms,\n  );\n  jitter_input.setAttribute(\"style\", \"width: 4.5em;margin-right: 10px;margin-left:5px;\");\n\n\n  start_baseline_input.onchange = (event: Event) => {\n    if (event.target) {\n      if (\"value\" in event.target) {\n        if (typeof event.target.value === \"number\") {\n          start_config.start_baseline_s = event.target.value;\n        } else if (typeof event.target.value === \"string\") {\n          start_config.start_baseline_s = parseFloat(event.target.value);\n        }\n      }\n    }\n    start_baseline_input.value = start_config.start_baseline_s.toString();\n    updateSearchURL(start_config);\n  };\n\n  end_baseline_input.onchange = (event: Event) => {\n    if (event.target) {\n      if (\"value\" in event.target) {\n        if (typeof event.target.value === \"number\") {\n          start_config.end_baseline_s = event.target.value;\n        } else if (typeof event.target.value === \"string\") {\n          start_config.end_baseline_s = parseFloat(event.target.value);\n        }\n      }\n    }\n    end_baseline_input.value = start_config.end_baseline_s.toString();\n    updateSearchURL(start_config);\n  };\n\n  start_fixation_input.onchange = (event: Event) => {\n    if (event.target) {\n      if (\"value\" in event.target) {\n        if (typeof event.target.value === \"number\") {\n          start_config.start_fixation_ms = event.target.value;\n        } else if (typeof event.target.value === \"string\") {\n          start_config.start_fixation_ms = parseFloat(event.target.value);\n        }\n      }\n    }\n    start_fixation_input.value = start_config.start_fixation_ms.toString();\n    updateSearchURL(start_config);\n  };\n\n  end_white_input.onchange = (event: Event) => {\n    if (event.target) {\n      if (\"value\" in event.target) {\n        if (typeof event.target.value === \"number\") {\n          start_config.end_white_ms = event.target.value;\n        } else if (typeof event.target.value === \"string\") {\n          start_config.end_white_ms = parseFloat(event.target.value);\n        }\n      }\n    }\n    end_white_input.value = start_config.end_white_ms.toString();\n    updateSearchURL(start_config);\n  };\n\n  const add_vis_stim_in = document.createElement(\"input\");\n  add_vis_stim_in.setAttribute(\"type\", \"file\");\n  add_vis_stim_in.setAttribute(\"id\", \"vis-stim-upload\");\n  add_vis_stim_in.setAttribute(\"style\", \"display:none\");\n  add_vis_stim_in.setAttribute(\"accept\", \"image/*\");\n  add_vis_stim_in.multiple = true;\n  add_vis_stim_in.onchange = async (event: Event) => {\n    const target = event.target as HTMLInputElement;\n    const files = target.files as FileList;\n    if (files.length > 0) {\n      await addVisStimSet(files);\n    }\n  };\n\n  const add_vis_sim_btn = document.createElement(\"button\");\n  add_vis_sim_btn.classList.add(\"btn\", \"btn-lg\", \"btn-primary\")\n\n  add_vis_sim_btn.innerHTML = \"Add Stim Set\";\n  timing_form.appendChild(add_vis_sim_btn);\n  add_vis_sim_btn.onclick = () => {\n    add_vis_stim_in.click();\n  };\n\n  const vis_stim = createDiv(\"vis_stim\", control_panel_div, [\"flat-flex-col\"]);\n  // vis_stim.setAttribute(\"style\", \"width:100%\");\n  control_panel_div.appendChild(vis_stim);\n  const stim_info_list: StimulusSetInfo[] = []\n\n  const play_stim_div = createDiv(\"play_stim\", control_panel_div, [\"flat-flex-row\"]);\n  // play_stim_div.setAttribute(\"style\", \"width:100%;margin-top:2vh\");\n  control_panel_div.appendChild(play_stim_div);\n\n  let show_progress = true\n  const show_progress_set = createSwitch(\"Show progress\", (event: any) => {\n    if (event.target?.checked) {\n      show_progress = true;\n    } else {\n      show_progress = false;\n    }\n  })\n  const show_progress_input = show_progress_set.children.item(0) as HTMLInputElement;\n  show_progress_input.disabled = true;\n  show_progress_input.checked = show_progress;\n  // shuffle_between_set.classList.add(\"width_12vw\");\n  play_stim_div.appendChild(show_progress_set);\n\n\n  let shuffle_between = true\n  const shuffle_between_set = createSwitch(\"Shuffle between set\", (event: any) => {\n    if (event.target?.checked) {\n      shuffle_between = true;\n    } else {\n      shuffle_between = false;\n    }\n  })\n  const shuffle_between_input = shuffle_between_set.children.item(0) as HTMLInputElement;\n  shuffle_between_input.disabled = true;\n  shuffle_between_input.checked = shuffle_between;\n  // shuffle_between_set.classList.add(\"width_12vw\");\n  play_stim_div.appendChild(shuffle_between_set);\n\n\n  let shuffle_within = true\n  const shuffle_within_set = createSwitch(\"Shuffle within set\", (event: any) => {\n    if (event.target?.checked) {\n      shuffle_within = true;\n    } else {\n      shuffle_within = false;\n    }\n  })\n  const shuffle_within_input = shuffle_within_set.children.item(0) as HTMLInputElement;\n  shuffle_within_input.disabled = true;\n  shuffle_within_input.checked = shuffle_within;\n  // shuffle_within_set.classList.add(\"width_12vw\");\n  play_stim_div.appendChild(shuffle_within_set);\n\n  const play_stim_button = document.createElement(\"button\");\n  play_stim_button.classList.add(\"btn\", \"btn-lg\", \"btn-primary\");\n  play_stim_button.disabled = true;\n  play_stim_button.textContent = \"Start experiment\";\n  play_stim_div.appendChild(play_stim_button);\n  let timeout = 0;\n\n  let my_promise: Promise<any>\n  let stim_order_i = -1\n  let stim_set_i = -1\n  let stim_seq_i = -1\n  let event_list: StimEvent[] = []\n\n  function eventGen(epoch_time_ms: number, type: string, event: string, verbose = true) {\n    let e = {\n      event: {\n        stim_order_i: stim_order_i,\n        stim_set_num: stim_set_i,\n        stim_seq_num: stim_seq_i,\n        stim_file_name: \"\",\n        type: type,\n        event: event,\n      },\n      epoch_time_ms: epoch_time_ms,\n    }\n    if ((stim_set_i > -1) && (stim_seq_i > -1)) {\n      e.event.stim_file_name = stim_info_list[stim_set_i].stim_info[stim_seq_i].file.name\n    }\n    if (verbose) {\n      console.log(e);\n    }\n    setTimeout(() => {\n      if (socket?.readyState === WebSocket.OPEN) {\n        e[\"send_epoch_time_ms\"] = epochTimestamp();\n        socket.send(JSON.stringify(e))\n      }\n    }, 0)\n    return e\n  }\n\n  play_stim_button.onclick = (event: Event) => {\n    event_list = [];\n    const stim_seq = generateStimSeq(stim_info_list, shuffle_within, shuffle_between);\n    my_promise = Promise.resolve();\n    document.addEventListener(\"keydown\", on_key_down);\n    control_panel_div.classList.add(\"hide\");\n    app.canvas.classList.remove(\"hide\");\n    openFullscreen();\n    for (let stim_set_i = 0; stim_set_i < stim_info_list.length; stim_set_i++) {\n      const stim_set = stim_info_list[stim_set_i];\n      for (let stim_i = 0; stim_i < stim_set.stim_info.length; stim_i++) {\n        stim_set.stim_info[stim_i].sprite.x = app.screen.width / 2\n        stim_set.stim_info[stim_i].sprite.y = app.screen.height / 2\n      }\n    }\n    my_promise\n      .then(start)\n      .then(baseline_start)\n      .then(show_stim_sequence(stim_seq, show_progress))\n      .then(baseline_end)\n      .then(closeFullscreen)\n      .then(exitExperiment)\n\n  }\n  //\n  function clearCanvas() {\n    app.stage.removeChildren();\n  }\n  function start(count_down = 5, interval_ms = 1000) {\n    for (let i = count_down; i > 0; i--) {\n      my_promise = my_promise\n        .then(delay_ms(interval_ms))\n        .then(() => {\n          app.ticker.addOnce(() => {\n            app.stage.removeChildren();\n            showPixiText(`${i}`);\n            const timestamp = epochTimestamp();\n          })\n\n        })\n    }\n    my_promise = my_promise.then(delay_ms(interval_ms)).then(clearCanvas);\n    return my_promise;\n  }\n\n  function baseline_start() {\n    if (start_config.start_baseline_s > 0) {\n      my_promise = my_promise\n        .then(() => {\n          app.ticker.addOnce(() => {\n            app.stage.removeChildren();\n            showPixiText(`Pre-experiment baseline\\n Please rest and stay calm for ${start_config.start_baseline_s}s with eyes open`)\n            const timestamp = epochTimestamp();\n            event_list.push(eventGen(timestamp, \"Pre-baseline\", \"start\"))\n          })\n        })\n        .then(delay_ms(start_config.start_baseline_s * 1e3))\n        .then(() => {\n          app.ticker.addOnce(() => {\n            app.stage.removeChildren();\n            const timestamp = epochTimestamp();\n            event_list.push(eventGen(timestamp, \"Pre-baseline\", \"end\"))\n          })\n        })\n    }\n    return my_promise;\n  }\n\n  function baseline_end() {\n    if (start_config.end_baseline_s > 0) {\n      my_promise = my_promise\n        .then(() => {\n          app.ticker.addOnce(() => {\n            app.stage.removeChildren();\n            showPixiText(`Post-experiment baseline\\n Please rest and stay calm for ${start_config.start_baseline_s}s with eyes open`)\n            const timestamp = epochTimestamp();\n            event_list.push(eventGen(timestamp, \"Post-baseline\", \"start\"))\n          })\n        })\n        .then(delay_ms(start_config.end_baseline_s * 1e3))\n        .then(() => {\n          app.ticker.addOnce(() => {\n            app.stage.removeChildren();\n            const timestamp = epochTimestamp();\n            event_list.push(eventGen(timestamp, \"Post-baseline\", \"end\"))\n          })\n        })\n    }\n    return my_promise;\n  }\n\n  function event_end(type: string, event: string) {\n    return () => {\n      app.ticker.addOnce(() => {\n        app.stage.removeChildren();\n        const timestamp = epochTimestamp();\n        event_list.push(eventGen(timestamp, type, event))\n      })\n    }\n  }\n\n  function show_stim_sequence(stim_seq: number[][], show_stim_sequence = true) {\n    return () => {\n      for (let i = 0; i < stim_seq.length; i++) {\n        stim_order_i = i\n        stim_set_i = stim_seq[i][0];\n        stim_seq_i = stim_seq[i][1];\n        const sprite = stim_info_list[stim_set_i].stim_info[stim_seq_i].sprite\n        sprite.x = app.screen.width / 2\n        sprite.y = app.screen.height / 2\n\n        const fixation_time_ms = start_config.start_fixation_ms + getRandomFloat(0, start_config.jitter_ms)\n        if (fixation_time_ms > 0) {\n          my_promise = my_promise\n            .then(() => {\n              app.ticker.addOnce(() => {\n                app.stage.removeChildren();\n                showPixiText(`+`, pixi_huge_text);\n                const timestamp = epochTimestamp();\n                event_list.push(eventGen(timestamp, \"show fixation\", \"start\"))\n              })\n            })\n            .then(delay_ms(fixation_time_ms))\n            .then(event_end(\"show fixation\", \"end\"))\n        }\n\n\n        my_promise = my_promise.then(() => {\n          app.ticker.addOnce(() => {\n            app.stage.addChild(sprite);\n            const timestamp = epochTimestamp();\n            event_list.push(eventGen(timestamp, \"show stim\", \"start\"))\n          })\n        })\n          .then(delay_ms(stim_info_list[stim_set_i].show_time_ms))\n          .then(event_end(\"show stim\", \"end\"))\n\n        if (start_config.end_white_ms > 0) {\n          my_promise = my_promise.then(() => {\n            app.ticker.addOnce(() => {\n              app.stage.removeChildren();\n              if (show_stim_sequence) {\n                showPixiText(`Progress\\n${i + 1}/${stim_seq.length}`, pixi_huge_text);\n              }\n              const timestamp = epochTimestamp();\n              event_list.push(eventGen(timestamp, \"show post stim\", \"start\"))\n            })\n          }).then(delay_ms(start_config.end_white_ms))\n            .then(event_end(\"show post stim\", \"end\"))\n        }\n      }\n      return my_promise;\n    }\n  }\n\n  function delay(time_ms: number, callback: Function | null = null) {\n    return new Promise((resolve, reject) => {\n      timeout = setTimeout(() => {\n        try {\n          if (callback) {\n            resolve(callback());\n          } else {\n            resolve(null);\n          }\n        } catch (err) {\n          reject(err);\n        }\n      }, time_ms);\n    });\n  }\n  function delay_ms(time_ms: number) {\n    return () => delay(time_ms)\n  }\n\n  function exitExperiment() {\n    clearTimeout(timeout);\n    my_promise.finally();\n    document.removeEventListener(\"keydown\", on_key_down);\n    app.stage.removeChildren();\n    app.canvas.classList.add(\"hide\");\n    control_panel_div.classList.remove(\"hide\");\n    if (event_list.length > 0) {\n      download(\"visual_stimuli_events\", JSON.stringify((event_list), null, 2))\n    }\n  }\n\n  function on_key_down(event: KeyboardEvent) {\n    if (event.key === \"Escape\") {\n      exitExperiment()\n    } else {\n      eventGen(epochTimestamp(), \"keydown\", event.key)\n    }\n  }\n\n  // add_vis_stim_set.innerHTML = \"+ Stim Set\";\n  // vis_stim.appendChild(add_vis_stim_set);\n  async function addVisStimSet(files: FileList) {\n    const info: StimulusSetInfo = {\n      stim_info: [],\n      num_repeat: start_config.num_repeat,\n      show_time_ms: start_config.show_time_ms,\n    }\n    stim_info_list.push(info);\n    const files_arr = Array.from(files);\n    files_arr.reverse();\n    const id_num = vis_stim.children.length;\n    const stim_row_div = createDiv(`Vis-stim-${id_num}`, vis_stim, [\n      \"vis-stim-row\"\n    ]);\n    const setting_div = createDiv(`Vis-stim-${id_num}-settings`, stim_row_div, [\n      \"stim-setting\"\n    ]);\n    const title_card = createDiv(`img-card-${id_num}`, setting_div, [\"card\", \"width_8vw\", \"gray\"]);\n    const title_header = createDiv(`img-card-header-${id_num}`, title_card, [\n      \"card-header\", \"center\"\n    ]);\n    const title_header_content = createDiv(\n      `img-card-header-content-${id_num}`,\n      title_header,\n      [\"card-title\", \"h6\", \"center\"],\n      `Set ${id_num + 1}: ${files_arr.length} stimuli`,\n    );\n\n    const title_card_content = createDiv(`img-card-content-${id_num}`, title_card, [\n      \"card-image\", \"width_8vw\", \"center\"\n    ]);\n    title_card_content.setAttribute(\"style\", \"display:flex;flex-direction: column;\")\n\n    const num_repeat_input_id = \"num_repeat_time_s\";\n    const num_repeat_label = createLabel(\n      \"num_repeat_time_span\",\n      title_card_content,\n      num_repeat_input_id,\n      [\"form-label\"],\n      \"# repeat each:\",\n    );\n\n\n    const num_repeat_input = createNumInput(\n      num_repeat_input_id,\n      title_card_content,\n      // [\"form-input\", \"width_12vw\"],\n      [\"lg-input\"],\n      1,\n      100,\n      1,\n      start_config.num_repeat,\n    );\n    num_repeat_input.setAttribute(\"style\", \"width:3em\")\n    num_repeat_input.onchange = (event: Event) => {\n      if (event.target) {\n        if (\"value\" in event.target) {\n          if (typeof event.target.value === \"number\") {\n            info.num_repeat = event.target.value;\n          } else if (typeof event.target.value === \"string\") {\n            info.num_repeat = parseInt(event.target.value);\n          }\n        }\n      }\n    }\n\n\n    const stim_show_time_input_id = \"stim_show_time_time_s\";\n    const stim_show_time_label = createLabel(\n      \"stim_show_time_time_span\",\n      title_card_content,\n      stim_show_time_input_id,\n      [\"form-label\"],\n      \"Display time (ms):\",\n    );\n\n\n    const stim_show_time_input = createNumInput(\n      stim_show_time_input_id,\n      title_card_content,\n      [\"lg-input\"],\n      1,\n      30000,\n      1,\n      start_config.show_time_ms,\n    );\n    stim_show_time_input.setAttribute(\"style\", \"width:4em\")\n    stim_show_time_input.onchange = (event: Event) => {\n      if (event.target) {\n        if (\"value\" in event.target) {\n          if (typeof event.target.value === \"number\") {\n            info.show_time_ms = event.target.value;\n          } else if (typeof event.target.value === \"string\") {\n            info.show_time_ms = parseFloat(event.target.value);\n          }\n        }\n      }\n    }\n\n    const stims_div = createDiv(`Vis-stim-${id_num}-stims`, stim_row_div, [\n      \"stims\", \"xscroll\"\n    ]);\n\n\n    for (let i = 0; i < files_arr.length; i++) {\n      const img_card_id = `${id_num}-${i}`;\n      const card = createDiv(`img-card-${img_card_id}`, stims_div, [\"card\", \"width_12vw\"]);\n      const header = createDiv(`img-card-header-${img_card_id}`, card, [\n        \"card-header\",\n      ]);\n      const header_content = createDiv(\n        `img-card-header-content-${img_card_id}`,\n        header,\n        [\"card-title\", \"h6\"],\n        files_arr[i].name,\n      );\n      const card_img = createDiv(`img-card-img-${img_card_id}`, card, [\n        \"card-image\", \"center\"\n      ]);\n      const reader = new FileReader();\n      reader.readAsDataURL(files_arr[i]);\n      reader.onload = async (e: any) => {\n        const img = document.createElement(\"img\");\n        img.setAttribute(\"src\", e.target?.result);\n        img.classList.add(\"fit\");\n        card_img.appendChild(img);\n        const imageUrl = e.target?.result as string;\n        if (imageUrl) {\n          info.stim_info.push({\n            sprite: await createSprite(imageUrl),\n            file: files_arr[i]\n          })\n        }\n      };\n    }\n    if (play_stim_button.disabled) {\n      play_stim_button.disabled = false;\n    }\n    if (shuffle_within_input.disabled) {\n      shuffle_within_input.disabled = false;\n    }\n    if ((stim_info_list.length > 1) && shuffle_between_input.disabled) {\n      shuffle_between_input.disabled = false;\n    }\n    if (show_progress_input.disabled) {\n      show_progress_input.disabled = false;\n    }\n\n  }\n}\n\nfunction generateStimSeq(infos: StimulusSetInfo[], shuffle_within = true, shuffle_between = true) {\n  let stim_seq: number[][] = [];\n  let stim_seqs: number[][][] = [];\n  let stim_set_repeat_left: number[] = infos.map(e => e.num_repeat);\n  while (any(stim_set_repeat_left)) {\n    for (let set_i = 0; set_i < infos.length; set_i++) {\n      if (stim_set_repeat_left[set_i] > 0) {\n        const info = infos[set_i];\n        stim_set_repeat_left[set_i] -= 1;\n        const set_seq: number[][] = [];\n        for (let stim_i = 0; stim_i < info.stim_info.length; stim_i++) {\n          set_seq.push([set_i, stim_i]);\n        }\n        if (shuffle_within) {\n          shuffle(set_seq, true);\n        }\n        stim_seqs.push(set_seq);\n      }\n    }\n  }\n  stim_seq = stim_seq.concat(...stim_seqs);\n  if (shuffle_between) {\n    shuffle(stim_seq, true);\n  }\n  return stim_seq\n}\n\n\nfunction showPixiText(txt: string, text_style: PIXI.TextStyle = pixi_large_text) {\n  let pre_baseline_text = new PIXI.Text({ text: txt, style: text_style });\n  pre_baseline_text.anchor.set(0.5);\n  pre_baseline_text.x = app.screen.width / 2;\n  pre_baseline_text.y = app.screen.height / 2;\n  app.stage.addChild(pre_baseline_text);\n  return pre_baseline_text;\n}\n\nasync function createSprite(imageUrl: string) {\n  // const texture = PIXI.Texture.from(imageUrl);\n  const texture = await PIXI.Assets.load(imageUrl);\n  const sprite = new PIXI.Sprite(texture);\n  sprite.anchor.set(0.5);\n  sprite.x = app.screen.width / 2;\n  sprite.y = app.screen.height / 2;\n  return sprite\n}\n\nfunction createLabel(\n  id: string,\n  parent: HTMLElement | undefined = undefined,\n  for_id: string,\n  classList: string[] = [],\n  textContent: string = \"\",\n) {\n  const myLabel = document.createElement(\"label\");\n  configureHTMLElement(myLabel, id, parent, classList, textContent);\n  myLabel.setAttribute(\"for\", for_id);\n  myLabel.setAttribute(\"style\", \"white-space: pre-wrap;\");\n  return myLabel;\n}\n\nfunction createNumInput(\n  id: string,\n  parent: HTMLElement | undefined = undefined,\n  classList: string[] = [],\n  min: number = 0,\n  max: number = 100,\n  step: number = 1,\n  val: number = 1,\n  textContent: string = \"\",\n) {\n  const myNumInput = document.createElement(\"input\");\n  configureHTMLElement(myNumInput, id, parent, [...classList], textContent);\n  myNumInput.setAttribute(\"type\", \"number\");\n  myNumInput.setAttribute(\"min\", min.toString());\n  myNumInput.setAttribute(\"max\", max.toString());\n  myNumInput.setAttribute(\"step\", step.toString());\n  myNumInput.setAttribute(\"value\", val.toString());\n  return myNumInput;\n}\n\nfunction configureHTMLElement(\n  e: HTMLElement,\n  id: string,\n  parent: HTMLElement | undefined = undefined,\n  classList: string[] = [],\n  textContent: string = \"\",\n) {\n  if (parent) {\n    parent.appendChild(e);\n  }\n  if (classList.length > 0) {\n    e.classList.add(...classList);\n  }\n  if (textContent.length > 0) {\n    e.textContent = textContent;\n  }\n  e.id = id;\n  return e;\n}\n\nfunction createDiv(\n  id: string,\n  parent: HTMLElement | undefined = undefined,\n  classList: string[] = [],\n  textContent: string = \"\",\n) {\n  const myDiv = document.createElement(\"div\");\n  configureHTMLElement(myDiv, id, parent, classList, textContent);\n  return myDiv;\n}\n\n\nfunction createSwitch(\n  labeltext: string,\n  eventHandler: (ev: Event) => void,\n) {\n  const label = document.createElement(\"label\");\n  label.setAttribute(\"class\", \"form-switch\");\n  label.classList.add(\"label-lg\");\n  const input = document.createElement(\"input\");\n  input.id = `${labeltext}-onoff`;\n  input.type = \"checkbox\";\n  input.addEventListener(\"change\", eventHandler);\n  input.classList.add(\"input-lg\");\n  const icon = document.createElement(\"i\");\n  icon.classList.add(\"form-icon\");\n  label.textContent = labeltext;\n  label.appendChild(input);\n  label.appendChild(icon);\n  return label;\n}\n\nfunction ws_connect() {\n\n  socket = new WebSocket(WS_URL);\n\n  socket.addEventListener(\"open\", (event) => {\n    console.log(`ws to ${WS_URL} connected!`);\n    reconnect_count = 0;\n  });\n\n  socket.addEventListener(\"close\", (event) => {\n    console.log(\n      `ws to ${WS_URL} disconnected! ${reconnect_count}/${MAX_RECONNECT}`,\n    );\n    if (reconnect_count < MAX_RECONNECT) {\n      reconnect_timeout = setTimeout(ws_connect, 2000);\n    }\n  });\n\n  socket.onerror = (err) => {\n    reconnect_count++;\n  };\n\n  socket.addEventListener(\"message\", (event) => {\n    if (event.data === \"Another instance is connected!\") {\n      reconnect_count = MAX_RECONNECT;\n      window.alert(\n        \"Another instance is connected! Refresh page to take control if you must\",\n      );\n    }\n  });\n}\n\nsetTimeout(ws_connect, 0);", "import { startConfigFromUrl, prepVisStimCtrlPanel } from \"./vis_stim_manager\";\n\nawait prepVisStimCtrlPanel(startConfigFromUrl());\n\nfunction location_reload() {\n  location.reload();\n  console.log(\"Page reloaded\");\n}\nif (!(window as any).IS_PRODUCTION) {\n  new EventSource(\"/esbuild\").addEventListener(\"change\", location_reload);\n}\n"],
  "mappings": "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",
  "names": ["ExtensionType", "normalizeExtension", "normalizeExtensionPriority", "extensions", "ext", "defaultPriority", "type", "handlers", "queue", "onAdd", "onRemove", "addHandlers", "removeHandlers", "map", "extension", "item", "a", "b", "index", "list", "Target", "sources", "source", "require_eventemitter3", "__commonJSMin", "exports", "module", "has", "prefix", "Events", "EE", "fn", "context", "once", "addListener", "emitter", "event", "listener", "evt", "clearEvent", "EventEmitter", "names", "events", "name", "handlers", "i", "l", "ee", "listeners", "a1", "a2", "a3", "a4", "a5", "len", "args", "length", "j", "import_index", "eventemitter3_default", "init_eventemitter3", "__esmMin", "EventEmitter", "r", "t", "n", "e", "u", "a", "o", "i", "s", "h", "b", "g", "d", "f", "c", "l", "p", "v", "m", "y", "N", "x", "M", "H", "$", "j", "w", "S", "k", "init_colord", "__esmMin", "names_default", "e", "f", "a", "d", "l", "i", "n", "o", "t", "b", "c", "u", "r", "init_names", "__esmMin", "_Color", "Color", "k", "names_default", "value", "value1", "value2", "type1", "v", "i", "keys1", "keys2", "key", "r", "g", "b", "a", "out", "alpha", "applyToRGB", "hexString", "alphaString", "int", "match", "color", "w", "min", "max", "cullingMixin", "PI_2", "RAD_TO_DEG", "DEG_TO_RAD", "Point", "tempPoint", "_Point", "x", "y", "p", "Matrix", "tempMatrix", "identityMatrix", "_Matrix", "a", "b", "c", "d", "tx", "ty", "array", "transpose", "out", "pos", "newPos", "Point", "x", "y", "id", "angle", "cos", "sin", "a1", "c1", "tx1", "matrix", "b1", "d1", "a2", "b2", "c2", "d2", "pivotX", "pivotY", "scaleX", "scaleY", "rotation", "skewX", "skewY", "transform", "pivot", "delta", "PI_2", "n", "ObservablePoint", "_ObservablePoint", "observer", "x", "y", "p", "value", "uid", "name", "uidCache", "warnings", "v8_0_0", "v8_3_4", "deprecationState", "deprecation", "version", "message", "ignoreDepth", "stack", "deprecationMessage", "useGroup", "value", "warn", "args", "warnCount", "maxWarnings", "GlobalResourceRegistry", "pool", "Pool", "ClassType", "initialSize", "total", "i", "data", "item", "PoolGroupClass", "BigPool", "Class", "total", "data", "item", "ClassType", "Pool", "stats", "pool", "name", "GlobalResourceRegistry", "cacheAsTextureMixin", "val", "deprecation", "removeItems", "arr", "startIdx", "removeCount", "length", "i", "len", "childrenHelperMixin", "beginIndex", "endIndex", "end", "range", "removed", "i", "child", "removeItems", "renderGroup", "index", "deprecation", "v8_0_0", "children", "currentIndex", "child2", "index1", "index2", "c", "childMat", "newMatrix", "oldChild", "newChild", "collectRenderablesMixin", "instructionSet", "renderer", "currentLayer", "children", "length", "i", "renderPipes", "effect", "FilterEffect", "i", "MaskEffectManagerClass", "MaskEffectManager", "test", "item", "i", "BigPool", "effect", "extensions", "ExtensionType", "effectsMixin", "renderGroup", "effect", "a", "b", "index", "value", "MaskEffectManager", "options", "FilterEffect", "hasFilters", "hadFilters", "didChange", "findMixin", "deprecation", "v8_0_0", "value", "name", "deep", "label", "children", "i", "child", "found", "out", "tempPoints", "Rectangle", "Point", "_Rectangle", "x", "y", "width", "height", "bounds", "rectangle", "strokeWidth", "alignment", "_x", "_y", "strokeWidthOuter", "strokeWidthInner", "outerLeft", "outerRight", "outerTop", "outerBottom", "innerLeft", "innerRight", "innerTop", "innerBottom", "other", "transform", "x0", "y0", "x1", "y1", "lt", "lb", "rt", "rb", "s", "nx", "ny", "n00", "n10", "n01", "n11", "mx", "my", "m00", "m10", "m01", "m11", "paddingX", "paddingY", "x2", "y2", "resolution", "eps", "out", "defaultMatrix", "Bounds", "Matrix", "_Bounds", "minX", "minY", "maxX", "maxY", "Rectangle", "rectangle", "x0", "y0", "x1", "y1", "matrix", "a", "b", "c", "d", "tx", "ty", "rect", "bounds", "mask", "x", "y", "left", "right", "top", "bottom", "paddingX", "paddingY", "value", "width", "height", "vertexData", "beginOffset", "endOffset", "i", "localX", "localY", "matrixPool", "boundsPool", "BigPool", "Matrix", "Bounds", "tempMatrix", "getFastGlobalBoundsMixin", "Matrix", "factorRenderLayers", "bounds", "Bounds", "renderGroup", "currentLayer", "localBounds", "manageEffects", "boundsPool", "viewBounds", "children", "i", "advanced", "getGlobalBounds", "target", "skipUpdateTransform", "bounds", "parentTransform", "pooledMatrix", "matrixPool", "updateTransformBackwards", "Matrix", "_getGlobalBounds", "worldTransform", "parentBounds", "preserveBounds", "boundsPool", "renderableBounds", "i", "parent", "multiplyHexColors", "color1", "color2", "r1", "g1", "b1", "r2", "g2", "b2", "r", "g", "b", "multiplyColors", "localBGRColor", "parentBGRColor", "WHITE_BGR", "multiplyHexColors", "bgr2rgb", "color", "getGlobalMixin", "skipUpdate", "alpha", "current", "matrix", "Matrix", "parentTransform", "updateTransformBackwards", "matrixPool", "multiplyColors", "parent", "getLocalBounds", "target", "bounds", "relativeMatrix", "Matrix", "_getLocalBounds", "parentTransform", "rootContainer", "isRoot", "relativeTransform", "matrixPool", "localTransform", "parentBounds", "preserveBounds", "boundsPool", "children", "i", "checkChildrenDidChange", "container", "previousData", "children", "i", "child", "uid", "didChange", "index", "tempMatrix", "measureMixin", "Matrix", "value", "localWidth", "sign", "localHeight", "Bounds", "localBoundsCacheData", "checkChildrenDidChange", "getLocalBounds", "skipUpdate", "bounds", "getGlobalBounds", "onRenderMixin", "func", "renderGroup", "sortChildren", "a", "b", "sortMixin", "value", "toLocalGlobalMixin", "point", "Point", "skipUpdate", "position", "globalMatrix", "matrixPool", "from", "InstructionSet", "uid", "instruction", "nextPow2", "v", "isPow2", "definedProps", "obj", "result", "key", "createResourceIdFromString", "value", "id", "idHash", "uid", "_TextureStyle", "TextureStyle", "eventemitter3_default", "options", "deprecation", "v8_0_0", "bigKey", "_TextureSource", "TextureSource", "eventemitter3_default", "options", "uid", "TextureStyle", "definedProps", "value", "resolution", "resource", "width", "height", "newPixelWidth", "newPixelHeight", "isPow2", "_resource", "init", "row", "rotationCayley", "j", "_ux", "signum", "ux", "vx", "uy", "_uy", "vy", "_vx", "_vy", "k", "mat", "Matrix", "rotationMatrices", "groupD8", "ind", "rotation", "rotationSecond", "rotationFirst", "dx", "dy", "matrix", "tx", "ty", "rect", "sourceFrame", "out", "x", "y", "width", "height", "frameX", "frameY", "frameWidth", "frameHeight", "NOOP", "BufferImageSource", "TextureSource", "options", "buffer", "format", "resource", "ExtensionType", "tempMat", "TextureMatrix", "Matrix", "texture", "clampMargin", "value", "uvs", "out", "mat", "i", "x", "y", "tex", "orig", "trim", "texBase", "frame", "margin", "offset", "Texture", "eventemitter3_default", "source", "label", "frame", "orig", "trim", "defaultAnchor", "defaultBorders", "rotate", "dynamic", "uid", "Rectangle", "TextureSource", "width", "height", "value", "TextureMatrix", "uvs", "nX", "nY", "nW", "nH", "w2", "h2", "cX", "cY", "groupD8", "destroySource", "deprecation", "v8_0_0", "NOOP", "BufferImageSource", "count", "TexturePoolClass", "TexturePool", "textureOptions", "TextureStyle", "pixelWidth", "pixelHeight", "antialias", "textureSource", "TextureSource", "Texture", "frameWidth", "frameHeight", "resolution", "po2Width", "po2Height", "nextPow2", "key", "texture", "source", "renderTexture", "resetStyle", "destroyTextures", "i", "textures", "j", "GlobalResourceRegistry", "RenderGroup", "Matrix", "InstructionSet", "root", "children", "i", "child", "options", "TexturePool", "cachedParent", "childrenAtDepth", "renderGroupChild", "index", "childrenToUpdate", "renderable", "container", "renderer", "out", "parentCacheAsTexture", "assignWithIgnore", "target", "options", "ignore", "key", "defaultSkew", "defaultPivot", "defaultScale", "defaultOrigin", "UPDATE_COLOR", "UPDATE_BLEND", "UPDATE_VISIBLE", "Container", "ObservablePoint", "_Container", "eventemitter3_default", "options", "uid", "Matrix", "assignWithIgnore", "child", "source", "deprecation", "extensions", "value", "children", "v8_0_0", "i", "renderGroup", "index", "point", "parentRenderGroup", "BigPool", "RenderGroup", "RAD_TO_DEG", "DEG_TO_RAD", "warn", "localWidth", "localHeight", "out", "bounds", "height", "size", "rotation", "skew", "opts", "matrix", "localTransformChangeId", "lt", "scale", "pivot", "origin", "position", "sx", "sy", "px", "py", "ox", "oy", "bgr", "Color", "bgr2rgb", "valueNumber", "oldChildren", "childrenHelperMixin", "getFastGlobalBoundsMixin", "toLocalGlobalMixin", "onRenderMixin", "measureMixin", "effectsMixin", "findMixin", "sortMixin", "cullingMixin", "cacheAsTextureMixin", "getGlobalMixin", "collectRenderablesMixin", "UPDATE_PRIORITY", "TickerListener", "fn", "context", "priority", "once", "ticker", "redirect", "previous", "hard", "_Ticker", "Ticker", "TickerListener", "time", "fn", "context", "priority", "UPDATE_PRIORITY", "listener", "current", "previous", "count", "currentTime", "elapsedMS", "delta", "head", "fps", "minFPS", "minFPMS", "maxFPS", "shared", "system", "CanvasObserver", "options", "rect", "contentWidth", "contentHeight", "sx", "sy", "tx", "ty", "newTransform", "entries", "entry", "Ticker", "UPDATE_PRIORITY", "FederatedEvent", "_FederatedEvent", "manager", "Point", "_type", "_bubbles", "_cancelable", "_typeArg", "_bubblesArg", "_cancelableArg", "_viewArg", "_detailArg", "createMatch", "userAgent", "regex", "isMobile", "param", "nav", "tmp", "match", "result", "appleIphone", "windowsPhone", "appleIpod", "appleTablet", "isAppleTabletOnIos13", "appleUniversal", "amazonPhone", "amazonTablet", "androidPhone", "androidTablet", "windowsTablet", "otherBlackBerry", "otherBlackBerry10", "otherOpera", "otherFirefox", "otherChrome", "init_isMobile", "__esmMin", "navigator", "init_esm", "__esmMin", "init_isMobile", "isMobileCall", "isMobile", "KEY_CODE_TAB", "DIV_TOUCH_SIZE", "DIV_TOUCH_POS_X", "DIV_TOUCH_POS_Y", "DIV_TOUCH_ZINDEX", "DIV_HOOK_SIZE", "DIV_HOOK_POS_X", "DIV_HOOK_POS_Y", "DIV_HOOK_ZINDEX", "_AccessibilitySystem", "AccessibilitySystem", "renderer", "_mobileInfo", "isMobile", "hookDiv", "CanvasObserver", "canvas", "observer", "child", "accessibleType", "div", "container", "children", "i", "options", "mergedOptions", "now", "activeIds", "removeItems", "hitArea", "wt", "viewWidth", "viewHeight", "e", "type", "target", "boundary", "event", "FederatedEvent", "enabled", "ExtensionType", "accessibilityTarget", "extensions", "AccessibilitySystem", "Container", "accessibilityTarget", "ResizePlugin", "options", "dom", "width", "height", "clientWidth", "clientHeight", "ExtensionType", "TickerPlugin", "options", "ticker", "UPDATE_PRIORITY", "Ticker", "oldTicker", "ExtensionType", "extensions", "ResizePlugin", "TickerPlugin", "EventsTickerClass", "EventsTicker", "events", "paused", "Ticker", "UPDATE_PRIORITY", "rootPointerEvent", "ticker", "FederatedMouseEvent", "FederatedEvent", "Point", "container", "point", "globalPos", "key", "_typeArg", "_canBubbleArg", "_cancelableArg", "_viewArg", "_detailArg", "_screenXArg", "_screenYArg", "_clientXArg", "_clientYArg", "_ctrlKeyArg", "_altKeyArg", "_shiftKeyArg", "_metaKeyArg", "_buttonArg", "_relatedTargetArg", "FederatedPointerEvent", "FederatedMouseEvent", "FederatedWheelEvent", "FederatedMouseEvent", "PROPAGATION_LIMIT", "tempHitLocation", "tempLocalMapping", "EventBoundary", "Point", "rootTarget", "eventemitter3_default", "type", "fn", "a", "b", "e", "mappers", "i", "j", "warn", "x", "y", "EventsTicker", "invertedPath", "composedPath", "targets", "events", "event", "target", "propagationPath", "currentTarget", "eventMode", "location", "testFn", "pruneFn", "ignore", "shouldReturn", "children", "child", "nestedHit", "isInteractive", "isInteractiveMode", "isInteractiveTarget", "relativeLocation", "int", "container", "effect", "handlerKey", "key", "from", "FederatedPointerEvent", "isRightButton", "trackingData", "isMouse", "outTarget", "outType", "outEvent", "leaveEvent", "overType", "overEvent", "overTargetAncestor", "enterEvent", "allMethods", "allowGlobalPointerEvents", "now", "pressTarget", "clickTarget", "clickEvent", "clickHistory", "FederatedWheelEvent", "wheelEvent", "to", "FederatedMouseEvent", "id", "constructor", "listeners", "MOUSE_POINTER_ID", "TOUCH_TO_POINTER", "_EventSystem", "EventSystem", "renderer", "EventBoundary", "EventsTicker", "FederatedPointerEvent", "FederatedWheelEvent", "target", "key", "value", "options", "canvas", "resolution", "mode", "applyStyles", "style", "nativeEvent", "events", "i", "j", "federatedEvent", "normalizedEvents", "event", "outside", "wheelEvent", "element", "point", "x", "y", "rect", "resolutionMultiplier", "li", "touch", "tempEvent", "ExtensionType", "FederatedContainer", "value", "EventSystem", "type", "listener", "options", "capture", "signal", "once", "context", "listenerFn", "emitter", "e", "FederatedEvent", "extensions", "EventSystem", "Container", "FederatedContainer", "DOMPipe", "renderer", "CanvasObserver", "domContainer", "_instructionSet", "_domContainer", "attachedDomElements", "i", "element", "wt", "anchor", "ax", "ay", "ExtensionType", "ViewContainer", "Container", "options", "Bounds", "value", "point", "bounds", "x", "y", "renderGroup", "key", "instructionSet", "renderer", "currentLayer", "renderPipes", "children", "length", "i", "extensions", "DOMPipe", "LoaderParserPriority", "BrowserAdapter", "width", "height", "canvas", "url", "options", "xml", "currentAdapter", "DOMAdapter", "BrowserAdapter", "adapter", "assertPath", "path", "removeUrlParams", "url", "escapeRegExp", "string", "replaceAll", "str", "find", "replace", "normalizeStringPosix", "allowAboveRoot", "res", "lastSegmentLength", "lastSlash", "dots", "code", "i", "lastSlashIndex", "matchFile", "matchProtocol", "customBaseUrl", "customRootUrl", "baseUrl", "DOMAdapter", "rootUrl", "protocol", "isAbsolute", "trailingSeparator", "segments", "joined", "arg", "prevArg", "hasRoot", "end", "matchedSlash", "proto", "origpath", "root", "index", "ext", "start", "extIdx", "firstNonSlashEnd", "startDot", "startPart", "preDotState", "ret", "convertToList", "input", "transform", "forceTransform", "item", "processX", "base", "ids", "depth", "result", "tags", "id", "i", "value", "createStringVariations", "string", "regex", "vars", "split", "isSingleItem", "item", "getUrlExtension", "url", "Resolver", "bundleId", "assetId", "assetBundleId", "bundleIdentifier", "preferOrders", "prefer", "basePath", "rootPath", "searchParams", "queryValues", "key", "asset", "alias", "src", "convertToList", "value", "v", "manifest", "warn", "bundle", "assets", "assetNames", "convertedAssets", "srcs", "aliases", "ids", "bundleAssetId", "bundleIds", "name", "keyCheck", "data", "format", "userDefinedLoadParser", "userDefinedParser", "srcsToUse", "createStringVariations", "aliasesToUse", "resolvedAssets", "formattedAsset", "i", "parser", "singleAsset", "isSingleItem", "out", "results", "result", "keys", "preferredOrder", "priorityKey", "filteredAssets", "preferred", "preference", "paramConnector", "assetData", "loadParser", "progressSize", "path", "copySearchParams", "targetUrl", "sourceUrl", "searchParams", "_Spritesheet", "Spritesheet", "optionsOrTexture", "arg1", "options", "TextureSource", "texture", "data", "cachePrefix", "Texture", "metaResolution", "resolve", "initialFrameIndex", "frameIndex", "maxFrames", "i", "rect", "frame", "trim", "sourceSize", "orig", "Rectangle", "animations", "animName", "frameName", "callback", "destroyBase", "getCacheableAssets", "keys", "asset", "ignoreMultiPack", "out", "key", "basePath", "path", "item", "i", "out2", "validImages", "spritesheetAsset", "ExtensionType", "Spritesheet", "value", "split", "extension", "format", "Resolver", "LoaderParserPriority", "options", "loader", "imageTexture", "imageFilename", "textureOptions", "cachePrefix", "texture", "Texture", "imagePath", "copySearchParams", "spritesheet", "multiPacks", "promises", "itemUrl", "res", "sp", "_resolvedAsset", "extensions", "spritesheetAsset", "updateQuadBounds", "bounds", "anchor", "texture", "width", "height", "trim", "sourceWidth", "sourceHeight", "Sprite", "_Sprite", "ViewContainer", "options", "Texture", "texture", "anchor", "roundPixels", "width", "height", "rest", "ObservablePoint", "source", "skipCache", "value", "currentTexture", "updateQuadBounds", "deprecation", "bounds", "destroyTextureSource", "out", "addMaskBounds", "mask", "bounds", "skipUpdateTransform", "boundsToMask", "tempBounds", "getGlobalBounds", "Bounds", "addMaskLocalBounds", "mask", "bounds", "localRoot", "boundsToMask", "boundsPool", "tempMatrix", "matrixPool", "relativeMask", "getMatrixRelativeToParent", "getLocalBounds", "target", "root", "matrix", "warn", "AlphaMask", "options", "mask", "Sprite", "bounds", "skipUpdateTransform", "addMaskBounds", "localRoot", "addMaskLocalBounds", "point", "hitTestFn", "ExtensionType", "ColorMask", "options", "mask", "ExtensionType", "StencilMask", "options", "mask", "bounds", "skipUpdateTransform", "addMaskBounds", "localRoot", "addMaskLocalBounds", "point", "hitTestFn", "Container", "ExtensionType", "CanvasSource", "TextureSource", "options", "DOMAdapter", "width", "height", "resolution", "didResize", "resource", "ExtensionType", "ImageSource", "TextureSource", "options", "resource", "ExtensionType", "detectVideoAlphaMode", "promise", "gl", "DOMAdapter", "video", "resolve", "texture", "framebuffer", "pixel", "_VideoSource", "VideoSource", "TextureSource", "options", "elapsedMS", "Ticker", "source", "detectVideoAlphaMode", "resolve", "reject", "event", "value", "resource", "ExtensionType", "CacheClass", "Cache", "key", "result", "warn", "value", "keys", "convertToList", "cacheableAssets", "i", "parser", "cacheableMap", "cacheKeys", "cachedAssets", "val", "cacheMap", "textureSourceFrom", "options", "hasResource", "res", "opts", "i", "sources", "Source", "resourceToTexture", "skipCache", "resource", "Cache", "texture", "Texture", "textureFrom", "id", "TextureSource", "extensions", "ExtensionType", "extensions", "AlphaMask", "ColorMask", "StencilMask", "VideoSource", "ImageSource", "CanvasSource", "BufferImageSource", "BindGroup", "resources", "index", "i", "resource", "keyParts", "currentResource", "tick", "getTextureBatchBindGroup", "textures", "size", "maxTextures", "uid", "i", "cachedGroups", "generateTextureBatchBindGroup", "key", "bindGroupResources", "bindIndex", "texture", "Texture", "bindGroup", "BindGroup", "ViewableBuffer", "sizeOrBuffer", "type", "fastCopy", "sourceBuffer", "destinationBuffer", "lengthDouble", "sourceFloat64View", "remainingBytes", "sourceUint8View", "BLEND_TO_NPM", "STENCIL_MODES", "getAdjustedBlendModeBlend", "blendMode", "textureSource", "BLEND_TO_NPM", "getTestContext", "context", "DOMAdapter", "generateIfTestSrc", "maxIfs", "src", "i", "checkMaxIfStatementsInShader", "gl", "shader", "fragmentSrc", "fragTemplate", "getMaxTexturesPerBatch", "maxTexturesPerBatchCache", "gl", "getTestContext", "checkMaxIfStatementsInShader", "BatchTextureArray", "i", "t", "getBatchFromPool", "batchPoolIndex", "batchPool", "Batch", "returnBatchToPool", "batch", "BATCH_TICK", "_Batcher", "Batcher", "BatchTextureArray", "GlobalResourceRegistry", "item", "options", "uid", "deprecation", "getMaxTexturesPerBatch", "maxTextures", "attributesInitialSize", "indicesInitialSize", "ViewableBuffer", "i", "batchableObject", "texture", "textureId", "attributeBuffer", "instructionSet", "elements", "textureBatch", "firstElement", "blendMode", "getAdjustedBlendModeBlend", "topology", "f32", "u32", "indexBuffer", "size", "start", "action", "element", "source", "adjustedBlendMode", "breakRequired", "indexStart", "indexSize", "newSize", "newArrayBuffer", "fastCopy", "newIndexBuffer", "index", "indicesOffset", "indices", "indexOffset", "attributeOffset", "BufferUsage", "Buffer", "eventemitter3_default", "options", "data", "size", "usage", "label", "shrinkToFit", "uid", "mappedAtCreation", "value", "BufferUsage", "syncGPU", "oldData", "sizeInBytes", "ensureIsBuffer", "buffer", "index", "Buffer", "usage", "BufferUsage", "getGeometryBounds", "geometry", "attributeId", "bounds", "attribute", "data", "minX", "minY", "maxX", "maxY", "byteSize", "offset", "stride", "i", "x", "y", "ensureIsAttribute", "attribute", "Buffer", "ensureIsBuffer", "Geometry", "eventemitter3_default", "options", "uid", "Bounds", "attributes", "indexBuffer", "topology", "i", "id", "name", "attributeOption", "getGeometryBounds", "destroyBuffers", "buffer", "placeHolderBufferData", "placeHolderIndexData", "BatchGeometry", "Geometry", "attributeBuffer", "Buffer", "BufferUsage", "indexBuffer", "stride", "createIdFromString", "value", "groupId", "id", "idHash", "idCounts", "getMaxFragmentPrecision", "maxFragmentPrecision", "gl", "getTestContext", "addProgramDefines", "src", "isES300", "isFragment", "ensurePrecision", "src", "options", "isFragment", "maxSupportedPrecision", "precision", "insertVersion", "src", "isES300", "setProgramName", "src", "name", "isFragment", "nameCache", "fragmentNameCache", "VertexNameCache", "stripVersion", "src", "isES300", "processes", "programCache", "_GlProgram", "GlProgram", "stripVersion", "ensurePrecision", "addProgramDefines", "setProgramName", "insertVersion", "options", "isES300", "preprocessorOptions", "getMaxFragmentPrecision", "fragment", "vertex", "processKey", "processOptions", "createIdFromString", "key", "getAttributeInfoFromFormat", "format", "attributeFormatData", "extractAttributesFromGpuProgram", "source", "entryPoint", "results", "mainVertStart", "arrowFunctionStart", "functionArgsSubstring", "inputsRegex", "match", "format", "WGSL_TO_VERTEX_TYPES", "getAttributeInfoFromFormat", "extractStructAndGroups", "wgsl", "linePattern", "groupPattern", "bindingPattern", "namePattern", "typePattern", "structPattern", "structMemberPattern", "structName", "groups", "item", "structs", "struct", "name", "members", "acc", "member", "type", "group", "ShaderStage", "generateGpuLayoutGroups", "groups", "layout", "i", "group", "ShaderStage", "generateLayoutHash", "groups", "layout", "i", "group", "removeStructAndGroupDuplicates", "vertexStructsAndGroups", "fragmentStructsAndGroups", "structNameSet", "dupeGroupKeySet", "structs", "struct", "groups", "group", "key", "programCache", "GpuProgram", "_GpuProgram", "options", "fragment", "vertex", "layout", "gpuLayout", "name", "structsAndGroups", "extractStructAndGroups", "vertexStructsAndGroups", "fragmentStructsAndGroups", "removeStructAndGroupDuplicates", "generateLayoutHash", "generateGpuLayoutGroups", "bigKey", "createIdFromString", "extractAttributesFromGpuProgram", "key", "addBits", "srcParts", "parts", "name", "i", "id", "part", "sanitisedPart", "warn", "compileHooks", "programSrc", "parts", "findHooksRx", "hook", "extractInputs", "fragmentSource", "out", "match", "regex", "compileInputs", "fragments", "template", "sort", "results", "fragment", "mainInput", "finalString", "inValue", "i", "cleanedString", "extractOutputs", "fragmentSource", "out", "match", "regex", "extractVariableName", "value", "stripVariable", "compileOutputs", "fragments", "template", "results", "fragment", "index", "mainStruct", "inValue", "mainStart", "mainEnd", "compiledCode", "injectBits", "templateSrc", "fragmentParts", "out", "i", "parts", "compileHighShader", "template", "bits", "cacheId", "generateCacheId", "cacheMap", "vertex", "fragment", "compileInputsAndOutputs", "compileBits", "compileHighShaderGl", "vertexFragments", "shaderBit", "v", "fragmentFragments", "compiledVertex", "compileInputs", "compileOutputs", "compiledFragment", "highFragment", "bitCacheMap", "CACHE_UID", "a", "b", "vertexParts", "compileHooks", "fragmentParts", "addBits", "injectBits", "vertexGPUTemplate", "fragmentGPUTemplate", "vertexGlTemplate", "fragmentGlTemplate", "globalUniformsBit", "globalUniformsBitGl", "compileHighShaderGpuProgram", "bits", "name", "source", "compileHighShader", "fragmentGPUTemplate", "vertexGPUTemplate", "globalUniformsBit", "GpuProgram", "compileHighShaderGlProgram", "GlProgram", "compileHighShaderGl", "vertexGlTemplate", "fragmentGlTemplate", "globalUniformsBitGl", "colorBit", "colorBitGl", "generateBindingSrc", "maxTextures", "src", "bindingIndex", "i", "generateSampleSrc", "generateTextureBatchBit", "textureBatchBitGpuCache", "generateSampleGlSrc", "generateTextureBatchBitGl", "textureBatchBitGlCache", "roundPixelsBit", "roundPixelsBitGl", "UNIFORM_TYPES_VALUES", "UNIFORM_TYPES_MAP", "acc", "type", "getDefaultUniformValue", "type", "size", "_UniformGroup", "UniformGroup", "uniformStructures", "options", "uid", "uniforms", "i", "uniformData", "UNIFORM_TYPES_MAP", "arrayMatch", "innerType", "size", "UNIFORM_TYPES_VALUES", "getDefaultUniformValue", "createIdFromString", "getBatchSamplersUniformGroup", "maxTextures", "batchSamplersUniformGroup", "batchSamplersUniformGroupHash", "sampleValues", "i", "UniformGroup", "RendererType", "Shader", "_Shader", "eventemitter3_default", "options", "uid", "gpuProgram", "glProgram", "groups", "resources", "compatibleRenderers", "groupMap", "RendererType", "nameHash", "i", "j", "uniformName", "groupData", "data", "bindTick", "BindGroup", "name", "value", "UniformGroup", "groupIndex", "bindIndex", "_a", "_b", "uniformsOut", "destroyPrograms", "bindGroup", "gpu", "gl", "rest", "GpuProgram", "GlProgram", "DefaultShader", "Shader", "maxTextures", "glProgram", "compileHighShaderGlProgram", "colorBitGl", "generateTextureBatchBitGl", "roundPixelsBitGl", "gpuProgram", "compileHighShaderGpuProgram", "colorBit", "generateTextureBatchBit", "roundPixelsBit", "getBatchSamplersUniformGroup", "defaultShader", "_DefaultBatcher", "DefaultBatcher", "Batcher", "options", "BatchGeometry", "DefaultShader", "element", "float32View", "uint32View", "index", "textureId", "textureIdAndRound", "wt", "a", "b", "c", "d", "tx", "ty", "positions", "uvs", "argb", "offset", "end", "i", "i2", "x", "y", "texture", "bounds", "w0", "w1", "h0", "h1", "ExtensionType", "buildUvs", "vertices", "verticesStride", "verticesOffset", "uvs", "uvsOffset", "uvsStride", "size", "matrix", "index", "a", "b", "c", "tx", "ty", "x", "y", "buildSimpleUvs", "transformVertices", "vertices", "m", "offset", "stride", "size", "a", "b", "c", "d", "tx", "ty", "index", "i", "x", "y", "identityMatrix", "BatchableGraphics", "Matrix", "rgb", "bgr", "renderable", "multiplyHexColors", "gpuBuffer", "buildCircle", "buildEllipse", "buildRoundedRectangle", "ExtensionType", "shape", "points", "x", "y", "dx", "dy", "rx", "ry", "circle", "ellipse", "roundedRect", "halfWidth", "halfHeight", "n", "m", "j1", "j2", "j3", "j4", "x0", "y0", "x1", "x2", "y1", "y2", "i", "a", "vertices", "verticesStride", "verticesOffset", "indices", "indicesOffset", "centerX", "centerY", "count", "centerIndex", "getOrientationOfPoints", "points", "m", "area", "i", "x1", "y1", "x2", "y2", "square", "x", "y", "nx", "ny", "innerWeight", "outerWeight", "clockwise", "verts", "ix", "iy", "ox", "oy", "exx", "eyy", "eix", "eiy", "eox", "eoy", "round", "cx", "cy", "sx", "sy", "ex", "ey", "cx2p0x", "cy2p0y", "angle0", "angle1", "startAngle", "angleDiff", "absAngleDiff", "radius", "segCount", "angleInc", "i", "angle", "buildLine", "points", "lineStyle", "flipAlignment", "closed", "vertices", "indices", "eps", "style", "alignment", "orientation", "getOrientationOfPoints", "firstPoint", "Point", "lastPoint", "closedShape", "closedPath", "midPointX", "midPointY", "length", "indexCount", "indexStart", "width", "widthSquared", "miterLimitSquared", "x0", "y0", "x1", "y1", "x2", "y2", "perpX", "perpY", "perp1x", "perp1y", "dist", "ratio", "dx0", "dy0", "dx1", "dy1", "dot", "cross", "c1", "c2", "px", "py", "pDist", "imx", "imy", "omx", "omy", "smallerInsideSegmentSq", "insideWeight", "smallerInsideDiagonalSq", "eps2", "buildPixelLine", "points", "closed", "vertices", "indices", "eps", "fx", "fy", "lx", "ly", "closePath", "verts", "length", "indexStart", "i", "earcut", "data", "holeIndices", "dim", "hasHoles", "outerLen", "outerNode", "linkedList", "triangles", "minX", "minY", "invSize", "eliminateHoles", "maxX", "maxY", "i", "x", "y", "earcutLinked", "start", "end", "clockwise", "last", "signedArea", "insertNode", "equals", "removeNode", "filterPoints", "p", "again", "area", "ear", "pass", "indexCurve", "stop", "prev", "next", "isEarHashed", "isEar", "cureLocalIntersections", "splitEarcut", "a", "b", "c", "ax", "bx", "cx", "ay", "by", "cy", "x0", "y0", "x1", "y1", "pointInTriangleExceptFirst", "minZ", "zOrder", "maxZ", "n", "intersects", "locallyInside", "isValidDiagonal", "splitPolygon", "queue", "len", "list", "getLeftmost", "compareXYSlope", "eliminateHole", "result", "aSlope", "bSlope", "hole", "bridge", "findHoleBridge", "bridgeReverse", "hx", "hy", "qx", "m", "mx", "my", "tanMin", "pointInTriangle", "tan", "sectorContainsSector", "sortLinked", "numMerges", "inSize", "e", "tail", "q", "pSize", "qSize", "leftmost", "px", "py", "intersectsPolygon", "middleInside", "r", "p1", "p2", "q1", "q2", "o1", "sign", "o2", "o3", "o4", "onSegment", "num", "inside", "a2", "createNode", "b2", "an", "bp", "sum", "j", "init_earcut", "__esmMin", "earcut", "triangulateWithHoles", "points", "holes", "vertices", "verticesStride", "verticesOffset", "indices", "indicesOffset", "triangles", "earcut", "i", "index", "emptyArray", "buildPolygon", "ExtensionType", "shape", "points", "i", "vertices", "verticesStride", "verticesOffset", "indices", "indicesOffset", "triangulateWithHoles", "buildRectangle", "ExtensionType", "shape", "points", "rectData", "x", "y", "width", "height", "vertices", "verticesStride", "verticesOffset", "indices", "indicesOffset", "count", "verticesIndex", "buildTriangle", "ExtensionType", "shape", "points", "vertices", "verticesStride", "verticesOffset", "indices", "indicesOffset", "count", "verticesIndex", "addColorStops", "gradient", "colorStops", "i", "stop", "getCanvas", "width", "height", "canvas", "DOMAdapter", "context", "ensureGradientOptions", "args", "options", "deprecation", "FillGradient", "emptyColorStops", "_FillGradient", "uid", "definedProps", "offset", "color", "Color", "x0", "y0", "x1", "y1", "dx", "dy", "flip", "temp", "defaultSize", "Texture", "ImageSource", "dist", "angle", "m", "Matrix", "r0", "r1", "ox", "oy", "scale", "cx", "cy", "generateTextureMatrix", "out", "style", "shape", "matrix", "textureMatrix", "bounds", "tempRect", "tx", "ty", "sx", "sy", "mTx", "mTy", "a1", "b1", "c1", "d1", "sourceStyle", "FillGradient", "tempTextureMatrix", "Matrix", "Rectangle", "buildContextBatches", "context", "gpuContext", "geometryData", "batches", "i", "instruction", "addTextureToGeometryData", "isStroke", "shapePath", "style", "hole", "addShapePathToGeometryData", "data", "points", "build", "shapeBuilders", "rect", "tempRect", "matrix", "vertices", "uvs", "indices", "indexOffset", "vertOffset", "transformVertices", "texture", "textureUvs", "graphicsBatch", "BigPool", "BatchableGraphics", "shape", "holes", "topology", "close", "lineStyle", "buildPixelLine", "buildLine", "holeIndices", "otherPoints", "getHoleArrays", "holePoints", "triangulateWithHoles", "uvsOffset", "Texture", "textureMatrix", "generateTextureFillMatrix", "tempTextureMatrix", "buildUvs", "buildSimpleUvs", "holePrimitives", "holeArrays", "k", "holePrimitive", "extensions", "ExtensionType", "buildRectangle", "buildPolygon", "buildTriangle", "buildCircle", "buildEllipse", "buildRoundedRectangle", "Rectangle", "Matrix", "GpuGraphicsContext", "GraphicsContextRenderData", "_GraphicsContextSystem", "GraphicsContextSystem", "InstructionSet", "maxTextures", "DefaultBatcher", "deprecation", "v8_3_4", "renderer", "options", "context", "gpuContext", "buildContextBatches", "batchMode", "graphicsData", "BigPool", "batches", "geometryData", "vertexSize", "indexSize", "i", "batcher", "batch", "geometry", "drawBatches", "getTextureBatchBindGroup", "ExtensionType", "blendModeIds", "BLEND", "OFFSET", "CULLING", "DEPTH_TEST", "WINDING", "DEPTH_MASK", "_State", "State", "value", "state", "color32BitToUniform", "abgr", "out", "offset", "alpha", "GraphicsGpuData", "GraphicsPipe", "batch", "BigPool", "renderer", "adaptor", "State", "graphics", "context", "wasBatched", "gpuContext", "instructionSet", "batches", "i", "shader", "localUniforms", "color32BitToUniform", "gpuData", "batchPipe", "roundPixels", "batchClone", "BatchableGraphics", "ExtensionType", "extensions", "GraphicsPipe", "GraphicsContextSystem", "BatchableMesh", "value", "uvBuffer", "uvs", "transformedUvs", "textureMatrix", "MeshGpuData", "MeshPipe", "renderer", "adaptor", "UniformGroup", "Matrix", "BindGroup", "mesh", "meshData", "wasBatched", "isBatched", "geometry", "batchableMesh", "instructionSet", "batcher", "gpuBatchableMesh", "getAdjustedBlendModeBlend", "localUniforms", "color32BitToUniform", "_a", "_b", "gpuMesh", "BatchableMesh", "ExtensionType", "extensions", "MeshPipe", "GlParticleContainerAdaptor", "particleContainerPipe", "container", "state", "renderer", "shader", "gl", "buffer", "glType", "createIndicesForQuads", "size", "outBuffer", "totalIndices", "i", "j", "generateParticleUpdateFunction", "properties", "generateUpdateFunction", "dynamic", "funcFragments", "offset", "i", "property", "attributeInfo", "getAttributeInfoFromFormat", "functionSource", "getParticleSyncKey", "properties", "keyGen", "key", "property", "ParticleBuffer", "options", "size", "staticVertexSize", "dynamicVertexSize", "i", "attributeInfo", "getAttributeInfoFromFormat", "ViewableBuffer", "createIndicesForQuads", "geometry", "Geometry", "dynamicOffset", "staticOffset", "Buffer", "BufferUsage", "uploadFunction", "generateParticleUpdateFunction", "particles", "uploadStatic", "dynamicAttributeBuffer", "staticAttributeBuffer", "fragment", "init_particles_frag", "__esmMin", "vertex", "init_particles_vert", "__esmMin", "wgsl", "init_particles_wgsl", "__esmMin", "ParticleShader", "Shader", "glProgram", "GlProgram", "vertex", "fragment", "gpuProgram", "GpuProgram", "wgsl", "Texture", "TextureStyle", "Matrix", "Color", "ParticleContainerPipe", "renderer", "adaptor", "State", "UniformGroup", "Matrix", "ParticleShader", "_renderable", "renderable", "instructionSet", "ParticleBuffer", "container", "children", "buffer", "state", "getAdjustedBlendModeBlend", "uniforms", "transformationMatrix", "color32BitToUniform", "GlParticleContainerPipe", "ParticleContainerPipe", "renderer", "GlParticleContainerAdaptor", "ExtensionType", "GpuParticleContainerAdaptor", "particleContainerPipe", "container", "renderer", "shader", "state", "buffer", "GpuParticleContainerPipe", "ParticleContainerPipe", "renderer", "GpuParticleContainerAdaptor", "ExtensionType", "extensions", "GlParticleContainerPipe", "GpuParticleContainerPipe", "updateTextBounds", "batchableSprite", "text", "texture", "bounds", "padding", "updateQuadBounds", "paddingOffset", "paddingOffsetY", "BatchableSprite", "BatchableText", "BatchableSprite", "renderer", "text", "canvasText", "CanvasTextPipe", "renderer", "text", "gpuText", "newKey", "instructionSet", "batchableText", "resolution", "updateTextBounds", "BatchableText", "ExtensionType", "repetitionMap", "FillPattern", "texture", "repetition", "uid", "Matrix", "transform", "value", "require_parse_svg_path", "__commonJSMin", "exports", "module", "parse", "length", "segment", "path", "data", "_", "command", "args", "type", "parseValues", "number", "numbers", "parseSVGPath", "svgPath", "path", "commands", "parse", "subpaths", "currentSubPath", "lastX", "lastY", "i", "command", "type", "data", "warn", "Circle", "_Circle", "x", "y", "radius", "r2", "dx", "dy", "width", "alignment", "outerWidth", "distance", "out", "Rectangle", "circle", "Ellipse", "_Ellipse", "x", "y", "halfWidth", "halfHeight", "normx", "normy", "strokeWidth", "alignment", "strokeOuterWidth", "strokeInnerWidth", "innerHorizontal", "innerVertical", "outerHorizontal", "outerVertical", "normalizedX", "normalizedY", "innerEllipse", "outerEllipse", "out", "Rectangle", "ellipse", "squaredDistanceToLineSegment", "x", "y", "x1", "y1", "x2", "y2", "a", "b", "c", "d", "dot", "lenSq", "param", "xx", "yy", "dx", "dy", "tempRect", "tempRect2", "Polygon", "_Polygon", "points", "flat", "p", "i", "il", "area", "length", "x1", "y1", "x2", "y2", "polygon", "thisBounds", "otherBounds", "x", "y", "inside", "j", "xi", "yi", "xj", "yj", "strokeWidth", "alignment", "strokeWidthSquared", "rightWidthSquared", "leftWidthSquared", "iterationLength", "distanceSquared", "squaredDistanceToLineSegment", "sign", "out", "Rectangle", "minX", "maxX", "minY", "maxY", "n", "pointsDesc", "currentPoint", "deprecation", "isCornerWithinStroke", "RoundedRectangle", "pX", "pY", "cornerX", "cornerY", "radius", "strokeWidthInner", "strokeWidthOuter", "dx", "dy", "distance", "_RoundedRectangle", "x", "y", "width", "height", "out", "Rectangle", "rectangle", "radius2", "strokeWidth", "alignment", "innerX", "innerY", "innerWidth", "innerHeight", "rightBound", "bottomBound", "buildAdaptiveBezier", "points", "sX", "sY", "cp1x", "cp1y", "cp2x", "cp2y", "eX", "eY", "smoothness", "smoothing", "GraphicsContextSystem", "distanceTolerance", "PATH_DISTANCE_EPSILON", "begin", "recursive", "x1", "y1", "x2", "y2", "x3", "y3", "x4", "y4", "level", "RECURSION_LIMIT", "pi", "x12", "y12", "x23", "y23", "x34", "y34", "x123", "y123", "x234", "y234", "x1234", "y1234", "dx", "dy", "d2", "d3", "da1", "da2", "FLT_EPSILON", "mAngleTolerance", "curveAngleToleranceEpsilon", "a23", "mCuspLimit", "buildAdaptiveQuadratic", "points", "sX", "sY", "cp1x", "cp1y", "eX", "eY", "smoothness", "smoothing", "GraphicsContextSystem", "distanceTolerance", "PATH_DISTANCE_EPSILON", "begin", "recursive", "x1", "y1", "x2", "y2", "x3", "y3", "level", "RECURSION_LIMIT", "pi", "x12", "y12", "x23", "y23", "x123", "y123", "dx", "dy", "d", "FLT_EPSILON", "mAngleTolerance", "curveAngleToleranceEpsilon", "da", "buildArc", "points", "x", "y", "radius", "start", "end", "clockwise", "steps", "dist", "f", "t", "i", "cs", "sn", "nx", "ny", "buildArcTo", "points", "x1", "y1", "x2", "y2", "radius", "fromX", "a1", "b1", "a2", "b2", "mm", "dd", "cc", "tt", "k1", "k2", "j1", "j2", "cx", "cy", "px", "py", "qx", "qy", "startAngle", "endAngle", "buildArc", "approxUnitArc", "ang1", "ang2", "a1", "a", "x1", "y1", "x2", "y2", "buildArcToSvg", "points", "px", "py", "cx", "cy", "rx", "ry", "xAxisRotation", "largeArcFlag", "sweepFlag", "sinPhi", "TAU", "cosPhi", "pxp", "pyp", "lambda", "getArcCenter", "out", "centerX", "centerY", "ratio", "segments", "lastX", "lastY", "outCurvePoint", "i", "curve", "mapToEllipse", "x", "y", "buildAdaptiveBezier", "vectorAngle", "xp", "yp", "ux", "uy", "vx", "vy", "sign", "dot", "rxSq", "rySq", "pxpSq", "pypSq", "radicant", "centerXp", "centerYp", "vx1", "vy1", "vx2", "vy2", "roundedShapeArc", "g", "points", "radius", "vecFrom", "p", "pp", "x", "y", "len", "nx", "ny", "sharpCorner", "i", "p1", "p2", "pRadius", "p3", "v1", "v2", "angle", "radDirection", "drawDirection", "halfAngle", "cRadius", "lenOut", "cX", "cY", "startAngle", "endAngle", "roundedShapeQuadraticCurve", "smoothness", "distance", "pointLerp", "t", "numPoints", "thisPoint", "lastPoint", "nextPoint", "lastEdgeLength", "start", "lastOffsetDistance", "nextEdgeLength", "end", "nextOffsetDistance", "tempRectangle", "ShapePath", "Rectangle", "graphicsPath2D", "Bounds", "x", "y", "points", "fromX", "fromY", "radius", "startAngle", "endAngle", "counterclockwise", "buildArc", "x1", "y1", "x2", "y2", "buildArcTo", "rx", "ry", "xAxisRotation", "largeArcFlag", "sweepFlag", "buildArcToSvg", "cp1x", "cp1y", "cp2x", "cp2y", "smoothness", "currentPoly", "buildAdaptiveBezier", "smoothing", "buildAdaptiveQuadratic", "path", "transform", "shapePrimitives", "start", "i", "instruction", "mainShape", "shapePrimitive", "polygon", "mainPolygon", "closePath", "w", "h", "Circle", "close", "Polygon", "sides", "rotation", "delta", "angle", "corner", "sideLength", "internalAngle", "x0", "y0", "a1", "a2", "x3", "y3", "useQuadratic", "roundedShapeQuadraticCurve", "roundedShapeArc", "width", "height", "fillet", "maxFillet", "inset", "right", "bottom", "dir", "size", "chamfer", "radiusX", "radiusY", "Ellipse", "RoundedRectangle", "shape", "matrix", "lastShape", "lx", "ly", "t", "tempX", "bounds", "boundsRect", "adjustTransform", "currentMatrix", "transform", "GraphicsPath", "_GraphicsPath", "instructions", "signed", "uid", "parseSVGPath", "ShapePath", "path", "args", "cp2x", "cp2y", "x", "y", "smoothness", "last", "lastPoint", "Point", "cp1x", "cp1y", "currentX", "currentY", "cpx1", "cpy1", "w", "h", "radius", "points", "innerRadius", "rotation", "startAngle", "len", "delta", "polygon", "i", "r", "angle", "deep", "newGraphicsPath2D", "instruction", "matrix", "a", "b", "c", "d", "tx", "ty", "cpx2", "cpy2", "rx", "ry", "data", "warn", "out", "index", "lastInstruction", "parseSVGFloatAttribute", "svg", "id", "defaultValue", "value", "parseSVGDefinitions", "svg", "session", "definitions", "i", "definition", "j", "child", "parseLinearGradient", "parseRadialGradient", "x0", "parseSVGFloatAttribute", "y0", "x1", "y1", "gradientUnit", "gradient", "FillGradient", "k", "stop", "offset", "color", "Color", "_child", "warn", "extractSvgUrlId", "url", "match", "parseSVGStyle", "svg", "session", "style", "strokeStyle", "fillStyle", "result", "key", "styleAttributes", "attribute", "parseAttribute", "styleParts", "i", "stylePart", "value", "id", "extractSvgUrlId", "Color", "checkForNestedPattern", "subpathsWithArea", "areas", "s", "b", "largestArea", "secondArea", "smallestArea", "largestToSecondRatio", "secondToSmallestRatio", "extractSubpaths", "pathData", "part", "calculatePathArea", "coords", "numbers", "xs", "ys", "i", "minX", "maxX", "minY", "maxY", "appendSVGPath", "graphicsPath", "tempPath", "GraphicsPath", "instruction", "SVGParser", "svg", "graphicsContext", "div", "session", "GraphicsPath", "parseSVGDefinitions", "children", "fillStyle", "strokeStyle", "parseSVGStyle", "i", "child", "renderChildren", "f1", "s1", "noStyle", "x", "y", "x1", "y1", "x2", "y2", "cx", "cy", "r", "rx", "ry", "points", "pointsString", "d", "graphicsPath", "width", "height", "fillRule", "subpaths", "extractSubpaths", "hasExplicitEvenodd", "hasMultipleSubpaths", "subpathsWithArea", "subpath", "calculatePathArea", "a", "b", "checkForNestedPattern", "isMainShape", "newPath", "appendSVGPath", "isHole", "useEvenoddForGraphicsPath", "parseSVGFloatAttribute", "n", "warn", "isColorLike", "value", "Color", "isFillPattern", "FillPattern", "isFillGradient", "FillGradient", "isTexture", "Texture", "handleColorLike", "fill", "defaultStyle", "temp", "handleTexture", "handleFillPattern", "handleFillGradient", "handleFillObject", "style", "color", "toFillStyle", "objectStyle", "toStrokeStyle", "width", "alignment", "miterLimit", "cap", "join", "pixelLine", "rest", "tmpPoint", "tempMatrix", "_GraphicsContext", "GraphicsContext", "Point", "Matrix", "eventemitter3_default", "uid", "GraphicsPath", "Bounds", "clone", "value", "toFillStyle", "toStrokeStyle", "style", "texture", "tint", "dx", "dy", "dw", "dh", "Color", "alpha", "path", "lastInstruction", "deprecation", "v8_0_0", "x", "y", "i", "holePath", "radius", "startAngle", "endAngle", "counterclockwise", "t", "x1", "y1", "x2", "y2", "rx", "ry", "xAxisRotation", "largeArcFlag", "sweepFlag", "cp1x", "cp1y", "cp2x", "cp2y", "smoothness", "radiusX", "radiusY", "instructions", "transformedX", "transformedY", "cpx", "cpy", "w", "h", "points", "close", "sides", "rotation", "transform", "corner", "useQuadratic", "width", "height", "fillet", "chamfer", "innerRadius", "svg", "SVGParser", "state", "angle", "a", "b", "c", "d", "bounds", "instruction", "action", "data", "alignment", "outerPadding", "_bounds", "point", "hasHit", "k", "shapes", "shape", "transformedPoint", "strokeStyle", "holes", "holeShapes", "j", "options", "destroyTextureSource", "Texture", "convertV7Tov8Style", "style", "oldStyle", "defaults", "TextStyle", "deprecation", "v8_0_0", "color", "obj", "Color", "FillGradient", "FillPattern", "warn", "gradientFill", "fillGradientStops", "fills", "stop", "index", "_TextStyle", "eventemitter3_default", "uid", "fullStyle", "key", "thisKey", "value", "GraphicsContext", "toFillStyle", "toStrokeStyle", "defaultStyle", "filterPadding", "i", "options", "destroyTextureSource", "cb", "target", "property", "newValue", "getPo2TextureFromSource", "image", "width", "height", "resolution", "bounds", "tempBounds", "texture", "TexturePool", "Bounds", "CanvasPoolClass", "CanvasPool", "canvasOptions", "pixelWidth", "pixelHeight", "canvas", "DOMAdapter", "context", "minWidth", "minHeight", "resolution", "nextPow2", "key", "canvasAndContext", "width", "height", "GlobalResourceRegistry", "ensureInternalCanvas", "width", "height", "_internalCanvas", "DOMAdapter", "_internalContext", "nextPow2", "checkRow", "data", "y", "x", "index", "checkColumn", "top", "bottom", "stride", "getCanvasBoundingBox", "args", "options", "canvas", "resolution", "output", "left", "right", "Rectangle", "lru", "max", "ttl", "resetTtl", "LRU", "init_tiny_lru", "__esmMin", "key", "item", "keys", "bypass", "result", "x", "value", "evicted", "fontStringFromTextStyle", "style", "fontSizeString", "fontFamilies", "i", "fontFamily", "genericFontFamilies", "contextSettings", "_CanvasTextMetrics", "CanvasTextMetrics", "result", "proto", "DOMAdapter", "text", "style", "width", "height", "lines", "lineWidths", "lineHeight", "maxLineWidth", "fontProperties", "canvas", "wordWrap", "textKey", "font", "fontStringFromTextStyle", "context", "i", "lineWidth", "strokeWidth", "measurements", "letterSpacing", "useExperimentalLetterSpacing", "metrics", "metricWidth", "actualBoundingBoxLeft", "boundsWidth", "val", "line", "cache", "whiteSpace", "collapseSpaces", "collapseNewlines", "canPrependSpaces", "wordWrapWidth", "tokens", "token", "currIsBreakingSpace", "lastIsBreakingSpace", "tokenWidth", "characters", "j", "char", "lastChar", "k", "nextChar", "characterWidth", "isLastToken", "newLine", "key", "_nextChar", "_token", "breakWords", "_char", "_index", "_breakWords", "properties", "c", "segmenter", "s", "segments", "segment", "lru", "getCanvasFillStyle", "fillStyle", "context", "textMetrics", "padding", "Texture", "Color", "FillPattern", "fillPattern", "pattern", "tempMatrix", "Matrix", "FillGradient", "fillGradient", "isLinear", "isLocal", "width", "height", "gradient", "isNearlyVertical", "start", "end", "center", "innerRadius", "outerCenter", "outerRadius", "ratio", "i", "stop", "globalStop", "PRECISION", "warn", "tempRect", "CanvasTextGeneratorClass", "CanvasTextGenerator", "Rectangle", "options", "text", "style", "resolution", "padding", "measured", "CanvasTextMetrics", "width", "height", "canvasAndContext", "CanvasPool", "frame", "getCanvasBoundingBox", "canvas", "context", "font", "fontStringFromTextStyle", "lines", "lineHeight", "lineWidths", "maxLineWidth", "fontProperties", "strokeStyle", "linePositionX", "linePositionY", "passesCount", "i", "isShadowPass", "dsOffsetText", "dsOffsetShadow", "shadowOptions", "dropShadowColor", "dropShadowAlpha", "Color", "dropShadowBlur", "dropShadowDistance", "getCanvasFillStyle", "strokePadding", "linePositionYShift", "strokeWidth", "x", "y", "isStroke", "letterSpacing", "useExperimentalLetterSpacing", "currentPosition", "stringArray", "previousWidth", "currentWidth", "currentChar", "textStr", "j", "CanvasTextSystem", "_renderer", "options", "_resolution", "_style", "_textKey", "deprecation", "TextStyle", "TextureStyle", "text", "style", "textureStyle", "resolution", "frame", "canvasAndContext", "CanvasTextGenerator", "texture", "getPo2TextureFromSource", "filteredTexture", "source", "TexturePool", "textKey", "activeTexture", "filters", "currentRenderTarget", "resultTexture", "key", "ExtensionType", "extensions", "CanvasTextSystem", "CanvasTextPipe", "Graphics", "_Graphics", "ViewContainer", "options", "GraphicsContext", "context", "roundPixels", "rest", "point", "method", "args", "value", "deep", "width", "color", "alpha", "deprecation", "v8_0_0", "strokeStyle", "fillStyle", "localUniformMSDFBit", "localUniformMSDFBitGl", "mSDFBit", "mSDFBitGl", "gpuProgram", "glProgram", "SdfShader", "Shader", "maxTextures", "uniforms", "UniformGroup", "Matrix", "compileHighShaderGpuProgram", "colorBit", "generateTextureBatchBit", "localUniformMSDFBit", "mSDFBit", "roundPixelsBit", "compileHighShaderGlProgram", "colorBitGl", "generateTextureBatchBitGl", "localUniformMSDFBitGl", "mSDFBitGl", "roundPixelsBitGl", "getBatchSamplersUniformGroup", "AbstractBitmapFont", "eventemitter3_default", "deprecation", "v8_0_0", "destroyTextures", "i", "page", "_DynamicBitmapFont", "DynamicBitmapFont", "AbstractBitmapFont", "options", "dynamicOptions", "style", "Texture", "requestedFontSize", "font", "fontStringFromTextStyle", "TextureStyle", "CanvasTextMetrics", "chars", "charList", "char", "index", "self", "pageData", "canvas", "context", "textureSource", "currentX", "currentY", "currentMaxCharHeight", "fontScale", "padding", "skipTexture", "maxTextureWidth", "maxTextureHeight", "i", "metrics", "width", "textureGlyphWidth", "height", "paddedWidth", "paddedHeight", "xAdvance", "px", "py", "frame", "Rectangle", "deprecation", "v8_0_0", "newChars", "measureCache", "first", "j", "second", "c1", "c2", "total", "amount", "textureResolution", "canvasAndContext", "CanvasPool", "resolution", "texture", "ImageSource", "stroke", "strokeThickness", "getCanvasFillStyle", "shadowOptions", "rgb", "Color", "dropShadowBlur", "dropShadowDistance", "x", "y", "fontProperties", "tx", "ty", "descent", "lineHeight", "removeShadow", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "TextStyle", "getBitmapTextLayout", "chars", "style", "font", "trimEnd", "layoutData", "currentLine", "previousChar", "firstWord", "currentWord", "scale", "adjustedLetterSpacing", "adjustedWordWrapWidth", "adjustedLineHeight", "breakWords", "nextWord", "word", "start", "j", "position", "nextLine", "index", "lastChar", "checkIsOverflow", "lineWidth", "i", "char", "isEnd", "charData", "spaceWidth", "kerning", "nextCharWidth", "alignCenter", "alignRight", "alignJustify", "measurementData", "line", "offset", "width", "indy", "spaceIndex", "totalSpaces", "resolveCharacters", "chars", "result", "i", "j", "item", "startCode", "endCode", "fontCount", "BitmapFontManagerClass", "BitmapFontManager", "lru", "text", "style", "fontFamilyKey", "overrideFill", "Cache", "styleCopy", "fnt", "DynamicBitmapFont", "warn", "dynamicFont", "trimEnd", "bitmapFont", "id", "segments", "CanvasTextMetrics", "layoutData", "getBitmapTextLayout", "args", "options", "deprecation", "v8_0_0", "name", "textStyle", "TextStyle", "font", "flatChars", "resolveCharacters", "cacheKey", "syncWithProxy", "container", "proxy", "BitmapTextGraphics", "BitmapTextPipe", "Graphics", "renderer", "bitmapText", "graphicsRenderable", "instructionSet", "proxyGraphics", "context", "bitmapFont", "BitmapFontManager", "SdfShader", "chars", "CanvasTextMetrics", "style", "currentY", "bitmapTextLayout", "getBitmapTextLayout", "padding", "scale", "tx", "ty", "tint", "fontSize", "lineHeight", "linePositionYShift", "i", "line", "j", "char", "charData", "texture", "proxyRenderable", "fontFamily", "dynamicFont", "Cache", "a", "b", "c", "d", "dx", "dy", "worldScale", "fontScale", "distance", "ExtensionType", "extensions", "BitmapTextPipe", "BatchableHTMLText", "BatchableSprite", "renderer", "text", "htmlText", "HTMLTextPipe", "renderer", "htmlText", "gpuText", "newKey", "instructionSet", "batchableHTMLText", "resolution", "e", "updateTextBounds", "oldTexturePromise", "texturePromise", "renderGroup", "BatchableHTMLText", "Texture", "ExtensionType", "isSafari", "userAgent", "DOMAdapter", "nssvg", "nsxhtml", "HTMLTextRenderData", "foreignObject", "svgRoot", "styleElement", "domElement", "DOMAdapter", "extractFontFamilies", "text", "style", "fontFamily", "fontFamilies", "dedupe", "regex", "matches", "addFontFamily", "i", "match", "loadFontAsBase64", "url", "blob", "DOMAdapter", "reader", "resolve", "reject", "loadFontCSS", "style", "url", "dataSrc", "loadFontAsBase64", "getFontCss", "fontFamilies", "fontPromises", "fontFamily", "Cache", "FontStylePromiseCache", "entries", "promises", "entry", "url", "out", "face", "style", "loadFontCSS", "css", "getSVGUrl", "text", "style", "resolution", "fontCSS", "htmlTextData", "domElement", "styleElement", "svgRoot", "width", "height", "getTemporaryCanvasFromImage", "image", "resolution", "canvasAndContext", "CanvasPool", "context", "loadSVGImage", "image", "url", "delay", "resolve", "measureHtmlText", "text", "style", "fontStyleCSS", "htmlTextRenderData", "tempHTMLTextRenderData", "HTMLTextRenderData", "domElement", "styleElement", "svgRoot", "contentBounds", "doublePadding", "HTMLTextSystem", "renderer", "RendererType", "options", "text", "textKey", "promise", "texture", "activeTexture", "warn", "style", "resolution", "textureStyle", "htmlTextData", "BigPool", "HTMLTextRenderData", "fontFamilies", "extractFontFamilies", "fontCSS", "getFontCss", "measured", "measureHtmlText", "width", "height", "image", "uvSafeOffset", "svgURL", "getSVGUrl", "loadSVGImage", "isSafari", "resource", "canvasAndContext", "getTemporaryCanvasFromImage", "getPo2TextureFromSource", "CanvasPool", "texturePromise", "TexturePool", "key", "ExtensionType", "extensions", "HTMLTextSystem", "HTMLTextPipe", "_MeshGeometry", "MeshGeometry", "Geometry", "args", "options", "deprecation", "v8_0_0", "positions", "uvs", "indices", "shrinkToFit", "positionBuffer", "Buffer", "BufferUsage", "uvBuffer", "indexBuffer", "value", "localUniformBit", "localUniformBitGroup2", "localUniformBitGl", "tilingBit", "tilingBitGl", "gpuProgram", "glProgram", "TilingSpriteShader", "Shader", "compileHighShaderGpuProgram", "localUniformBit", "tilingBit", "roundPixelsBit", "compileHighShaderGlProgram", "localUniformBitGl", "tilingBitGl", "roundPixelsBitGl", "tilingUniforms", "UniformGroup", "Matrix", "Texture", "width", "height", "matrix", "anchorX", "anchorY", "texture", "textureWidth", "textureHeight", "textureMatrix", "uTextureTransform", "QuadGeometry", "MeshGeometry", "setPositions", "tilingSprite", "positions", "anchorX", "anchorY", "applyMatrix", "array", "stride", "offset", "matrix", "index", "size", "a", "b", "c", "d", "tx", "ty", "x", "y", "setUvs", "tilingSprite", "uvs", "texture", "width", "height", "anchorX", "anchorY", "textureMatrix", "Matrix", "applyMatrix", "sharedQuad", "TilingSpriteGpuData", "TilingSpritePipe", "QuadGeometry", "MeshGeometry", "renderer", "State", "renderable", "tilingSpriteData", "couldBatch", "canBatch", "batchableMesh", "tilingSprite", "instructionSet", "batcher", "geometry", "BatchableMesh", "TilingSpriteShader", "shader", "localUniforms", "color32BitToUniform", "getAdjustedBlendModeBlend", "gpuData", "renderableData", "style", "setUvs", "setPositions", "texture", "_nonPowOf2wrapping", "RendererType", "ExtensionType", "extensions", "TilingSpritePipe", "_PlaneGeometry", "PlaneGeometry", "MeshGeometry", "args", "options", "deprecation", "v8_0_0", "total", "verts", "uvs", "indices", "verticesX", "verticesY", "sizeX", "sizeY", "i", "x", "y", "totalSub", "xpos", "ypos", "value", "value2", "value3", "value4", "_NineSliceGeometry", "NineSliceGeometry", "PlaneGeometry", "options", "p", "width", "height", "_leftWidth", "_rightWidth", "_topHeight", "_bottomHeight", "_anchorX", "_anchorY", "w", "scaleW", "h", "scaleH", "scale", "anchorOffsetX", "anchorOffsetY", "uvs", "_uvw", "_uvh", "NineSliceSpriteGpuData", "NineSliceSpritePipe", "BatchableMesh", "NineSliceGeometry", "renderer", "sprite", "instructionSet", "gpuSprite", "batchableSprite", "gpuData", "batchableMesh", "ExtensionType", "extensions", "NineSliceSpritePipe", "FilterPipe", "renderer", "filterEffect", "container", "instructionSet", "_filterEffect", "_container", "instruction", "ExtensionType", "_Filter", "Filter", "Shader", "options", "State", "filterManager", "input", "output", "clearMode", "value", "gpu", "gl", "rest", "gpuProgram", "glProgram", "GpuProgram", "GlProgram", "vertex", "init_defaultFilter_vert", "__esmMin", "fragment", "init_passthrough_frag", "__esmMin", "source", "init_passthrough_wgsl", "__esmMin", "PassthroughFilter", "Filter", "gpuProgram", "GpuProgram", "source", "glProgram", "GlProgram", "vertex", "fragment", "getGlobalRenderableBounds", "renderables", "bounds", "actualMatrix", "i", "renderable", "renderGroup", "tempProjectionMatrix", "Matrix", "quadGeometry", "FilterData", "FilterSystem", "Geometry", "Bounds", "renderer", "UniformGroup", "BindGroup", "instruction", "filters", "filterData", "colorTextureSource", "rootResolution", "rootAntialias", "filter", "bounds", "previousFilterData", "globalResolution", "offsetX", "offsetY", "texture", "TexturePool", "Texture", "outputTexture", "lastRenderSurface", "previousBounds", "backgroundResolution", "backTexture", "x", "y", "width", "height", "input", "output", "clear", "isFinalTarget", "resolution", "offset", "filterToApply", "outputMatrix", "sprite", "data", "mappedMatrix", "worldTransform", "Matrix", "renderGroup", "PassthroughFilter", "batchUniforms", "RendererType", "renderTarget", "sourceWidth", "sourceHeight", "globalFrame", "uniforms", "outputFrame", "inputSize", "inputPixel", "inputClamp", "rootTexture", "currentIndex", "lastIndex", "prevFilterData", "getGlobalRenderableBounds", "filterFrameTransform", "inputTexture", "firstEnabled", "lastEnabled", "flip", "tempTexture", "flop", "i", "t", "viewPort", "paddingMultiplier", "padding", "antialias", "blendRequired", "enabled", "clipToViewport", "firstEnabledIndex", "lastEnabledIndex", "warn", "index", "ExtensionType", "extensions", "FilterSystem", "FilterPipe", "browserAll_exports", "init_browserAll", "__esmMin", "init_init", "webworkerAll_exports", "init_webworkerAll", "__esmMin", "init_init", "loadEnvironmentExtensions", "skip", "i", "environments", "env", "extensions", "ExtensionType", "unsafeEvalSupported", "unsafeEval", "CLEAR", "SystemRunner", "name", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "items", "i", "len", "item", "index", "defaultRunners", "_AbstractRenderer", "AbstractRenderer", "eventemitter3_default", "config", "uid", "combinedRunners", "options", "skip", "loadEnvironmentExtensions", "systemName", "i", "args", "deprecated", "Container", "deprecation", "v8_0_0", "isRGBAArray", "Color", "desiredScreenWidth", "desiredScreenHeight", "resolution", "previousResolution", "renderer", "CLEAR", "clear", "clearColor", "target", "value", "runnerIds", "runnerId", "SystemRunner", "systems", "val", "ClassRef", "name", "system", "pipes", "pipeAdaptors", "adaptors", "acc", "adaptor", "pipe", "PipeClass", "Adaptor", "runner", "GlobalResourceRegistry", "unsafeEvalSupported", "GpuGraphicsAdaptor", "renderer", "localUniforms", "UniformGroup", "Matrix", "gpuProgram", "compileHighShaderGpuProgram", "colorBit", "generateTextureBatchBit", "localUniformBitGroup2", "roundPixelsBit", "Shader", "graphicsPipe", "renderable", "context", "shader", "contextSystem", "batcher", "instructions", "encoder", "globalUniformsBindGroup", "localBindGroup", "batches", "topology", "i", "batch", "textureBatch", "getTextureBatchBindGroup", "ExtensionType", "textureBit", "textureBitGl", "GpuMeshAdapter", "gpuProgram", "compileHighShaderGpuProgram", "localUniformBit", "textureBit", "roundPixelsBit", "Shader", "Texture", "Matrix", "meshPipe", "mesh", "renderer", "shader", "warn", "localUniforms", "ExtensionType", "tempState", "GpuBatchAdaptor", "State", "batchPipe", "geometry", "shader", "renderer", "encoder", "program", "globalUniformsBindGroup", "batch", "textureBatch", "getTextureBatchBindGroup", "gpuBindGroup", "pipeline", "ExtensionType", "CustomRenderPipe", "renderer", "container", "instructionSet", "ExtensionType", "executeInstructions", "renderGroup", "renderer", "instructionSet", "instructions", "i", "instruction", "tempMatrix", "RenderGroupPipe", "Matrix", "renderer", "renderGroup", "instructionSet", "BigPool", "batchableRenderGroup", "BatchableSprite", "worldTransformMatrix", "executeInstructions", "ExtensionType", "clearList", "list", "index", "j", "updateRenderGroupTransforms", "renderGroup", "updateChildRenderGroups", "updateRenderGroupTransform", "childrenToUpdate", "updateTick", "j", "renderGroupDepth", "childrenAtDepth", "list", "index", "i", "child", "updateTransformAndChildren", "clearList", "root", "worldAlpha", "renderGroupParent", "multiplyColors", "container", "updateFlags", "localTransform", "parent", "UPDATE_BLEND_COLOR_VISIBLE", "updateColorBlendVisibility", "tempContainer", "children", "length", "renderable", "UPDATE_COLOR", "groupAlpha", "UPDATE_BLEND", "UPDATE_VISIBLE", "Container", "validateRenderables", "renderGroup", "renderPipes", "list", "rebuildRequired", "i", "container", "tempMatrix", "RenderGroupSystem", "Matrix", "renderer", "container", "transform", "parent", "renderGroupParent", "originalLocalTransform", "renderPipes", "executeInstructions", "renderGroup", "closestCacheAsTexture", "i", "bounds", "lastTexture", "TexturePool", "resolution", "antialias", "scaleMode", "texture", "TextureStyle", "Bounds", "clearList", "validateRenderables", "updateRenderGroupTransforms", "list", "index", "rendererOrPipes", "root", "instructionSet", "ExtensionType", "SpritePipe", "renderer", "sprite", "instructionSet", "gpuSprite", "batchableSprite", "BatchableSprite", "ExtensionType", "VERSION", "ApplicationInitHook", "RendererInitHook", "VERSION", "ExtensionType", "renderer", "_BatcherPipe", "BatcherPipe", "renderer", "adaptor", "State", "name", "instructionSet", "batchers", "DefaultBatcher", "i", "batchableObject", "batch", "batches", "geometry", "batcher", "shader", "ExtensionType", "extensions", "fragment", "init_mask_frag", "__esmMin", "vertex", "init_mask_vert", "__esmMin", "source", "init_mask_wgsl", "__esmMin", "MaskFilter", "Filter", "options", "sprite", "rest", "textureMatrix", "TextureMatrix", "filterUniforms", "UniformGroup", "Matrix", "gpuProgram", "GpuProgram", "source", "glProgram", "GlProgram", "vertex", "fragment", "value", "filterManager", "input", "output", "clearMode", "tempBounds", "AlphaMaskEffect", "AlphaMaskPipe", "Bounds", "FilterEffect", "MaskFilter", "Sprite", "Texture", "value", "renderer", "mask", "maskedContainer", "instructionSet", "maskContainer", "_maskedContainer", "instruction", "renderMask", "filterEffect", "BigPool", "bounds", "getGlobalBounds", "colorTextureSource", "filterTexture", "TexturePool", "sprite", "maskData", "RendererType", "ExtensionType", "ColorMaskPipe", "renderer", "mask", "_container", "instructionSet", "colorStack", "currentColor", "_mask", "instruction", "ExtensionType", "StencilMaskPipe", "renderer", "mask", "_container", "instructionSet", "_a", "effect", "maskContainer", "maskData", "instructionsLength", "renderTargetUid", "i", "instruction", "maskStackIndex", "STENCIL_MODES", "CLEAR", "ExtensionType", "_BackgroundSystem", "BackgroundSystem", "Color", "options", "value", "warn", "ExtensionType", "BLEND_MODE_FILTERS", "BlendModePipe", "extensions", "ExtensionType", "value", "renderer", "renderable", "blendMode", "instructionSet", "isRenderGroup", "RenderGroup", "warn", "filterEffect", "instruction", "FilterEffect", "i", "imageTypes", "_ExtractSystem", "ExtractSystem", "renderer", "options", "defaults", "Container", "Texture", "image", "DOMAdapter", "format", "quality", "canvas", "resolve", "reject", "blob", "reader", "target", "texture", "pixelInfo", "link", "width", "base64", "style", "ExtensionType", "RenderTexture", "_RenderTexture", "Texture", "options", "TextureSource", "width", "height", "resolution", "tempRect", "tempBounds", "noColor", "GenerateTextureSystem", "Rectangle", "Bounds", "renderer", "options", "Container", "resolution", "antialias", "container", "clearColor", "Color", "region", "getLocalBounds", "target", "RenderTexture", "transform", "Matrix", "ExtensionType", "GlobalUniformSystem", "renderer", "i", "options", "size", "projectionMatrix", "worldTransformMatrix", "worldColor", "offset", "renderTarget", "currentGlobalUniformData", "Matrix", "Point", "globalUniformData", "uniformGroup", "uniforms", "color32BitToUniform", "bindGroup", "BindGroup", "RendererType", "UniformGroup", "ExtensionType", "uid", "SchedulerSystem", "Ticker", "func", "duration", "useOffset", "id", "offset", "i", "now", "task", "elapsed", "ExtensionType", "sayHello", "type", "saidHello", "DOMAdapter", "args", "VERSION", "HelloSystem", "renderer", "options", "name", "RendererType", "sayHello", "ExtensionType", "cleanHash", "hash", "clean", "i", "value", "cleanArray", "arr", "offset", "renderableGCTick", "_RenderableGCSystem", "RenderableGCSystem", "renderer", "options", "value", "hash", "cleanHash", "array", "cleanArray", "context", "container", "renderable", "now", "managedRenderables", "renderPipes", "offset", "i", "renderGroup", "currentTick", "rp", "index", "gcTick", "child", "ExtensionType", "_TextureGCSystem", "TextureGCSystem", "renderer", "options", "managedTextures", "i", "texture", "ExtensionType", "_RenderTarget", "RenderTarget", "descriptor", "uid", "i", "TextureSource", "texture", "colorSource", "Texture", "_size", "source", "width", "height", "resolution", "skipColorTexture", "colorTexture", "getCanvasTexture", "canvas", "options", "canvasCache", "texture", "Texture", "CanvasSource", "onDestroy", "GlobalResourceRegistry", "_ViewSystem", "ViewSystem", "value", "options", "deprecation", "v8_0_0", "Rectangle", "DOMAdapter", "getCanvasTexture", "RenderTarget", "desiredScreenWidth", "desiredScreenHeight", "resolution", "ExtensionType", "SharedSystems", "SharedRenderPipes", "BackgroundSystem", "GlobalUniformSystem", "HelloSystem", "ViewSystem", "RenderGroupSystem", "TextureGCSystem", "GenerateTextureSystem", "ExtractSystem", "RendererInitHook", "RenderableGCSystem", "SchedulerSystem", "BlendModePipe", "BatcherPipe", "SpritePipe", "RenderGroupPipe", "AlphaMaskPipe", "StencilMaskPipe", "ColorMaskPipe", "CustomRenderPipe", "BindGroupSystem", "renderer", "gpu", "bindGroup", "program", "groupIndex", "group", "device", "groupLayout", "entries", "j", "resource", "gpuResource", "uniformGroup", "buffer", "bufferResource", "sampler", "texture", "layout", "gpuBindGroup", "key", "ExtensionType", "GpuBufferSystem", "renderer", "gpu", "buffer", "gpuBuffer", "data", "id", "fastCopy", "ExtensionType", "GpuColorMaskSystem", "renderer", "colorMask", "ExtensionType", "GpuDeviceSystem", "renderer", "options", "gpu", "adapter", "DOMAdapter", "requiredFeatures", "feature", "device", "ExtensionType", "GpuEncoderSystem", "renderer", "resolve", "gpuRenderTarget", "viewport", "geometry", "program", "state", "topology", "pipeline", "index", "buffer", "indexFormat", "bindGroup", "gpuBindGroup", "buffersToBind", "i", "shader", "skipSync", "j", "resource", "options", "size", "start", "instanceCount", "descriptor", "boundPipeline", "boundVertexBuffer", "boundIndexBuffer", "boundBindGroup", "gpu", "ExtensionType", "GpuLimitsSystem", "renderer", "ExtensionType", "GpuStencilSystem", "renderer", "renderTarget", "stencilState", "STENCIL_MODES", "stencilMode", "stencilReference", "ExtensionType", "UboSystem", "adaptor", "unsafeEvalSupported", "uniformGroup", "uniformData", "Buffer", "BufferUsage", "uniformGroupSignature", "elements", "i", "layout", "syncFunction", "uboElements", "data", "offset", "uniformGroupData", "dataInt32", "synced", "createUboElementsWGSL", "uniformData", "uboElements", "data", "offset", "i", "uboElement", "size", "WGSL_ALIGN_SIZE_DATA", "align", "uniformParsers", "data", "createUboSyncFunction", "uboElements", "parserCode", "arrayGenerationFunction", "singleSettersMap", "funcFragments", "prev", "i", "uboElement", "name", "parsed", "offset", "j", "uniformParsers", "template", "fragmentSrc", "loopMatrix", "col", "row", "uboSyncFunctionsSTD40", "uboSyncFunctionsWGSL", "generateArraySyncWGSL", "uboElement", "offsetToAdd", "size", "align", "WGSL_ALIGN_SIZE_DATA", "remainder", "data", "createUboSyncFunctionWGSL", "uboElements", "createUboSyncFunction", "generateArraySyncWGSL", "uboSyncFunctionsWGSL", "GpuUboSystem", "UboSystem", "createUboElementsWGSL", "createUboSyncFunctionWGSL", "ExtensionType", "BufferResource", "eventemitter3_default", "buffer", "offset", "size", "uid", "destroyBuffer", "UboBatch", "minUniformOffsetAlignment", "size", "start", "newSize", "array", "offset", "i", "minUniformOffsetAlignment", "GpuUniformBatchPipe", "renderer", "UboBatch", "totalBuffers", "i", "usage", "BufferUsage", "Buffer", "group", "duplicate", "data", "offset", "index", "buffer", "BufferResource", "bindGroup", "BindGroup", "bufferSystem", "firstBuffer", "commandEncoder", "ExtensionType", "ensureAttributes", "geometry", "extractedData", "i", "attribute", "attributeData", "warn", "ensureStartAndStride", "buffers", "attributes", "tempStride", "tempStart", "j", "buffer", "getAttributeInfoFromFormat", "GpuStencilModesToPixi", "STENCIL_MODES", "getGraphicsStateKey", "geometryLayout", "shaderKey", "state", "blendMode", "topology", "getGlobalStateKey", "stencilStateId", "multiSampleCount", "colorMask", "renderTarget", "topologyStringToId", "PipelineSystem", "renderer", "gpu", "STENCIL_MODES", "multisampleCount", "stencilMode", "GpuStencilModesToPixi", "geometry", "program", "passEncoder", "pipeline", "ensureAttributes", "key", "device", "buffers", "blendModes", "layout", "descriptor", "code", "keyGen", "index", "attributeKeys", "i", "attribute", "stringKey", "createIdFromString", "data", "bufferNamesToBind", "attributeData", "shaderLocation", "j", "vertexBuffersLayout", "buffer", "bufferEntry", "bufferEntryAttributes", "warn", "ExtensionType", "calculateProjection", "pm", "x", "y", "width", "height", "flipY", "sign", "isRenderingToScreen", "renderTarget", "resource", "RenderTargetSystem", "renderer", "Rectangle", "SystemRunner", "Matrix", "target", "clear", "clearColor", "frame", "isRenderingToScreen", "renderSurface", "renderTarget", "didChange", "gpuRenderTarget", "source", "viewport", "pixelWidth", "pixelHeight", "Texture", "resolution", "calculateProjection", "CLEAR", "currentRenderTargetData", "sourceRenderSurfaceTexture", "destinationTexture", "originSrc", "size", "originDest", "key", "CanvasSource", "getCanvasTexture", "RenderTarget", "TextureSource", "GpuRenderTarget", "GpuRenderTargetAdaptor", "renderer", "renderTargetSystem", "sourceRenderSurfaceTexture", "destinationTexture", "originSrc", "size", "originDest", "baseGpuTexture", "backGpuTexture", "renderTarget", "clear", "clearColor", "viewport", "gpuRenderTarget", "descriptor", "clearValue", "CLEAR", "colorAttachments", "texture", "i", "context", "view", "resolveTarget", "loadOp", "depthStencilAttachment", "stencilLoadOp", "depthLoadOp", "gpu", "encoder", "device", "commandEncoder", "renderPassDescriptor", "passEncoder", "gpuCommands", "GpuRenderTarget", "colorTexture", "CanvasSource", "alphaMode", "e", "msaaTexture", "TextureSource", "GpuRenderTargetSystem", "RenderTargetSystem", "renderer", "GpuRenderTargetAdaptor", "ExtensionType", "GpuShaderSystem", "gpu", "program", "device", "bindGroups", "group", "pipelineLayoutDesc", "ExtensionType", "GpuBlendModesToPixi", "GpuStateSystem", "State", "gpu", "state", "GpuBlendModesToPixi", "ExtensionType", "gpuUploadBufferImageResource", "source", "gpuTexture", "gpu", "resource", "total", "bytesPerPixel", "blockDataMap", "defaultBlockData", "gpuUploadCompressedTextureResource", "source", "gpuTexture", "gpu", "mipWidth", "mipHeight", "blockData", "i", "levelBuffer", "bytesPerRow", "gpuUploadImageResource", "source", "gpuTexture", "gpu", "resource", "canvas", "DOMAdapter", "warn", "width", "height", "premultipliedAlpha", "gpuUploadVideoResource", "source", "gpuTexture", "gpu", "gpuUploadImageResource", "GpuMipmapGenerator", "device", "format", "pipeline", "texture", "mipTexture", "arrayLayerCount", "renderToSource", "mipTextureDescriptor", "commandEncoder", "bindGroupLayout", "arrayLayer", "srcView", "dstMipLevel", "i", "dstView", "passEncoder", "bindGroup", "mipLevelSize", "GpuTextureSystem", "renderer", "gpuUploadImageResource", "gpuUploadBufferImageResource", "gpuUploadVideoResource", "gpuUploadCompressedTextureResource", "gpu", "source", "biggestDimension", "usage", "blockData", "blockDataMap", "width", "height", "textureDescriptor", "gpuTexture", "GpuMipmapGenerator", "sampler", "texture", "BindGroup", "UniformGroup", "commandEncoder", "canvas", "DOMAdapter", "context", "webGPUCanvas", "canvasAndContext", "CanvasPool", "imageData", "pixels", "k", "key", "ExtensionType", "DefaultWebGPUSystems", "DefaultWebGPUPipes", "DefaultWebGPUAdapters", "systems", "renderPipes", "renderPipeAdaptors", "WebGPURenderer", "SharedSystems", "GpuUboSystem", "GpuEncoderSystem", "GpuDeviceSystem", "GpuLimitsSystem", "GpuBufferSystem", "GpuTextureSystem", "GpuRenderTargetSystem", "GpuShaderSystem", "GpuStateSystem", "PipelineSystem", "GpuColorMaskSystem", "GpuStencilSystem", "BindGroupSystem", "SharedRenderPipes", "GpuUniformBatchPipe", "GpuBatchAdaptor", "GpuMeshAdapter", "GpuGraphicsAdaptor", "extensions", "ExtensionType", "AbstractRenderer", "systemConfig", "RendererType", "GlGraphicsAdaptor", "renderer", "uniforms", "UniformGroup", "Matrix", "maxTextures", "glProgram", "compileHighShaderGlProgram", "colorBitGl", "generateTextureBatchBitGl", "localUniformBitGl", "roundPixelsBitGl", "Shader", "getBatchSamplersUniformGroup", "graphicsPipe", "renderable", "context", "shader", "contextSystem", "batcher", "instructions", "batches", "i", "batch", "j", "ExtensionType", "GlMeshAdaptor", "glProgram", "compileHighShaderGlProgram", "localUniformBitGl", "textureBitGl", "roundPixelsBitGl", "Shader", "Texture", "Matrix", "meshPipe", "mesh", "renderer", "shader", "warn", "texture", "source", "ExtensionType", "GlBatchAdaptor", "State", "batcherPipe", "batchPipe", "geometry", "shader", "renderer", "didUpload", "batch", "textures", "i", "ExtensionType", "BUFFER_TYPE", "GlBuffer", "buffer", "type", "GlBufferSystem", "renderer", "buffer", "gl", "glBuffer", "index", "hasTransformFeedback", "freeIndex", "loop", "nextIndex", "curBuf", "offset", "size", "data", "drawType", "BufferUsage", "id", "contextLost", "type", "BUFFER_TYPE", "GlBuffer", "ExtensionType", "_GlContextSystem", "GlContextSystem", "renderer", "gl", "options", "multiView", "warn", "DOMAdapter", "alpha", "premultipliedAlpha", "antialias", "targetCanvas", "canvas", "element", "preferWebGLVersion", "common", "provokeExt", "event", "attributes", "supports", "isWebGl2", "extensions", "ExtensionType", "GL_FORMATS", "GL_TARGETS", "GL_TYPES", "getGlTypeFromFormat", "format", "infoMap", "GL_TYPES", "topologyToGlMap", "GlGeometrySystem", "renderer", "gl", "nativeVaoExtension", "vao", "nativeInstancedExtension", "a", "b", "c", "d", "e", "geometry", "program", "bufferSystem", "i", "buffer", "geometryAttributes", "shaderAttributes", "j", "attribs", "strings", "_incRefCount", "signature", "vaoObjectHash", "ensureAttributes", "buffers", "contextLost", "attributes", "lastBuffer", "attribute", "glBuffer", "programAttrib", "location", "attributeInfo", "getAttributeInfoFromFormat", "type", "getGlTypeFromFormat", "divisor", "topology", "size", "start", "instanceCount", "glTopology", "byteSize", "glType", "ExtensionType", "bigTriangleGeometry", "_GlBackBufferSystem", "GlBackBufferSystem", "Geometry", "renderer", "options", "useBackBuffer", "antialias", "warn", "State", "bigTriangleProgram", "GlProgram", "Shader", "Texture", "renderTarget", "targetSourceTexture", "TextureSource", "ExtensionType", "GlColorMaskSystem", "renderer", "colorMask", "ExtensionType", "GlEncoderSystem", "renderer", "geometry", "shader", "options", "state", "skipSync", "type", "size", "start", "instanceCount", "ExtensionType", "GlLimitsSystem", "renderer", "gl", "checkMaxIfStatementsInShader", "isWebGl2", "ExtensionType", "GlStencilSystem", "renderer", "STENCIL_MODES", "gl", "renderTarget", "stencilState", "stencilMode", "stencilReference", "mode", "GpuStencilModesToPixi", "_stencilCache", "ExtensionType", "createUboElementsSTD40", "uniformData", "uboElements", "data", "chunkSize", "size", "offset", "i", "uboElement", "WGSL_TO_STD40_SIZE", "boundary", "curOffset", "generateArraySyncSTD40", "uboElement", "offsetToAdd", "rowSize", "WGSL_TO_STD40_SIZE", "elementSize", "remainder", "data", "createUboSyncFunctionSTD40", "uboElements", "createUboSyncFunction", "generateArraySyncSTD40", "uboSyncFunctionsSTD40", "GlUboSystem", "UboSystem", "createUboElementsSTD40", "createUboSyncFunctionSTD40", "ExtensionType", "GlRenderTarget", "GlRenderTargetAdaptor", "Rectangle", "renderer", "renderTargetSystem", "sourceRenderSurfaceTexture", "destinationTexture", "originSrc", "size", "originDest", "glRenderTarget", "gl", "renderTarget", "clear", "clearColor", "viewport", "source", "gpuRenderTarget", "viewPortY", "texture", "viewPortCache", "GlRenderTarget", "CanvasSource", "renderBuffer", "_renderTarget", "CLEAR", "clearColorCache", "clearColorArray", "resolveTargetFramebuffer", "colorTexture", "i", "warn", "glTexture", "viewFramebuffer", "_", "msaaRenderBuffer", "glInternalFormat", "depthStencilRenderBuffer", "resource", "contextCanvas", "canvasSource", "GlRenderTargetSystem", "RenderTargetSystem", "renderer", "GlRenderTargetAdaptor", "ExtensionType", "generateShaderSyncCode", "shader", "shaderSystem", "funcFragments", "headerFragments", "addedTextreSystem", "textureCount", "programData", "i", "group", "j", "resource", "UniformGroup", "resName", "BufferResource", "TextureSource", "uniformName", "uniformData", "functionSource", "GlProgramData", "program", "uniformData", "compileShader", "gl", "type", "src", "shader", "booleanArray", "size", "array", "i", "defaultValue", "type", "mapType", "gl", "type", "GL_TABLE", "typeNames", "GL_TO_GLSL_TYPES", "i", "tn", "mapGlToVertexFormat", "typeValue", "GLSL_TO_VERTEX_TYPES", "extractAttributesFromGlProgram", "program", "gl", "sortAttributes", "attributes", "totalAttributes", "i", "attribData", "format", "mapGlToVertexFormat", "getAttributeInfoFromFormat", "keys", "a", "b", "getUboData", "program", "gl", "uniformBlocks", "totalUniformsBlocks", "i", "name", "uniformBlockIndex", "size", "getUniformData", "program", "gl", "uniforms", "totalUniforms", "i", "uniformData", "name", "isArray", "type", "mapType", "defaultValue", "logPrettyShaderError", "gl", "shader", "shaderSrc", "line", "index", "shaderLog", "splitShader", "dedupe", "lineNumbers", "n", "logArgs", "number", "fragmentSourceToLog", "logProgramError", "program", "vertexShader", "fragmentShader", "generateProgram", "gl", "program", "glVertShader", "compileShader", "glFragShader", "webGLProgram", "transformFeedbackVaryings", "warn", "logProgramError", "extractAttributesFromGlProgram", "getUniformData", "getUboData", "uniformData", "i", "data", "defaultValue", "GlProgramData", "defaultSyncData", "GlShaderSystem", "renderer", "gl", "shader", "skipSync", "syncFunction", "uniformGroup", "name", "index", "bufferSystem", "programData", "isBufferResource", "buffer", "glBuffer", "boundLocation", "offset", "size", "uniformBlockIndex", "program", "key", "generateProgram", "shaderSystem", "generateShaderSyncCode", "ExtensionType", "UNIFORM_TO_SINGLE_SETTERS", "UNIFORM_TO_ARRAY_SETTERS", "generateUniformsSync", "group", "uniformData", "funcFragments", "i", "UniformGroup", "BufferResource", "uniform", "parsed", "j", "uniformParsers", "parser", "template", "UNIFORM_TO_SINGLE_SETTERS", "UNIFORM_TO_ARRAY_SETTERS", "GlUniformGroupSystem", "renderer", "gl", "group", "program", "syncData", "programData", "uniformGroupSyncHash", "id", "uniformData", "generateUniformsSync", "preFix", "uniforms", "strings", "i", "ExtensionType", "mapWebGLBlendModesToPixi", "gl", "blendMap", "DOMAdapter", "ext", "BLEND", "OFFSET", "CULLING", "DEPTH_TEST", "WINDING", "DEPTH_MASK", "_GlStateSystem", "GlStateSystem", "renderer", "State", "renderTarget", "gl", "mapWebGLBlendModesToPixi", "state", "diff", "i", "value", "faceMode", "mode", "scale", "func", "index", "system", "ExtensionType", "GlTexture", "texture", "GL_TARGETS", "GL_TYPES", "GL_FORMATS", "glUploadBufferImageResource", "source", "glTexture", "gl", "compressedFormatMap", "glUploadCompressedTextureResource", "source", "glTexture", "gl", "mipWidth", "mipHeight", "compressed", "i", "levelBuffer", "glUploadImageResource", "source", "glTexture", "gl", "webGLVersion", "glWidth", "glHeight", "textureWidth", "textureHeight", "resourceWidth", "resourceHeight", "glUploadVideoResource", "source", "glTexture", "gl", "webGLVersion", "glUploadImageResource", "scaleModeToGlFilter", "mipmapScaleModeToGlFilter", "wrapModeToGlAddress", "compareModeToGlCompare", "applyStyleParams", "style", "gl", "mipmaps", "anisotropicExt", "glFunctionName", "firstParam", "forceClamp", "firstCreation", "castParam", "wrapModeS", "wrapModeToGlAddress", "wrapModeT", "wrapModeR", "scaleModeToGlFilter", "glFilterMode", "mipmapScaleModeToGlFilter", "level", "compareModeToGlCompare", "mapFormatToGlFormat", "gl", "mapFormatToGlInternalFormat", "gl", "extensions", "srgb", "bgra8unorm", "DOMAdapter", "mapFormatToGlType", "gl", "BYTES_PER_PIXEL", "GlTextureSystem", "renderer", "glUploadImageResource", "glUploadBufferImageResource", "glUploadVideoResource", "glUploadCompressedTextureResource", "gl", "mapFormatToGlInternalFormat", "mapFormatToGlType", "mapFormatToGlFormat", "i", "Texture", "source", "texture", "location", "glTexture", "style", "sampler", "boundTextures", "GlTexture", "biggestDimension", "firstCreation", "applyStyleParams", "premultipliedAlpha", "bind", "glSampler", "pixels", "width", "height", "canvas", "DOMAdapter", "ctx", "imageData", "resolution", "frame", "renderTarget", "glRenterTarget", "ExtensionType", "DefaultWebGLSystems", "DefaultWebGLPipes", "DefaultWebGLAdapters", "systems", "renderPipes", "renderPipeAdaptors", "WebGLRenderer", "SharedSystems", "GlUboSystem", "GlBackBufferSystem", "GlContextSystem", "GlLimitsSystem", "GlBufferSystem", "GlTextureSystem", "GlRenderTargetSystem", "GlGeometrySystem", "GlUniformGroupSystem", "GlShaderSystem", "GlEncoderSystem", "GlStateSystem", "GlStencilSystem", "GlColorMaskSystem", "SharedRenderPipes", "GlBatchAdaptor", "GlMeshAdaptor", "GlGraphicsAdaptor", "extensions", "ExtensionType", "AbstractRenderer", "systemConfig", "RendererType", "browserExt", "ExtensionType", "webworkerExt", "ExtensionType", "_isWebGLSupported", "isWebGLSupported", "failIfMajorPerformanceCaveat", "contextOptions", "AbstractRenderer", "DOMAdapter", "gl", "success", "loseContext", "_isWebGPUSupported", "isWebGPUSupported", "options", "gpu", "DOMAdapter", "renderPriority", "autoDetectRenderer", "options", "preferredOrder", "item", "RendererClass", "finalOptions", "i", "rendererType", "isWebGPUSupported", "WebGPURenderer", "isWebGLSupported", "AbstractRenderer", "WebGLRenderer", "renderer", "_Application", "args", "Container", "deprecation", "v8_0_0", "options", "autoDetectRenderer", "plugin", "rendererDestroyOptions", "plugins", "Application", "extensions", "ExtensionType", "ApplicationInitHook", "BitmapFont", "AbstractBitmapFont", "options", "url", "textures", "data", "key", "pageData", "texture", "charData", "textureFrame", "textureSource", "textureRotate", "frame", "groupD8", "Rectangle", "Texture", "i", "BitmapFontManager", "name", "bitmapFontTextParser", "data", "txt", "items", "rawData", "i", "name", "attributeList", "itemData", "split", "key", "strValue", "floatValue", "value", "font", "info", "common", "distanceField", "page", "map", "char", "charNode", "id", "letter", "kerning", "first", "second", "amount", "bitmapFontXMLParser", "data", "xml", "info", "common", "distanceField", "page", "char", "kerning", "i", "map", "charNode", "id", "letter", "first", "second", "amount", "bitmapFontXMLStringParser", "data", "bitmapFontXMLParser", "DOMAdapter", "validExtensions", "bitmapFontCachePlugin", "ExtensionType", "asset", "BitmapFont", "keys", "out", "key", "loadBitmapFont", "LoaderParserPriority", "url", "path", "data", "bitmapFontTextParser", "bitmapFontXMLStringParser", "loader", "bitmapFontData", "src", "pages", "textureUrls", "textureOptions", "i", "pageFile", "imagePath", "copySearchParams", "loadedTextures", "textures", "_options", "DOMAdapter", "bitmapFont", "_resolvedAsset", "page", "BackgroundLoader", "loader", "verbose", "assetUrls", "a", "toLoad", "toLoadAmount", "i", "value", "cacheTextureArray", "ExtensionType", "asset", "Texture", "keys", "out", "key", "item", "i", "testImageFormat", "imageData", "resolve", "image", "blob", "detectAvif", "ExtensionType", "testImageFormat", "formats", "f", "imageFormats", "detectDefaults", "ExtensionType", "formats", "f", "inWorker", "testVideoFormat", "mimeType", "detectMp4", "ExtensionType", "testVideoFormat", "formats", "f", "detectOgv", "ExtensionType", "testVideoFormat", "formats", "f", "detectWebm", "ExtensionType", "testVideoFormat", "formats", "f", "detectWebp", "ExtensionType", "testImageFormat", "formats", "f", "_Loader", "target", "key", "value", "url", "data", "result", "asset", "parser", "warn", "i", "parserX", "assetsToLoadIn", "onProgressOrOptions", "options", "onProgress", "onError", "strategy", "retryCount", "retryDelay", "count", "assets", "singleAsset", "isSingleItem", "assetsToLoad", "convertToList", "item", "total", "sum", "promises", "path", "assetsToUnloadIn", "loadPromise", "loadedAsset", "hash", "attempt", "wait", "ms", "r", "e", "isLast", "Loader", "checkDataUrl", "url", "mimes", "mime", "checkExtension", "url", "extension", "tempURL", "ext", "path", "validJSONExtension", "validJSONMIME", "loadJson", "ExtensionType", "LoaderParserPriority", "url", "checkDataUrl", "checkExtension", "DOMAdapter", "validTXTExtension", "validTXTMIME", "loadTxt", "ExtensionType", "LoaderParserPriority", "url", "checkDataUrl", "checkExtension", "DOMAdapter", "validWeights", "validFontExtensions", "validFontMIMEs", "CSS_IDENT_TOKEN_REGEX", "getFontFamilyName", "url", "ext", "path", "nameTokens", "word", "valid", "token", "fontFamilyName", "validURICharactersRegex", "encodeURIWhenNeeded", "uri", "loadWebFont", "ExtensionType", "LoaderParserPriority", "checkDataUrl", "checkExtension", "options", "fonts", "DOMAdapter", "fontFaces", "name", "weights", "weight", "data", "i", "font", "Cache", "warn", "fontFamily", "cached", "entry", "f", "t", "getResolutionOfUrl", "url", "defaultValue", "resolution", "Resolver", "createTexture", "source", "loader", "url", "texture", "Texture", "unload", "Cache", "warn", "validSVGExtension", "validSVGMIME", "loadSvg", "ExtensionType", "LoaderParserPriority", "url", "checkDataUrl", "checkExtension", "asset", "loader", "loadAsGraphics", "loadAsTexture", "crossOrigin", "response", "DOMAdapter", "image", "width", "height", "resolution", "getResolutionOfUrl", "canvasWidth", "canvasHeight", "canvas", "context", "_p", "rest", "base", "ImageSource", "createTexture", "svgSource", "GraphicsContext", "WORKER_CODE", "WORKER_URL", "WorkerInstance", "WORKER_CODE", "WORKER_URL", "WorkerInstance", "UUID", "MAX_WORKERS", "WorkerManagerClass", "resolve", "worker", "CheckImageBitmapWorker", "event", "src", "asset", "LoadImageBitmapWorker", "data", "id", "args", "promise", "reject", "toDo", "WorkerManager", "validImageExtensions", "validImageMIMEs", "loadImageBitmap", "url", "asset", "response", "DOMAdapter", "imageBlob", "loadTextures", "ExtensionType", "LoaderParserPriority", "checkDataUrl", "checkExtension", "loader", "src", "WorkerManager", "resolve", "reject", "base", "ImageSource", "getResolutionOfUrl", "createTexture", "texture", "potentialVideoExtensions", "validVideoExtensions", "validVideoMIMEs", "crossOrigin", "element", "url", "crossorigin", "determineCrossOrigin", "preloadVideo", "resolve", "reject", "loaded", "error", "cleanup", "err", "loc", "parsedUrl", "getBrowserSupportedVideoExtensions", "supportedExtensions", "supportedMimes", "ext", "mimeType", "VideoSource", "testVideoFormat", "loadVideoTextures", "ExtensionType", "ve", "vm", "isValidDataUrl", "checkDataUrl", "isValidExtension", "checkExtension", "asset", "loader", "options", "getResolutionOfUrl", "detectVideoAlphaMode", "videoElement", "attributeMap", "key", "value", "sourceElement", "mime", "onCanPlay", "base", "createTexture", "texture", "resolveTextureUrl", "ExtensionType", "loadTextures", "value", "Resolver", "resolveJsonUrl", "ExtensionType", "value", "Resolver", "resolveTextureUrl", "AssetsClass", "Resolver", "Loader", "Cache", "BackgroundLoader", "options", "warn", "manifest", "resolutionPref", "resolution", "formats", "assets", "urls", "onProgress", "singleAsset", "isSingleItem", "urlArray", "convertToList", "url", "aliases", "alias", "resolveResults", "out", "bundleId", "bundleIds", "keys", "total", "counts", "_onProgress", "a", "b", "promises", "i", "resolveResult", "values", "progressSize", "sum", "asset", "e", "progressOrLoadOptions", "resolveArray", "loadedAssets", "key", "detection", "format", "index", "preferences", "parser", "Assets", "extensions", "ExtensionType", "cacheTextureArray", "detectDefaults", "detectAvif", "detectWebp", "detectMp4", "detectOgv", "detectWebm", "loadJson", "loadTxt", "loadWebFont", "loadSvg", "loadTextures", "loadVideoTextures", "loadBitmapFont", "bitmapFontCachePlugin", "resolveTextureUrl", "resolveJsonUrl", "assetKeyMap", "extension", "ref", "type", "AbstractText", "ViewContainer", "options", "styleClass", "text", "resolution", "style", "anchor", "width", "height", "roundPixels", "rest", "ObservablePoint", "value", "out", "point", "x1", "y1", "ensureTextOptions", "args", "name", "deprecation", "v8_0_0", "Text", "AbstractText", "args", "options", "ensureTextOptions", "TextStyle", "TextureStyle", "bounds", "anchor", "width", "height", "frame", "canvasAndContext", "CanvasTextGenerator", "canvasMeasurement", "CanvasTextMetrics", "extensions", "browserExt", "webworkerExt", "openFullscreen", "elem", "closeFullscreen", "pixi_large_text", "TextStyle", "pixi_huge_text", "shuffle", "arr_in", "inplace", "arr", "i", "j", "temp", "any", "getRandomFloat", "min", "max", "epochTimestamp", "download", "filename", "content", "mimeType", "a", "blob", "url", "app", "Application", "defaultConfig", "DATA_SERVER_PORT", "VISUAL_STIM_PATH", "WS_URL", "socket", "MAX_RECONNECT", "reconnect_count", "reconnect_timeout", "startConfigFromUrl", "params", "updateConfig", "input_config", "defaultConfig", "config", "key", "param_val", "updateSearchURL", "start_config", "curr_url_search_string", "url_params", "val", "new_url", "setupPixiApp", "parentElement", "app", "prepVisStimCtrlPanel", "control_panel_div", "timing_form", "createDiv", "start_baseline_input_id", "start_baseline_label", "createLabel", "start_baseline_input", "createNumInput", "end_baseline_input_id", "end_baseline_label", "end_baseline_input", "start_fixation_input_id", "start_fixation_label", "start_fixation_input", "end_white_input_id", "end_white_label", "end_white_input", "jitter_input_id", "jitter_label", "event", "add_vis_stim_in", "files", "addVisStimSet", "add_vis_sim_btn", "vis_stim", "stim_info_list", "play_stim_div", "show_progress", "show_progress_set", "createSwitch", "show_progress_input", "shuffle_between", "shuffle_between_set", "shuffle_between_input", "shuffle_within", "shuffle_within_set", "shuffle_within_input", "play_stim_button", "timeout", "my_promise", "stim_order_i", "stim_set_i", "stim_seq_i", "event_list", "eventGen", "epoch_time_ms", "type", "verbose", "e", "socket", "epochTimestamp", "stim_seq", "generateStimSeq", "on_key_down", "openFullscreen", "stim_set", "stim_i", "start", "baseline_start", "show_stim_sequence", "baseline_end", "closeFullscreen", "exitExperiment", "clearCanvas", "count_down", "interval_ms", "i", "delay_ms", "showPixiText", "timestamp", "event_end", "sprite", "fixation_time_ms", "getRandomFloat", "pixi_huge_text", "delay", "time_ms", "callback", "resolve", "reject", "err", "download", "info", "files_arr", "id_num", "stim_row_div", "setting_div", "title_card", "title_header", "title_header_content", "title_card_content", "num_repeat_input_id", "num_repeat_label", "num_repeat_input", "stim_show_time_input_id", "stim_show_time_label", "stim_show_time_input", "stims_div", "img_card_id", "card", "header", "header_content", "card_img", "reader", "img", "imageUrl", "createSprite", "infos", "stim_seqs", "stim_set_repeat_left", "any", "set_i", "set_seq", "shuffle", "txt", "text_style", "pixi_large_text", "pre_baseline_text", "Text", "texture", "Assets", "Sprite", "id", "parent", "for_id", "classList", "textContent", "myLabel", "configureHTMLElement", "min", "max", "step", "myNumInput", "myDiv", "labeltext", "eventHandler", "label", "input", "icon", "ws_connect", "WS_URL", "reconnect_count", "MAX_RECONNECT", "reconnect_timeout", "prepVisStimCtrlPanel", "startConfigFromUrl"]
}
